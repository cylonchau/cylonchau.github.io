<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>kube-schedulerçš„è°ƒåº¦ä¸Šä¸‹æ–‡ | Cylon&#39;s Collection</title>
<meta name="keywords" content="kubernetes, develop">
<meta name="description" content="kube-schedulerçš„è°ƒåº¦ä¸Šä¸‹æ–‡ - Cylon&#39;s Collection">
<meta name="author" content="cylon">
<link rel="canonical" href="https://www.oomkill.com/2022/07/ch20-schedule-workflow/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.41a8706089174fae1769fc26da4d1d354fa88083db604a95688ff58852dd9006.css" integrity="sha256-QahwYIkXT64Xafwm2k0dNU&#43;ogIPbYEqVaI/1iFLdkAY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.oomkill.com/favicon.ico">
<link rel="apple-touch-icon" href="https://www.oomkill.com/apple-touch-icon.png">

<meta name="twitter:title" content="kube-schedulerçš„è°ƒåº¦ä¸Šä¸‹æ–‡ | Cylon&#39;s Collection" />
<meta name="twitter:description" content="" />
<meta property="og:title" content="kube-schedulerçš„è°ƒåº¦ä¸Šä¸‹æ–‡ | Cylon&#39;s Collection" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.oomkill.com/2022/07/ch20-schedule-workflow/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2022-07-21T00:00:00&#43;00:00" />
  <meta property="article:modified_time" content="2022-07-21T00:00:00&#43;00:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://www.oomkill.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "kube-schedulerçš„è°ƒåº¦ä¸Šä¸‹æ–‡",
      "item": "https://www.oomkill.com/2022/07/ch20-schedule-workflow/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "kube-schedulerçš„è°ƒåº¦ä¸Šä¸‹æ–‡ | Cylon's Collection",
  "name": "kube-schedulerçš„è°ƒåº¦ä¸Šä¸‹æ–‡",
  "description": "",
  "keywords": [
    "kubernetes", "develop"
  ],
  "wordCount" : "7452",
  "inLanguage": "zh",
  "datePublished": "2022-07-21T00:00:00Z",
  "dateModified": "2022-07-21T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "cylon"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.oomkill.com/2022/07/ch20-schedule-workflow/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cylon's Collection",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.oomkill.com/favicon.ico"
    }
  }
}
</script><script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary-bg: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list-page {
                background: var(--theme);
            }

            .list-page:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list-page:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

</head>

<body class=" type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'auto';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.oomkill.com" accesskey="h" title="Cylon&#39;s Collection (Alt + H)">Cylon&#39;s Collection</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.oomkill.com/archives/" title="å½’æ¡£"
                >å½’æ¡£
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/tags/" title="æ ‡ç­¾"
                >æ ‡ç­¾
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/search/" title="æœç´¢ (Alt &#43; /)"data-no-instant accesskey=/
                >æœç´¢
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/about/" title="å…³äº"
                >å…³äº
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header"><h1 class="post-title">kube-schedulerçš„è°ƒåº¦ä¸Šä¸‹æ–‡</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>2022-07-21</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>Edited on 2022-07-21</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://www.oomkill.com/tags/kubernetes-develop/">kubernetes develop</a><a href="https://www.oomkill.com/tags/kubernetes/">kubernetes</a></span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><circle cx="12" cy="12" r="9"></circle><polyline points="12 7 12 12 15 15"></polyline></svg>
  <span>15 åˆ†é’Ÿ</span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">ç›®å½•</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#scheduler" aria-label="Scheduler">Scheduler</a></li>
                <li>
                    <a href="#schedulingqueue" aria-label="SchedulingQueue">SchedulingQueue</a></li>
                <li>
                    <a href="#%e8%b0%83%e5%ba%a6%e4%b8%8a%e4%b8%8b%e6%96%87" aria-label="è°ƒåº¦ä¸Šä¸‹æ–‡">è°ƒåº¦ä¸Šä¸‹æ–‡</a><ul>
                        
                <li>
                    <a href="#sort" aria-label="Sort">Sort</a></li>
                <li>
                    <a href="#prefilter" aria-label="preFilter">preFilter</a></li>
                <li>
                    <a href="#filter" aria-label="filter">filter</a></li>
                <li>
                    <a href="#postfilter" aria-label="Postfilter">Postfilter</a></li>
                <li>
                    <a href="#prescorescore" aria-label="PreScore,Score">PreScore,Score</a></li>
                <li>
                    <a href="#reserve" aria-label="Reserve">Reserve</a></li>
                <li>
                    <a href="#permit" aria-label="permit">permit</a></li>
                <li>
                    <a href="#binding-cycle" aria-label="Binding Cycle">Binding Cycle</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%b0%83%e5%ba%a6%e4%b8%8a%e4%b8%8b%e6%96%87%e4%b8%ad%e7%9a%84%e5%a4%b1%e8%b4%a5%e6%b5%81%e7%a8%8b" aria-label="è°ƒåº¦ä¸Šä¸‹æ–‡ä¸­çš„å¤±è´¥æµç¨‹">è°ƒåº¦ä¸Šä¸‹æ–‡ä¸­çš„å¤±è´¥æµç¨‹</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93%e8%b0%83%e5%ba%a6%e4%b8%8a%e4%b8%8b%e6%96%87%e6%b5%81%e7%a8%8b" aria-label="æ€»ç»“è°ƒåº¦ä¸Šä¸‹æ–‡æµç¨‹">æ€»ç»“è°ƒåº¦ä¸Šä¸‹æ–‡æµç¨‹</a></li>
                <li>
                    <a href="#reference" aria-label="Reference">Reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content">
    





<div class="copyrightTopBlock">
    <p>æœ¬æ–‡å‘å¸ƒäº<a href="https://www.oomkill.com/about" target="_blank">Cylonçš„æ”¶è—å†Œ</a>ï¼Œè½¬è½½è¯·è‘—ååŸæ–‡é“¾æ¥~</p>
    <div class="articleSuffix-bg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 147.78 155.96"> <path d="M10.5,99.81a1.9,1.9,0,0,0-.53-.09,1.66,1.66,0,0,0-1.64,1.65A1.64,1.64,0,0,0,10,103a1.57,1.57,0,0,0,.87-.25l26.76,26.82.45-1.08L11.52,101.91A1.65,1.65,0,0,0,10.5,99.81Zm-.13,2a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.58.58,0,0,1,.57-.57h0a.57.57,0,0,1,.56.58A.55.55,0,0,1,10.37,101.77Z" style="fill:#c5c9e0"></path><path d="M56.15,117.58H39.06l0-.09a1.65,1.65,0,0,0-1.36-1H37.5a1.65,1.65,0,1,0,1.56,2.19H55.7L92.92,156h41.44v-1.08h-41Zm-18.25.94a.56.56,0,0,1-.79,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h0a.58.58,0,0,1,.57.58A.54.54,0,0,1,37.9,118.52Z" style="fill:#c5c9e0"></path><path d="M23.52,50.32a1.65,1.65,0,0,0,1.55-1.11H55.28l48-48.13h31.06V0H102.85l-48,48.13H25.07a1.64,1.64,0,0,0-2.09-1,1.64,1.64,0,0,0,.54,3.2Zm0-2.21a.57.57,0,0,1,0,1.13.57.57,0,1,1,0-1.13Z" style="fill:#c5c9e0"></path><polygon points="102.86 0 102.86 0 102.86 0 102.86 0" style="fill:#c5c9e0"></polygon><path d="M107.72,12.14h26.64V11.07H107.27L57.4,61H3.09a1.66,1.66,0,0,0-1.45-.86H1.52A1.65,1.65,0,1,0,2.81,63a1.59,1.59,0,0,0,.45-.87H57.85ZM2.05,62.23a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h.09a.57.57,0,0,1,.32,1Z" style="fill:#c5c9e0"></path><path d="M134.36,43.22V42.14h-22.3l-9.62,9.63a1.64,1.64,0,0,0-2.19.77,1.61,1.61,0,0,0-.17.71,1.65,1.65,0,1,0,3.29,0,1.61,1.61,0,0,0-.16-.72l9.3-9.32Zm-32.64,10.6a.57.57,0,0,1,0-1.13.57.57,0,0,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M147,52.3l-9,9H111.48a1.64,1.64,0,0,0-1.61-1.33h-.14a1.65,1.65,0,1,0,1.6,2.41h27.19l9.26-9.29L147,52.3Zm-37.15,9.85a.56.56,0,0,1-.56-.57h0a.56.56,0,0,1,.56-.56h0a.57.57,0,1,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M66.79,75.35l11,11.06h56.53V85.33H78.27l-11-11.06H49.49L37.12,86.67a1.64,1.64,0,0,0-2.09,1,1.61,1.61,0,0,0-.09.54,1.65,1.65,0,0,0,3.29,0,1.68,1.68,0,0,0-.26-.89l12-12ZM36.58,88.79a.57.57,0,1,1,.57-.56A.57.57,0,0,1,36.58,88.79Z" style="fill:#c5c9e0"></path><path d="M110.61,95.55,92.8,113.4a1.62,1.62,0,1,0,.77.76l17.49-17.53h23.31V95.55ZM92.49,115.28a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.57-.57h0a.58.58,0,0,1,.56.58A.55.55,0,0,1,92.49,115.28Z" style="fill:#c5c9e0"></path><path d="M97.89,122.3H76.62L64.2,109.85a1.65,1.65,0,0,0-.77-2.2,1.77,1.77,0,0,0-.72-.17h-.14a1.65,1.65,0,0,0,.15,3.29,1.58,1.58,0,0,0,.71-.17l12.74,12.77H98.34l17.48-17.52h18.54v-1.08h-19ZM63.12,109.53a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,1.14,0A.54.54,0,0,1,63.12,109.53Z" style="fill:#c5c9e0"></path> </svg> </div>
</div>
<br><h2 id="scheduler">Scheduler<a hidden class="anchor" aria-hidden="true" href="#scheduler">Â¶</a></h2>
<p><a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/scheduler.go#L64-L102" target="_blank"
   rel="noopener nofollow noreferrer" >Scheduler</a> æ˜¯æ•´ä¸ª <code>kube-scheduler</code> çš„ä¸€ä¸ª structureï¼Œæä¾›äº† <code>kube-scheduler</code> è¿è¡Œæ‰€éœ€çš„ç»„ä»¶ã€‚</p>
<pre><code class="language-go">type Scheduler struct {
	// Cacheæ˜¯ä¸€ä¸ªæŠ½è±¡ï¼Œä¼šç¼“å­˜podçš„ä¿¡æ¯ï¼Œä½œä¸ºschedulerè¿›è¡ŒæŸ¥æ‰¾ï¼Œæ“ä½œæ˜¯åŸºäºPodè¿›è¡Œå¢åŠ 
	Cache internalcache.Cache
	// Extenders ç®—æ˜¯è°ƒåº¦æ¡†æ¶ä¸­æä¾›çš„è°ƒåº¦æ’ä»¶ï¼Œä¼šå½±å“kubernetesä¸­çš„è°ƒåº¦ç­–ç•¥
	Extenders []framework.Extender

	// NextPod ä½œä¸ºä¸€ä¸ªå‡½æ•°æä¾›ï¼Œä¼šé˜»å¡è·å–ä¸‹ä¸€ä¸ªke'diao'du
	NextPod func() *framework.QueuedPodInfo

	// Error is called if there is an error. It is passed the pod in
	// question, and the error
	Error func(*framework.QueuedPodInfo, error)

	// SchedulePod å°è¯•å°†ç»™å‡ºçš„podè°ƒåº¦åˆ°Nodeã€‚
	SchedulePod func(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) (ScheduleResult, error)

	// å…³é—­schedulerçš„ä¿¡å·
	StopEverything &lt;-chan struct{}

	// SchedulingQueueä¿å­˜è¦è°ƒåº¦çš„Pod
	SchedulingQueue internalqueue.SchedulingQueue

	// Profilesä¸­æ˜¯å¤šä¸ªè°ƒåº¦æ¡†æ¶
	Profiles profile.Map
	client clientset.Interface
	nodeInfoSnapshot *internalcache.Snapshot
	percentageOfNodesToScore int32
	nextStartNodeIndex int
}
</code></pre>
<p>ä½œä¸ºå®é™…æ‰§è¡Œçš„ä¸¤ä¸ªæ ¸å¿ƒï¼Œ<code>SchedulingQueue</code> ï¼Œä¸ <code>scheduleOne</code> å°†ä¼šåˆ†æåˆ°è¿™ä¸¤ä¸ª</p>
<h2 id="schedulingqueue">SchedulingQueue<a hidden class="anchor" aria-hidden="true" href="#schedulingqueue">Â¶</a></h2>
<p>åœ¨çŸ¥é“ <code>kube-scheduler</code> åˆå§‹åŒ–è¿‡ç¨‹åï¼Œéœ€è¦å¯¹ <code>kube-scheduler</code> çš„æ•´ä¸ª <em>structure</em> å’Œ <em>workflow</em> è¿›è¡Œåˆ†æ</p>
<p>åœ¨ <a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/scheduler.go#L336-L340" target="_blank"
   rel="noopener nofollow noreferrer" >Run</a> ä¸­ï¼Œè¿è¡Œçš„æ˜¯ ä¸€ä¸ª <code>SchedulingQueue</code> ä¸ ä¸€ä¸ª <code>scheduleOne</code> ï¼Œä»ç»“æ„ä¸Šçœ‹æ˜¯å±äº <em>Scheduler</em></p>
<pre><code class="language-go">func (sched *Scheduler) Run(ctx context.Context) {
	sched.SchedulingQueue.Run()

	// We need to start scheduleOne loop in a dedicated goroutine,
	// because scheduleOne function hangs on getting the next item
	// from the SchedulingQueue.
	// If there are no new pods to schedule, it will be hanging there
	// and if done in this goroutine it will be blocking closing
	// SchedulingQueue, in effect causing a deadlock on shutdown.
	go wait.UntilWithContext(ctx, sched.scheduleOne, 0)

	&lt;-ctx.Done()
	sched.SchedulingQueue.Close()
}

</code></pre>
<p><a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/internal/queue/scheduling_queue.go#L81-L110" target="_blank"
   rel="noopener nofollow noreferrer" >SchedulingQueue</a> æ˜¯ä¸€ä¸ªé˜Ÿåˆ—çš„æŠ½è±¡ï¼Œç”¨äºå­˜å‚¨ç­‰å¾…è°ƒåº¦çš„Podã€‚è¯¥æ¥å£éµå¾ªç±»ä¼¼äº cache.FIFO å’Œ cache.Heap çš„æ¨¡å¼ã€‚</p>
<pre><code class="language-go">type SchedulingQueue interface {
	framework.PodNominator
	Add(pod *v1.Pod) error
	// Activate moves the given pods to activeQ iff they're in unschedulablePods or backoffQ.
	// The passed-in pods are originally compiled from plugins that want to activate Pods,
	// by injecting the pods through a reserved CycleState struct (PodsToActivate).
	Activate(pods map[string]*v1.Pod)
	// å°†ä¸å¯è°ƒåº¦çš„Podé‡å…¥åˆ°é˜Ÿåˆ—ä¸­
	AddUnschedulableIfNotPresent(pod *framework.QueuedPodInfo, podSchedulingCycle int64) error
	// SchedulingCycle returns the current number of scheduling cycle which is
	// cached by scheduling queue. Normally, incrementing this number whenever
	// a pod is popped (e.g. called Pop()) is enough.
	SchedulingCycle() int64
	// Popä¼šå¼¹å‡ºä¸€ä¸ªpodï¼Œå¹¶ä»headä¼˜å…ˆçº§é˜Ÿåˆ—ä¸­åˆ é™¤
	Pop() (*framework.QueuedPodInfo, error)
	Update(oldPod, newPod *v1.Pod) error
	Delete(pod *v1.Pod) error
	MoveAllToActiveOrBackoffQueue(event framework.ClusterEvent, preCheck PreEnqueueCheck)
	AssignedPodAdded(pod *v1.Pod)
	AssignedPodUpdated(pod *v1.Pod)
	PendingPods() []*v1.Pod
	// Close closes the SchedulingQueue so that the goroutine which is
	// waiting to pop items can exit gracefully.
	Close()
	// Run starts the goroutines managing the queue.
	Run()
}
</code></pre>
<p>è€Œ <a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/internal/queue/scheduling_queue.go#L134-L175" target="_blank"
   rel="noopener nofollow noreferrer" >PriorityQueue</a> æ˜¯ <code>SchedulingQueue</code> çš„å®ç°ï¼Œè¯¥éƒ¨åˆ†çš„æ ¸å¿ƒæ„æˆæ˜¯ä¸¤ä¸ªå­é˜Ÿåˆ—ä¸ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œå³ <code>activeQ</code>ã€<code>backoffQ</code> å’Œ <code>unschedulablePods</code></p>
<ul>
<li><code>activeQ</code>ï¼šæ˜¯ä¸€ä¸ª <em>heap</em> ç±»å‹çš„ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæ˜¯ <em>sheduler</em> ä»ä¸­è·å¾—ä¼˜å…ˆçº§æœ€é«˜çš„Podè¿›è¡Œè°ƒåº¦</li>
<li><code>backoffQ</code>ï¼šä¹Ÿæ˜¯ä¸€ä¸ª <em>heap</em> ç±»å‹çš„ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œå­˜æ”¾çš„æ˜¯ä¸å¯è°ƒåº¦çš„Pod</li>
<li><code>unschedulablePods </code>ï¼šä¿å­˜ç¡®å®šä¸å¯è¢«è°ƒåº¦çš„Pod</li>
</ul>
<pre><code class="language-GO">type SchedulingQueue interface {
	framework.PodNominator
	Add(pod *v1.Pod) error
	// Activate moves the given pods to activeQ iff they're in unschedulablePods or backoffQ.
	// The passed-in pods are originally compiled from plugins that want to activate Pods,
	// by injecting the pods through a reserved CycleState struct (PodsToActivate).
	Activate(pods map[string]*v1.Pod)
	// AddUnschedulableIfNotPresent adds an unschedulable pod back to scheduling queue.
	// The podSchedulingCycle represents the current scheduling cycle number which can be
	// returned by calling SchedulingCycle().
	AddUnschedulableIfNotPresent(pod *framework.QueuedPodInfo, podSchedulingCycle int64) error
	// SchedulingCycle returns the current number of scheduling cycle which is
	// cached by scheduling queue. Normally, incrementing this number whenever
	// a pod is popped (e.g. called Pop()) is enough.
	SchedulingCycle() int64
	// Pop removes the head of the queue and returns it. It blocks if the
	// queue is empty and waits until a new item is added to the queue.
	Pop() (*framework.QueuedPodInfo, error)
	Update(oldPod, newPod *v1.Pod) error
	Delete(pod *v1.Pod) error
	MoveAllToActiveOrBackoffQueue(event framework.ClusterEvent, preCheck PreEnqueueCheck)
	AssignedPodAdded(pod *v1.Pod)
	AssignedPodUpdated(pod *v1.Pod)
	PendingPods() []*v1.Pod
	// Close closes the SchedulingQueue so that the goroutine which is
	// waiting to pop items can exit gracefully.
	Close()
	// Run starts the goroutines managing the queue.
	Run()
}
</code></pre>
<p>åœ¨New <em>scheduler</em> æ—¶å¯ä»¥çœ‹åˆ°ä¼šåˆå§‹åŒ–è¿™ä¸ªqueue</p>
<pre><code class="language-go">podQueue := internalqueue.NewSchedulingQueue(
    // å®ç°podå¯¹æ¯”çš„ä¸€ä¸ªå‡½æ•°å³less
    profiles[options.profiles[0].SchedulerName].QueueSortFunc(),
    informerFactory,
    internalqueue.WithPodInitialBackoffDuration(time.Duration(options.podInitialBackoffSeconds)*time.Second),
    internalqueue.WithPodMaxBackoffDuration(time.Duration(options.podMaxBackoffSeconds)*time.Second),
    internalqueue.WithPodNominator(nominator),
    internalqueue.WithClusterEventMap(clusterEventMap),
    internalqueue.WithPodMaxInUnschedulablePodsDuration(options.podMaxInUnschedulablePodsDuration),
)
</code></pre>
<p>è€Œ <a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/internal/queue/scheduling_queue.go#L252-L289" target="_blank"
   rel="noopener nofollow noreferrer" >NewSchedulingQueue</a> åˆ™æ˜¯åˆå§‹åŒ–è¿™ä¸ª PriorityQueue</p>
<pre><code class="language-go">// NewSchedulingQueue initializes a priority queue as a new scheduling queue.
func NewSchedulingQueue(
	lessFn framework.LessFunc,
	informerFactory informers.SharedInformerFactory,
	opts ...Option) SchedulingQueue {
	return NewPriorityQueue(lessFn, informerFactory, opts...)
}

// NewPriorityQueue creates a PriorityQueue object.
func NewPriorityQueue(
	lessFn framework.LessFunc,
	informerFactory informers.SharedInformerFactory,
	opts ...Option,
) *PriorityQueue {
	options := defaultPriorityQueueOptions
	for _, opt := range opts {
		opt(&amp;options)
	}
	// è¿™ä¸ªå°±æ˜¯ lesså‡½æ•°ï¼Œä½œä¸ºæ‰“åˆ†çš„ä¸€éƒ¨åˆ†
	comp := func(podInfo1, podInfo2 interface{}) bool {
		pInfo1 := podInfo1.(*framework.QueuedPodInfo)
		pInfo2 := podInfo2.(*framework.QueuedPodInfo)
		return lessFn(pInfo1, pInfo2)
	}

	if options.podNominator == nil {
		options.podNominator = NewPodNominator(informerFactory.Core().V1().Pods().Lister())
	}

	pq := &amp;PriorityQueue{
		PodNominator:                      options.podNominator,
		clock:                             options.clock,
		stop:                              make(chan struct{}),
		podInitialBackoffDuration:         options.podInitialBackoffDuration,
		podMaxBackoffDuration:             options.podMaxBackoffDuration,
		podMaxInUnschedulablePodsDuration: options.podMaxInUnschedulablePodsDuration,
		activeQ:                           heap.NewWithRecorder(podInfoKeyFunc, comp, metrics.NewActivePodsRecorder()),
		unschedulablePods:                 newUnschedulablePods(metrics.NewUnschedulablePodsRecorder()),
		moveRequestCycle:                  -1,
		clusterEventMap:                   options.clusterEventMap,
	}
	pq.cond.L = &amp;pq.lock
	pq.podBackoffQ = heap.NewWithRecorder(podInfoKeyFunc, pq.podsCompareBackoffCompleted, metrics.NewBackoffPodsRecorder())
	pq.nsLister = informerFactory.Core().V1().Namespaces().Lister()

	return pq
}
</code></pre>
<p>äº†è§£äº†Queueçš„ç»“æ„ï¼Œå°±éœ€è¦çŸ¥é“ å…¥é˜Ÿåˆ—ä¸å‡ºé˜Ÿåˆ—æ˜¯åœ¨å“ªé‡Œæ“ä½œçš„ã€‚åœ¨åˆå§‹åŒ–æ—¶ï¼Œéœ€è¦æ³¨å†Œä¸€ä¸ª <code>addEventHandlerFuncs</code> è¿™ä¸ªæ—¶å€™ï¼Œä¼šæ³¨å…¥ä¸‰ä¸ªåŠ¨ä½œå‡½æ•°ï¼Œä¹Ÿå°±æ˜¯controllerä¸­çš„æ¦‚å¿µï¼›è€Œåœ¨AddFuncä¸­å¯ä»¥çœ‹åˆ°ä¼šå…¥é˜Ÿåˆ—ã€‚</p>
<p>æ³¨å…¥æ˜¯å¯¹ Pod çš„<a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/eventhandlers.go#L302-L305" target="_blank"
   rel="noopener nofollow noreferrer" >informer</a>æ³¨å…¥çš„ï¼Œæ³¨å…¥çš„å‡½æ•° <a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/eventhandlers.go#L114-L120" target="_blank"
   rel="noopener nofollow noreferrer" >addPodToSchedulingQueue</a>  å°±æ˜¯å…¥æ ˆ</p>
<pre><code class="language-go">Handler: cache.ResourceEventHandlerFuncs{
    AddFunc:    sched.addPodToSchedulingQueue,
    UpdateFunc: sched.updatePodInSchedulingQueue,
    DeleteFunc: sched.deletePodFromSchedulingQueue,
},

func (sched *Scheduler) addPodToSchedulingQueue(obj interface{}) {
	pod := obj.(*v1.Pod)
	klog.V(3).InfoS(&quot;Add event for unscheduled pod&quot;, &quot;pod&quot;, klog.KObj(pod))
	if err := sched.SchedulingQueue.Add(pod); err != nil {
		utilruntime.HandleError(fmt.Errorf(&quot;unable to queue %T: %v&quot;, obj, err))
	}
}
</code></pre>
<p>è€Œè¿™ä¸ª <code>SchedulingQueue</code> çš„å®ç°å°±æ˜¯ <code>PriorityQueue</code> ï¼Œè€ŒAddä¸­åˆ™å¯¹ activeQè¿›è¡Œçš„æ“ä½œ</p>
<pre><code class="language-go">func (p *PriorityQueue) Add(pod *v1.Pod) error {
	p.lock.Lock()
	defer p.lock.Unlock()
    // æ ¼å¼åŒ–å…¥æ ˆæ•°æ®ï¼ŒåŒ…å«podinfoï¼Œé‡Œä¼šåŒ…å«v1.Pod
    // åˆå§‹åŒ–çš„æ—¶é—´ï¼Œåˆ›å»ºçš„æ—¶é—´ï¼Œä»¥åŠä¸èƒ½è¢«è°ƒåº¦æ—¶çš„è®°å½•å…¶pluginçš„åç§°
	pInfo := p.newQueuedPodInfo(pod)
    // å…¥æ ˆ
	if err := p.activeQ.Add(pInfo); err != nil {
		klog.ErrorS(err, &quot;Error adding pod to the active queue&quot;, &quot;pod&quot;, klog.KObj(pod))
		return err
	}
	if p.unschedulablePods.get(pod) != nil {
		klog.ErrorS(nil, &quot;Error: pod is already in the unschedulable queue&quot;, &quot;pod&quot;, klog.KObj(pod))
		p.unschedulablePods.delete(pod)
	}
	// Delete pod from backoffQ if it is backing off
	if err := p.podBackoffQ.Delete(pInfo); err == nil {
		klog.ErrorS(nil, &quot;Error: pod is already in the podBackoff queue&quot;, &quot;pod&quot;, klog.KObj(pod))
	}
	metrics.SchedulerQueueIncomingPods.WithLabelValues(&quot;active&quot;, PodAdd).Inc()
	p.PodNominator.AddNominatedPod(pInfo.PodInfo, nil)
	p.cond.Broadcast()

	return nil
}
</code></pre>
<p>åœ¨ä¸Šé¢çœ‹ <em>scheduler</em> ç»“æ„æ—¶ï¼Œå¯ä»¥çœ‹åˆ°æœ‰ä¸€ä¸ª nextPodçš„ï¼ŒnextPodå°±æ˜¯ä»é˜Ÿåˆ—ä¸­å¼¹å‡ºä¸€ä¸ªpodï¼Œè¿™ä¸ªåœ¨<em>scheduler</em> æ—¶ä¼šä¼ å…¥ <a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/internal/queue/scheduling_queue.go#L952-L965" target="_blank"
   rel="noopener nofollow noreferrer" >MakeNextPodFunc</a> å°±æ˜¯è¿™ä¸ª nextpod</p>
<pre><code class="language-go">func MakeNextPodFunc(queue SchedulingQueue) func() *framework.QueuedPodInfo {
	return func() *framework.QueuedPodInfo {
		podInfo, err := queue.Pop()
		if err == nil {
			klog.V(4).InfoS(&quot;About to try and schedule pod&quot;, &quot;pod&quot;, klog.KObj(podInfo.Pod))
			for plugin := range podInfo.UnschedulablePlugins {
				metrics.UnschedulableReason(plugin, podInfo.Pod.Spec.SchedulerName).Dec()
			}
			return podInfo
		}
		klog.ErrorS(err, &quot;Error while retrieving next pod from scheduling queue&quot;)
		return nil
	}
}
</code></pre>
<p>è€Œè¿™ä¸ª <code>queue.Pop()</code> å¯¹åº”çš„å°±æ˜¯ <code>PriorityQueue</code> çš„ <a href="https://github.com/kubernetes/kubernetes/blob/140c27533044e9e00f800d3ad0517540e3e4ecad/pkg/scheduler/internal/queue/scheduling_queue.go#L483-L503" target="_blank"
   rel="noopener nofollow noreferrer" >Pop()</a> ï¼Œåœ¨è¿™é‡Œä¼šå°†ä½œä¸º activeQ çš„æ¶ˆè´¹ç«¯</p>
<pre><code class="language-go">func (p *PriorityQueue) Pop() (*framework.QueuedPodInfo, error) {
   p.lock.Lock()
   defer p.lock.Unlock()
   for p.activeQ.Len() == 0 {
      // When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
      // When Close() is called, the p.closed is set and the condition is broadcast,
      // which causes this loop to continue and return from the Pop().
      if p.closed {
         return nil, fmt.Errorf(queueClosed)
      }
      p.cond.Wait()
   }
   obj, err := p.activeQ.Pop()
   if err != nil {
      return nil, err
   }
   pInfo := obj.(*framework.QueuedPodInfo)
   pInfo.Attempts++
   p.schedulingCycle++
   return pInfo, nil
}
</code></pre>
<p>åœ¨ä¸Šé¢å…¥å£éƒ¨åˆ†ä¹Ÿçœ‹åˆ°äº†ï¼ŒscheduleOne å’Œ schedulerï¼ŒscheduleOne å°±æ˜¯å»æ¶ˆè´¹ä¸€ä¸ªPodï¼Œä»–ä¼šè°ƒç”¨ NextPodï¼ŒNextPodå°±æ˜¯åœ¨åˆå§‹åŒ–ä¼ å…¥çš„ <code>MakeNextPodFunc</code> ï¼Œè‡³æ­¤å›åˆ°å¯¹åº”çš„ Popæ¥åšæ¶ˆè´¹ã€‚</p>
<p>schedulerOneæ˜¯ä¸ºä¸€ä¸ªPodåšè°ƒåº¦çš„æµç¨‹ã€‚</p>
<pre><code class="language-go">func (sched *Scheduler) scheduleOne(ctx context.Context) {
	podInfo := sched.NextPod()
	// pod could be nil when schedulerQueue is closed
	if podInfo == nil || podInfo.Pod == nil {
		return
	}
	pod := podInfo.Pod
	fwk, err := sched.frameworkForPod(pod)
	if err != nil {
		// This shouldn't happen, because we only accept for scheduling the pods
		// which specify a scheduler name that matches one of the profiles.
		klog.ErrorS(err, &quot;Error occurred&quot;)
		return
	}
	if sched.skipPodSchedule(fwk, pod) {
		return
	}
...
</code></pre>
<h2 id="è°ƒåº¦ä¸Šä¸‹æ–‡">è°ƒåº¦ä¸Šä¸‹æ–‡<a hidden class="anchor" aria-hidden="true" href="#è°ƒåº¦ä¸Šä¸‹æ–‡">Â¶</a></h2>
<p>å½“äº†è§£äº†schedulerç»“æ„åï¼Œä¸‹é¢åˆ†æä¸‹è°ƒåº¦ä¸Šä¸‹æ–‡çš„è¿‡ç¨‹ã€‚çœ‹çœ‹æ‰©å±•ç‚¹æ˜¯æ€ä¹ˆå·¥ä½œçš„ã€‚è¿™ä¸ªæ—¶å€™åˆéœ€è¦æåˆ°å®˜ç½‘çš„è°ƒåº¦ä¸Šä¸‹æ–‡çš„å›¾ã€‚</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/scheduling-framework-extensions.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center class="podsc">å›¾1ï¼šPodçš„è°ƒåº¦ä¸Šä¸‹æ–‡</center>
<center><em>Sourceï¼š</em>https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework</center>
<p>è€Œ <em>scheduler</em> å¯¹äºè°ƒåº¦ä¸Šä¸‹æ–‡æ¥å°±æ˜¯è¿™ä¸ª <code>scheduleOne </code> ï¼Œä¸‹é¢å°±æ˜¯çœ‹è¿™ä¸ªè°ƒåº¦ä¸Šä¸‹æ–‡</p>
<h3 id="sort">Sort<a hidden class="anchor" aria-hidden="true" href="#sort">Â¶</a></h3>
<p><code>Sort</code> æ’ä»¶æä¾›äº†æ’åºåŠŸèƒ½ï¼Œç”¨äºå¯¹åœ¨è°ƒåº¦é˜Ÿåˆ—ä¸­å¾…å¤„ç† Pod è¿›è¡Œæ’åºã€‚ä¸€æ¬¡åªèƒ½å¯ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ’åºã€‚</p>
<p>åœ¨è¿›å…¥ <code>scheduleOne</code> åï¼Œ<code>NextPod</code> ä» <code>activeQ</code> ä¸­é˜Ÿåˆ—ä¸­å¾—åˆ°ä¸€ä¸ªPodï¼Œç„¶åçš„ <code>frameworkForPod</code> ä¼šåšæ‰“åˆ†çš„åŠ¨ä½œå°±æ˜¯è°ƒåº¦ä¸Šä¸‹æ–‡çš„ç¬¬ä¸€ä¸ªæ‰©å±•ç‚¹ <code>sort</code></p>
<pre><code class="language-go">func (sched *Scheduler) scheduleOne(ctx context.Context) {
	podInfo := sched.NextPod()
	// pod could be nil when schedulerQueue is closed
	if podInfo == nil || podInfo.Pod == nil {
		return
	}
	pod := podInfo.Pod
	fwk, err := sched.frameworkForPod(pod)
...
    
func (sched *Scheduler) frameworkForPod(pod *v1.Pod) (framework.Framework, error) {
    // è·å–æŒ‡å®šçš„profile
	fwk, ok := sched.Profiles[pod.Spec.SchedulerName]
	if !ok {
		return nil, fmt.Errorf(&quot;profile not found for scheduler name %q&quot;, pod.Spec.SchedulerName)
	}
	return fwk, nil
}
</code></pre>
<p>å›é¡¾ï¼Œå› ä¸ºåœ¨New scheduleræ—¶ä¼šåˆå§‹åŒ–è¿™ä¸ª sort å‡½æ•°</p>
<pre><code class="language-go">podQueue := internalqueue.NewSchedulingQueue(
    profiles[options.profiles[0].SchedulerName].QueueSortFunc(),
    informerFactory,
    internalqueue.WithPodInitialBackoffDuration(time.Duration(options.podInitialBackoffSeconds)*time.Second),
    internalqueue.WithPodMaxBackoffDuration(time.Duration(options.podMaxBackoffSeconds)*time.Second),
    internalqueue.WithPodNominator(nominator),
    internalqueue.WithClusterEventMap(clusterEventMap),
    internalqueue.WithPodMaxInUnschedulablePodsDuration(options.podMaxInUnschedulablePodsDuration),
)
</code></pre>
<h3 id="prefilter">preFilter<a hidden class="anchor" aria-hidden="true" href="#prefilter">Â¶</a></h3>
<p>preFilterä½œä¸ºç¬¬ä¸€ä¸ªæ‰©å±•ç‚¹ï¼Œæ˜¯ç”¨äºåœ¨è¿‡æ»¤ä¹‹å‰é¢„å¤„ç†æˆ–æ£€æŸ¥ Pod æˆ–é›†ç¾¤çš„ç›¸å…³ä¿¡æ¯ã€‚è¿™é‡Œä¼šç»ˆæ­¢è°ƒåº¦</p>
<pre><code class="language-go">func (sched *Scheduler) scheduleOne(ctx context.Context) {
	podInfo := sched.NextPod()
	// pod could be nil when schedulerQueue is closed
	if podInfo == nil || podInfo.Pod == nil {
		return
	}
	pod := podInfo.Pod
	fwk, err := sched.frameworkForPod(pod)
	if err != nil {
		// This shouldn't happen, because we only accept for scheduling the pods
		// which specify a scheduler name that matches one of the profiles.
		klog.ErrorS(err, &quot;Error occurred&quot;)
		return
	}
	if sched.skipPodSchedule(fwk, pod) {
		return
	}

	klog.V(3).InfoS(&quot;Attempting to schedule pod&quot;, &quot;pod&quot;, klog.KObj(pod))

	// Synchronously attempt to find a fit for the pod.
	start := time.Now()
	state := framework.NewCycleState()
	state.SetRecordPluginMetrics(rand.Intn(100) &lt; pluginMetricsSamplePercent)
	// Initialize an empty podsToActivate struct, which will be filled up by plugins or stay empty.
	podsToActivate := framework.NewPodsToActivate()
	state.Write(framework.PodsToActivateKey, podsToActivate)

	schedulingCycleCtx, cancel := context.WithCancel(ctx)
	defer cancel()
    // è¿™é‡Œå°†è¿›å…¥prefilter
	scheduleResult, err := sched.SchedulePod(schedulingCycleCtx, fwk, state, pod)
</code></pre>
<p><a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/schedule_one.go#L311-L360" target="_blank"
   rel="noopener nofollow noreferrer" >schedulePod</a> å°è¯•å°†ç»™å®šçš„ pod è°ƒåº¦åˆ°èŠ‚ç‚¹åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹ä¹‹ä¸€ã€‚å¦‚æœæˆåŠŸï¼Œå®ƒå°†è¿”å›èŠ‚ç‚¹çš„åç§°ã€‚</p>
<pre><code class="language-go">func (sched *Scheduler) schedulePod(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) (result ScheduleResult, err error) {
	trace := utiltrace.New(&quot;Scheduling&quot;, utiltrace.Field{Key: &quot;namespace&quot;, Value: pod.Namespace}, utiltrace.Field{Key: &quot;name&quot;, Value: pod.Name})
	defer trace.LogIfLong(100 * time.Millisecond)
	// ç”¨äºå°†cacheæ›´æ–°ä¸ºå½“å‰å†…å®¹
	if err := sched.Cache.UpdateSnapshot(sched.nodeInfoSnapshot); err != nil {
		return result, err
	}
	trace.Step(&quot;Snapshotting scheduler cache and node infos done&quot;)

	if sched.nodeInfoSnapshot.NumNodes() == 0 {
		return result, ErrNoNodesAvailable
	}
	// æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„podæ—¶ï¼Œä¼šæ‰§è¡Œæ‰©å±•ç‚¹
	feasibleNodes, diagnosis, err := sched.findNodesThatFitPod(ctx, fwk, state, pod)
	
    ...
</code></pre>
<p><a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/schedule_one.go#L364-L426" target="_blank"
   rel="noopener nofollow noreferrer" >findNodesThatFitPod</a> ä¼šæ‰§è¡Œå¯¹åº”çš„è¿‡æ»¤æ’ä»¶æ¥æ‰¾åˆ°æœ€é€‚åˆçš„Nodeï¼ŒåŒ…æ‹¬å¤‡æ³¨ï¼Œä»¥åŠæ–¹æ³•åéƒ½å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œè¿è¡Œçš„æ’ä»¶ğŸ˜ğŸ˜ï¼Œåé¢ä¼šåˆ†æç®—æ³•å†…å®¹ï¼Œåªå¯¹workflowå­¦ä¹ ã€‚</p>
<pre><code class="language-go">func (sched *Scheduler) findNodesThatFitPod(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) ([]*v1.Node, framework.Diagnosis, error) {
	diagnosis := framework.Diagnosis{
		NodeToStatusMap:      make(framework.NodeToStatusMap),
		UnschedulablePlugins: sets.NewString(),
	}

	// Run &quot;prefilter&quot; plugins.
	preRes, s := fwk.RunPreFilterPlugins(ctx, state, pod)
	allNodes, err := sched.nodeInfoSnapshot.NodeInfos().List()
	if err != nil {
		return nil, diagnosis, err
	}
	if !s.IsSuccess() {
		if !s.IsUnschedulable() {
			return nil, diagnosis, s.AsError()
		}
		// All nodes will have the same status. Some non trivial refactoring is
		// needed to avoid this copy.
		for _, n := range allNodes {
			diagnosis.NodeToStatusMap[n.Node().Name] = s
		}
		// Status satisfying IsUnschedulable() gets injected into diagnosis.UnschedulablePlugins.
		if s.FailedPlugin() != &quot;&quot; {
			diagnosis.UnschedulablePlugins.Insert(s.FailedPlugin())
		}
		return nil, diagnosis, nil
	}

	// &quot;NominatedNodeName&quot; can potentially be set in a previous scheduling cycle as a result of preemption.
	// This node is likely the only candidate that will fit the pod, and hence we try it first before iterating over all nodes.
	if len(pod.Status.NominatedNodeName) &gt; 0 {
		feasibleNodes, err := sched.evaluateNominatedNode(ctx, pod, fwk, state, diagnosis)
		if err != nil {
			klog.ErrorS(err, &quot;Evaluation failed on nominated node&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;node&quot;, pod.Status.NominatedNodeName)
		}
		// Nominated node passes all the filters, scheduler is good to assign this node to the pod.
		if len(feasibleNodes) != 0 {
			return feasibleNodes, diagnosis, nil
		}
	}

	nodes := allNodes
	if !preRes.AllNodes() {
		nodes = make([]*framework.NodeInfo, 0, len(preRes.NodeNames))
		for n := range preRes.NodeNames {
			nInfo, err := sched.nodeInfoSnapshot.NodeInfos().Get(n)
			if err != nil {
				return nil, diagnosis, err
			}
			nodes = append(nodes, nInfo)
		}
	}
	feasibleNodes, err := sched.findNodesThatPassFilters(ctx, fwk, state, pod, diagnosis, nodes)
	if err != nil {
		return nil, diagnosis, err
	}

	feasibleNodes, err = findNodesThatPassExtenders(sched.Extenders, pod, feasibleNodes, diagnosis.NodeToStatusMap)
	if err != nil {
		return nil, diagnosis, err
	}
	return feasibleNodes, diagnosis, nil
}
</code></pre>
<h3 id="filter">filter<a hidden class="anchor" aria-hidden="true" href="#filter">Â¶</a></h3>
<p>filteræ’ä»¶ç›¸å½“äº<em>è°ƒåº¦ä¸Šä¸‹æ–‡</em>ä¸­çš„ <code>Predicates</code>ï¼Œç”¨äºæ’é™¤ä¸èƒ½è¿è¡Œ Pod çš„èŠ‚ç‚¹ã€‚Filter ä¼šæŒ‰é…ç½®çš„é¡ºåºè¿›è¡Œè°ƒç”¨ã€‚å¦‚æœæœ‰ä¸€ä¸ªfilterå°†èŠ‚ç‚¹æ ‡è®°ä½ä¸å¯ç”¨ï¼Œåˆ™å°† Pod æ ‡è®°ä¸ºä¸å¯è°ƒåº¦ï¼ˆå³ä¸ä¼šå‘ä¸‹æ‰§è¡Œï¼‰ã€‚</p>
<p>å¯¹äºä»£ç ä¸­æ¥è®²ï¼Œfilterè¿˜æ˜¯å¤„äº <a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/schedule_one.go#L364-L426" target="_blank"
   rel="noopener nofollow noreferrer" >findNodesThatFitPod</a> å‡½æ•°ä¸­ï¼Œ<code>findNodesThatPassFilters</code> å°±æ˜¯è·å–åˆ° FNï¼Œå³å¯è¡ŒèŠ‚ç‚¹ï¼Œè€Œè¿™ä¸ªè¿‡ç¨‹å°±æ˜¯ <em>filter</em> æ‰©å±•ç‚¹</p>
<pre><code class="language-go">func (sched *Scheduler) findNodesThatFitPod(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) ([]*v1.Node, framework.Diagnosis, error) {
	...
    
	feasibleNodes, err := sched.findNodesThatPassFilters(ctx, fwk, state, pod, diagnosis, nodes)
	if err != nil {
		return nil, diagnosis, err
	}

	feasibleNodes, err = findNodesThatPassExtenders(sched.Extenders, pod, feasibleNodes, diagnosis.NodeToStatusMap)
	if err != nil {
		return nil, diagnosis, err
	}
	return feasibleNodes, diagnosis, nil
}
</code></pre>
<h3 id="postfilter">Postfilter<a hidden class="anchor" aria-hidden="true" href="#postfilter">Â¶</a></h3>
<p>å½“æ²¡æœ‰ä¸º pod æ‰¾åˆ°<em>FN</em>æ—¶ï¼Œè¯¥æ’ä»¶ä¼šæŒ‰ç…§é…ç½®çš„é¡ºåºè¿›è¡Œè°ƒç”¨ã€‚å¦‚æœä»»ä½•<code>postFilter</code>æ’ä»¶å°† Pod æ ‡è®°ä¸º<em>schedulable</em>ï¼Œåˆ™ä¸ä¼šè°ƒç”¨å…¶ä½™æ’ä»¶ã€‚å³ <code>filter</code> æˆåŠŸåä¸ä¼šè¿›è¡Œè¿™æ­¥éª¤ï¼Œé‚£æˆ‘ä»¬æ¥éªŒè¯ä¸‹è¿™é‡ŒæŠŠğŸ˜Š</p>
<p>è¿˜æ˜¯åœ¨ scheduleOne ä¸­ï¼Œå½“æˆ‘ä»¬è¿è¡Œçš„ SchedulePod å®Œæˆåï¼ˆæˆåŠŸæˆ–å¤±è´¥ï¼‰ï¼Œè¿™æ—¶ä¼šè¿”å›ä¸€ä¸ªerrï¼Œè€Œ <code>postfilter</code> ä¼šæ ¹æ®è¿™ä¸ª errè¿›è¡Œé€‰æ‹©æ‰§è¡Œæˆ–ä¸æ‰§è¡Œï¼Œç¬¦åˆå®˜æ–¹ç»™å‡ºçš„è¯´æ³•ã€‚</p>
<pre><code class="language-go">scheduleResult, err := sched.SchedulePod(schedulingCycleCtx, fwk, state, pod)
	if err != nil {
		// SchedulePod() may have failed because the pod would not fit on any host, so we try to
		// preempt, with the expectation that the next time the pod is tried for scheduling it
		// will fit due to the preemption. It is also possible that a different pod will schedule
		// into the resources that were preempted, but this is harmless.
		var nominatingInfo *framework.NominatingInfo
		if fitError, ok := err.(*framework.FitError); ok {
			if !fwk.HasPostFilterPlugins() {
				klog.V(3).InfoS(&quot;No PostFilter plugins are registered, so no preemption will be performed&quot;)
			} else {
				// Run PostFilter plugins to try to make the pod schedulable in a future scheduling cycle.
				result, status := fwk.RunPostFilterPlugins(ctx, state, pod, fitError.Diagnosis.NodeToStatusMap)
				if status.Code() == framework.Error {
					klog.ErrorS(nil, &quot;Status after running PostFilter plugins for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;status&quot;, status)
				} else {
					fitError.Diagnosis.PostFilterMsg = status.Message()
					klog.V(5).InfoS(&quot;Status after running PostFilter plugins for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;status&quot;, status)
				}
				if result != nil {
					nominatingInfo = result.NominatingInfo
				}
			}
			// Pod did not fit anywhere, so it is counted as a failure. If preemption
			// succeeds, the pod should get counted as a success the next time we try to
			// schedule it. (hopefully)
			metrics.PodUnschedulable(fwk.ProfileName(), metrics.SinceInSeconds(start))
		} else if err == ErrNoNodesAvailable {
			nominatingInfo = clearNominatedNode
			// No nodes available is counted as unschedulable rather than an error.
			metrics.PodUnschedulable(fwk.ProfileName(), metrics.SinceInSeconds(start))
		} else {
			nominatingInfo = clearNominatedNode
			klog.ErrorS(err, &quot;Error selecting node for pod&quot;, &quot;pod&quot;, klog.KObj(pod))
			metrics.PodScheduleError(fwk.ProfileName(), metrics.SinceInSeconds(start))
		}
		sched.handleSchedulingFailure(ctx, fwk, podInfo, err, v1.PodReasonUnschedulable, nominatingInfo)
		return
	}
</code></pre>
<h3 id="prescorescore">PreScore,Score<a hidden class="anchor" aria-hidden="true" href="#prescorescore">Â¶</a></h3>
<p>å¯ç”¨äºè¿›è¡Œé¢„Scoreå·¥ä½œï¼Œä½œä¸ºé€šçŸ¥æ€§çš„æ‰©å±•ç‚¹ï¼Œä¼šåœ¨åœ¨filterå®Œä¹‹åç›´æ¥ä¼šå…³è” preScore æ’ä»¶è¿›è¡Œç»§ç»­å·¥ä½œï¼Œè€Œä¸æ˜¯è¿”å›ï¼Œå¦‚æœé…ç½®çš„è¿™äº›æ’ä»¶æœ‰ä»»ä½•ä¸€ä¸ªè¿”å›å¤±è´¥ï¼Œåˆ™Podå°†è¢«æ‹’ç»ã€‚</p>
<pre><code class="language-go">
func (sched *Scheduler) schedulePod(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) (result ScheduleResult, err error) {
	trace := utiltrace.New(&quot;Scheduling&quot;, utiltrace.Field{Key: &quot;namespace&quot;, Value: pod.Namespace}, utiltrace.Field{Key: &quot;name&quot;, Value: pod.Name})
	defer trace.LogIfLong(100 * time.Millisecond)

	if err := sched.Cache.UpdateSnapshot(sched.nodeInfoSnapshot); err != nil {
		return result, err
	}
	trace.Step(&quot;Snapshotting scheduler cache and node infos done&quot;)

	if sched.nodeInfoSnapshot.NumNodes() == 0 {
		return result, ErrNoNodesAvailable
	}

	feasibleNodes, diagnosis, err := sched.findNodesThatFitPod(ctx, fwk, state, pod)
	if err != nil {
		return result, err
	}
	trace.Step(&quot;Computing predicates done&quot;)

	if len(feasibleNodes) == 0 {
		return result, &amp;framework.FitError{
			Pod:         pod,
			NumAllNodes: sched.nodeInfoSnapshot.NumNodes(),
			Diagnosis:   diagnosis,
		}
	}

	// When only one node after predicate, just use it.
	if len(feasibleNodes) == 1 {
		return ScheduleResult{
			SuggestedHost:  feasibleNodes[0].Name,
			EvaluatedNodes: 1 + len(diagnosis.NodeToStatusMap),
			FeasibleNodes:  1,
		}, nil
	}
	// è¿™é‡Œä¼šå®Œæˆprescoreï¼Œscore
	priorityList, err := prioritizeNodes(ctx, sched.Extenders, fwk, state, pod, feasibleNodes)
	if err != nil {
		return result, err
	}

	host, err := selectHost(priorityList)
	trace.Step(&quot;Prioritizing done&quot;)

	return ScheduleResult{
		SuggestedHost:  host,
		EvaluatedNodes: len(feasibleNodes) + len(diagnosis.NodeToStatusMap),
		FeasibleNodes:  len(feasibleNodes),
	}, err
}
</code></pre>
<p><a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/schedule_one.go#L605-L705" target="_blank"
   rel="noopener nofollow noreferrer" >priorityNodes</a> ä¼šé€šè¿‡é…ç½®çš„æ’ä»¶ç»™Nodeæ‰“åˆ†ï¼Œå¹¶è¿”å›æ¯ä¸ªNodeçš„åˆ†æ•°ï¼Œå°†æ¯ä¸ªæ’ä»¶æ‰“åˆ†ç»“æœè®¡ç®—æ€»å’Œè·å¾—Nodeçš„åˆ†æ•°ï¼Œæœ€åè·å¾—èŠ‚ç‚¹çš„åŠ æƒæ€»åˆ†æ•°ã€‚</p>
<pre><code class="language-go">func prioritizeNodes(
	ctx context.Context,
	extenders []framework.Extender,
	fwk framework.Framework,
	state *framework.CycleState,
	pod *v1.Pod,
	nodes []*v1.Node,
) (framework.NodeScoreList, error) {
	// If no priority configs are provided, then all nodes will have a score of one.
	// This is required to generate the priority list in the required format
	if len(extenders) == 0 &amp;&amp; !fwk.HasScorePlugins() {
		result := make(framework.NodeScoreList, 0, len(nodes))
		for i := range nodes {
			result = append(result, framework.NodeScore{
				Name:  nodes[i].Name,
				Score: 1,
			})
		}
		return result, nil
	}

	// Run PreScore plugins.
	preScoreStatus := fwk.RunPreScorePlugins(ctx, state, pod, nodes)
	if !preScoreStatus.IsSuccess() {
		return nil, preScoreStatus.AsError()
	}

	// Run the Score plugins.
	scoresMap, scoreStatus := fwk.RunScorePlugins(ctx, state, pod, nodes)
	if !scoreStatus.IsSuccess() {
		return nil, scoreStatus.AsError()
	}

	// Additional details logged at level 10 if enabled.
	klogV := klog.V(10)
	if klogV.Enabled() {
		for plugin, nodeScoreList := range scoresMap {
			for _, nodeScore := range nodeScoreList {
				klogV.InfoS(&quot;Plugin scored node for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;plugin&quot;, plugin, &quot;node&quot;, nodeScore.Name, &quot;score&quot;, nodeScore.Score)
			}
		}
	}

	// Summarize all scores.
	result := make(framework.NodeScoreList, 0, len(nodes))

	for i := range nodes {
		result = append(result, framework.NodeScore{Name: nodes[i].Name, Score: 0})
		for j := range scoresMap {
			result[i].Score += scoresMap[j][i].Score
		}
	}

	if len(extenders) != 0 &amp;&amp; nodes != nil {
		var mu sync.Mutex
		var wg sync.WaitGroup
		combinedScores := make(map[string]int64, len(nodes))
		for i := range extenders {
			if !extenders[i].IsInterested(pod) {
				continue
			}
			wg.Add(1)
			go func(extIndex int) {
				metrics.SchedulerGoroutines.WithLabelValues(metrics.PrioritizingExtender).Inc()
				defer func() {
					metrics.SchedulerGoroutines.WithLabelValues(metrics.PrioritizingExtender).Dec()
					wg.Done()
				}()
				prioritizedList, weight, err := extenders[extIndex].Prioritize(pod, nodes)
				if err != nil {
					// Prioritization errors from extender can be ignored, let k8s/other extenders determine the priorities
					klog.V(5).InfoS(&quot;Failed to run extender's priority function. No score given by this extender.&quot;, &quot;error&quot;, err, &quot;pod&quot;, klog.KObj(pod), &quot;extender&quot;, extenders[extIndex].Name())
					return
				}
				mu.Lock()
				for i := range *prioritizedList {
					host, score := (*prioritizedList)[i].Host, (*prioritizedList)[i].Score
					if klogV.Enabled() {
						klogV.InfoS(&quot;Extender scored node for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;extender&quot;, extenders[extIndex].Name(), &quot;node&quot;, host, &quot;score&quot;, score)
					}
					combinedScores[host] += score * weight
				}
				mu.Unlock()
			}(i)
		}
		// wait for all go routines to finish
		wg.Wait()
		for i := range result {
			// MaxExtenderPriority may diverge from the max priority used in the scheduler and defined by MaxNodeScore,
			// therefore we need to scale the score returned by extenders to the score range used by the scheduler.
			result[i].Score += combinedScores[result[i].Name] * (framework.MaxNodeScore / extenderv1.MaxExtenderPriority)
		}
	}

	if klogV.Enabled() {
		for i := range result {
			klogV.InfoS(&quot;Calculated node's final score for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;node&quot;, result[i].Name, &quot;score&quot;, result[i].Score)
		}
	}
	return result, nil
}
</code></pre>
<h3 id="reserve">Reserve<a hidden class="anchor" aria-hidden="true" href="#reserve">Â¶</a></h3>
<p><a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/schedule_one.go#L153-L163" target="_blank"
   rel="noopener nofollow noreferrer" >Reserve</a> å› ä¸ºç»‘å®šäº‹ä»¶æ—¶å¼‚æ­¥å‘ç”Ÿçš„ï¼Œè¯¥æ’ä»¶æ˜¯ä¸ºäº†é¿å…Podåœ¨ç»‘å®šåˆ°èŠ‚ç‚¹å‰æ—¶ï¼Œè°ƒåº¦åˆ°æ–°çš„Podï¼Œä½¿èŠ‚ç‚¹ä½¿ç”¨èµ„æºè¶…è¿‡å¯ç”¨èµ„æºæƒ…å†µã€‚å¦‚æœåç»­é˜¶æ®µå‘ç”Ÿé”™è¯¯æˆ–å¤±è´¥ï¼Œå°†è§¦å‘ <code>UnReserve</code> å›æ»šï¼ˆé€šçŸ¥æ€§æ‰©å±•ç‚¹ï¼‰ã€‚è¿™ä¹Ÿæ˜¯ä½œä¸ºè°ƒåº¦å‘¨æœŸä¸­æœ€åä¸€ä¸ªçŠ¶æ€ï¼Œè¦ä¹ˆæˆåŠŸåˆ° <code>postBind</code> ï¼Œè¦ä¹ˆå¤±è´¥è§¦å‘ <code>UnReserve</code>ã€‚</p>
<pre><code class="language-go">// Run the Reserve method of reserve plugins.
if sts := fwk.RunReservePluginsReserve(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost); !sts.IsSuccess() { // å½“å¤„ç†ä¸æˆåŠŸæ—¶
    metrics.PodScheduleError(fwk.ProfileName(), metrics.SinceInSeconds(start))
    // è§¦å‘ un-reserve æ¥æ¸…ç†ç›¸å…³Podçš„çŠ¶æ€
    fwk.RunReservePluginsUnreserve(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
    if forgetErr := sched.Cache.ForgetPod(assumedPod); forgetErr != nil {
        klog.ErrorS(forgetErr, &quot;Scheduler cache ForgetPod failed&quot;)
    }
    sched.handleSchedulingFailure(ctx, fwk, assumedPodInfo, sts.AsError(), SchedulerError, clearNominatedNode)
    return
}
</code></pre>
<h3 id="permit">permit<a hidden class="anchor" aria-hidden="true" href="#permit">Â¶</a></h3>
<p><a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/schedule_one.go#L165-L183" target="_blank"
   rel="noopener nofollow noreferrer" >Permit</a> æ’ä»¶å¯ä»¥é˜»æ­¢æˆ–å»¶è¿Ÿ Pod çš„ç»‘å®š</p>
<pre><code class="language-go">	// Run &quot;permit&quot; plugins.
	runPermitStatus := fwk.RunPermitPlugins(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
	if !runPermitStatus.IsWait() &amp;&amp; !runPermitStatus.IsSuccess() {
		var reason string
		if runPermitStatus.IsUnschedulable() {
			metrics.PodUnschedulable(fwk.ProfileName(), metrics.SinceInSeconds(start))
			reason = v1.PodReasonUnschedulable
		} else {
			metrics.PodScheduleError(fwk.ProfileName(), metrics.SinceInSeconds(start))
			reason = SchedulerError
		}
        // åªè¦å…¶ä¸­ä¸€ä¸ªæ’ä»¶è¿”å›çš„çŠ¶æ€ä¸æ˜¯ success æˆ–è€… wait
		fwk.RunReservePluginsUnreserve(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
        // ä»cacheä¸­å¿˜æ‰pod
		if forgetErr := sched.Cache.ForgetPod(assumedPod); forgetErr != nil {
			klog.ErrorS(forgetErr, &quot;Scheduler cache ForgetPod failed&quot;)
		}
		sched.handleSchedulingFailure(ctx, fwk, assumedPodInfo, runPermitStatus.AsError(), reason, clearNominatedNode)
		return
	}

</code></pre>
<h3 id="binding-cycle">Binding Cycle<a hidden class="anchor" aria-hidden="true" href="#binding-cycle">Â¶</a></h3>
<p>åœ¨é€‰æ‹©å¥½ <em>FN</em> ååˆ™åšä¸€ä¸ªå‡è®¾ç»‘å®šï¼Œå¹¶æ›´æ–°åˆ°cacheä¸­ï¼Œæ¥ä¸‹æ¥å›å»æ‰§è¡ŒçœŸæ­£çš„bindæ“ä½œï¼Œä¹Ÿå°±æ˜¯ <code>binding cycle</code></p>
<pre><code class="language-go">func (sched *Scheduler) scheduleOne(ctx context.Context) {
	...
    ...
	// binding cycle æ˜¯ä¸€ä¸ªå¼‚æ­¥çš„æ“ä½œï¼Œè¿™é‡Œè¡¨ç°å°±æ˜¯goåç¨‹
	go func() {
		bindingCycleCtx, cancel := context.WithCancel(ctx)
		defer cancel()
		metrics.SchedulerGoroutines.WithLabelValues(metrics.Binding).Inc()
		defer metrics.SchedulerGoroutines.WithLabelValues(metrics.Binding).Dec()
		// è¿è¡ŒWaitOnPermitæ’ä»¶ï¼Œå¦‚æœå¤±è´¥åˆ™ï¼ŒunReserveå›æ»š
		waitOnPermitStatus := fwk.WaitOnPermit(bindingCycleCtx, assumedPod)
		if !waitOnPermitStatus.IsSuccess() {
			var reason string
			if waitOnPermitStatus.IsUnschedulable() {
				metrics.PodUnschedulable(fwk.ProfileName(), metrics.SinceInSeconds(start))
				reason = v1.PodReasonUnschedulable
			} else {
				metrics.PodScheduleError(fwk.ProfileName(), metrics.SinceInSeconds(start))
				reason = SchedulerError
			}
			// trigger un-reserve plugins to clean up state associated with the reserved Pod
			fwk.RunReservePluginsUnreserve(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
			if forgetErr := sched.Cache.ForgetPod(assumedPod); forgetErr != nil {
				klog.ErrorS(forgetErr, &quot;scheduler cache ForgetPod failed&quot;)
			} else {
				// &quot;Forget&quot;ing an assumed Pod in binding cycle should be treated as a PodDelete event,
				// as the assumed Pod had occupied a certain amount of resources in scheduler cache.
				// TODO(#103853): de-duplicate the logic.
				// Avoid moving the assumed Pod itself as it's always Unschedulable.
				// It's intentional to &quot;defer&quot; this operation; otherwise MoveAllToActiveOrBackoffQueue() would
				// update `q.moveRequest` and thus move the assumed pod to backoffQ anyways.
				defer sched.SchedulingQueue.MoveAllToActiveOrBackoffQueue(internalqueue.AssignedPodDelete, func(pod *v1.Pod) bool {
					return assumedPod.UID != pod.UID
				})
			}
			sched.handleSchedulingFailure(ctx, fwk, assumedPodInfo, waitOnPermitStatus.AsError(), reason, clearNominatedNode)
			return
		}

	// è¿è¡ŒPrebind æ’ä»¶
		preBindStatus := fwk.RunPreBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
		if !preBindStatus.IsSuccess() {
			metrics.PodScheduleError(fwk.ProfileName(), metrics.SinceInSeconds(start))
			// trigger un-reserve plugins to clean up state associated with the reserved Pod
			fwk.RunReservePluginsUnreserve(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
			if forgetErr := sched.Cache.ForgetPod(assumedPod); forgetErr != nil {
				klog.ErrorS(forgetErr, &quot;scheduler cache ForgetPod failed&quot;)
			} else {
				// &quot;Forget&quot;ing an assumed Pod in binding cycle should be treated as a PodDelete event,
				// as the assumed Pod had occupied a certain amount of resources in scheduler cache.
				// TODO(#103853): de-duplicate the logic.
				sched.SchedulingQueue.MoveAllToActiveOrBackoffQueue(internalqueue.AssignedPodDelete, nil)
			}
			sched.handleSchedulingFailure(ctx, fwk, assumedPodInfo, preBindStatus.AsError(), SchedulerError, clearNominatedNode)
			return
		}
		// bindæ˜¯çœŸæ­£çš„ç»‘å®šæ“ä½œ
		err := sched.bind(bindingCycleCtx, fwk, assumedPod, scheduleResult.SuggestedHost, state)
		if err != nil {
			metrics.PodScheduleError(fwk.ProfileName(), metrics.SinceInSeconds(start))
			// å¦‚æœå¤±è´¥äº†å°±è§¦å‘ un-reserve plugins 
			fwk.RunReservePluginsUnreserve(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)
			if err := sched.Cache.ForgetPod(assumedPod); err != nil {
				klog.ErrorS(err, &quot;scheduler cache ForgetPod failed&quot;)
			} else {
				// &quot;Forget&quot;ing an assumed Pod in binding cycle should be treated as a PodDelete event,
				// as the assumed Pod had occupied a certain amount of resources in scheduler cache.
				// TODO(#103853): de-duplicate the logic.
				sched.SchedulingQueue.MoveAllToActiveOrBackoffQueue(internalqueue.AssignedPodDelete, nil)
			}
			sched.handleSchedulingFailure(ctx, fwk, assumedPodInfo, fmt.Errorf(&quot;binding rejected: %w&quot;, err), SchedulerError, clearNominatedNode)
			return
		}
		// Calculating nodeResourceString can be heavy. Avoid it if klog verbosity is below 2.
		klog.V(2).InfoS(&quot;Successfully bound pod to node&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;node&quot;, scheduleResult.SuggestedHost, &quot;evaluatedNodes&quot;, scheduleResult.EvaluatedNodes, &quot;feasibleNodes&quot;, scheduleResult.FeasibleNodes)
		metrics.PodScheduled(fwk.ProfileName(), metrics.SinceInSeconds(start))
		metrics.PodSchedulingAttempts.Observe(float64(podInfo.Attempts))
		metrics.PodSchedulingDuration.WithLabelValues(getAttemptsLabel(podInfo)).Observe(metrics.SinceInSeconds(podInfo.InitialAttemptTimestamp))

		// è¿è¡Œ &quot;postbind&quot; æ’ä»¶
        // æ˜¯é€šçŸ¥æ€§çš„æ‰©å±•ç‚¹ï¼Œè¯¥æ’ä»¶åœ¨ç»‘å®š Pod åè°ƒç”¨ï¼Œå¯ç”¨äºæ¸…ç†ç›¸å…³èµ„æºï¼ˆï¼‰ã€‚
		fwk.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)

		// At the end of a successful binding cycle, move up Pods if needed.
		if len(podsToActivate.Map) != 0 {
			sched.SchedulingQueue.Activate(podsToActivate.Map)
			// Unlike the logic in scheduling cycle, we don't bother deleting the entries
			// as `podsToActivate.Map` is no longer consumed.
		}
	}()
}
</code></pre>
<h2 id="è°ƒåº¦ä¸Šä¸‹æ–‡ä¸­çš„å¤±è´¥æµç¨‹">è°ƒåº¦ä¸Šä¸‹æ–‡ä¸­çš„å¤±è´¥æµç¨‹<a hidden class="anchor" aria-hidden="true" href="#è°ƒåº¦ä¸Šä¸‹æ–‡ä¸­çš„å¤±è´¥æµç¨‹">Â¶</a></h2>
<p>ä¸Šé¢è¯´åˆ°çš„éƒ½æ˜¯æ­£å¸¸çš„è¯·æ±‚ï¼Œä¸‹é¢ä¼šå¯¹å¤±è´¥çš„è¯·æ±‚æ˜¯å¦‚ä½•é‡è¯•çš„è¿›è¡Œåˆ†æï¼Œè€Œ <em>scheduler</em> ä¸­å…³äºå¤±è´¥å¤„ç†æ–¹é¢ç›¸å…³çš„å±æ€§ä¼šæ¶‰åŠåˆ°ä¸Šé¢ <em>scheduler</em> ç»“æ„ä¸­çš„  <code>backoffQ</code> ä¸ <code>unschedulablePods </code></p>
<ul>
<li><code>backoffQ</code>ï¼šä¹Ÿæ˜¯ä¸€ä¸ª <em>heap</em> ç±»å‹çš„ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œå­˜æ”¾çš„æ˜¯ä¸å¯è°ƒåº¦çš„Pod</li>
<li><code>unschedulablePods </code>ï¼šä¿å­˜ç¡®å®šä¸å¯è¢«è°ƒåº¦çš„Podï¼Œä¸€ä¸ªmapç±»å‹</li>
</ul>
<p>backoffQ ä¸  unschedulablePods ä¼šåœ¨åˆå§‹åŒ– <em>scheduler</em> æ—¶åˆå§‹åŒ–ï¼Œ</p>
<pre><code class="language-go">func NewPriorityQueue(
	lessFn framework.LessFunc,
	informerFactory informers.SharedInformerFactory,
	opts ...Option,
) *PriorityQueue {
	options := defaultPriorityQueueOptions
	for _, opt := range opts {
		opt(&amp;options)
	}

	comp := func(podInfo1, podInfo2 interface{}) bool {
		pInfo1 := podInfo1.(*framework.QueuedPodInfo)
		pInfo2 := podInfo2.(*framework.QueuedPodInfo)
		return lessFn(pInfo1, pInfo2)
	}

	if options.podNominator == nil {
		options.podNominator = NewPodNominator(informerFactory.Core().V1().Pods().Lister())
	}

	pq := &amp;PriorityQueue{
		PodNominator:                      options.podNominator,
		clock:                             options.clock,
		stop:                              make(chan struct{}),
		podInitialBackoffDuration:         options.podInitialBackoffDuration,
		podMaxBackoffDuration:             options.podMaxBackoffDuration,
		podMaxInUnschedulablePodsDuration: options.podMaxInUnschedulablePodsDuration,
		activeQ:                           heap.NewWithRecorder(podInfoKeyFunc, comp, metrics.NewActivePodsRecorder()),
		unschedulablePods:                 newUnschedulablePods(metrics.NewUnschedulablePodsRecorder()),
		moveRequestCycle:                  -1,
		clusterEventMap:                   options.clusterEventMap,
	}
	pq.cond.L = &amp;pq.lock
    // åˆå§‹åŒ–backoffQ
    // NewWithRecorderä½œä¸ºä¸€ä¸ªå¯é€‰çš„ metricRecorder çš„ Heap å¯¹è±¡ã€‚
    // podInfoKeyFuncæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›é”™è¯¯ä¸å­—ç¬¦ä¸²
    // pq.podsCompareBackoffCompleted æ¯”è¾ƒä¸¤ä¸ªpodçš„å›é€€æ—¶é—´ï¼Œå¦‚æœç¬¬ä¸€ä¸ªåœ¨ç¬¬äºŒä¸ªä¹‹å‰ä¸ºtrueï¼Œ
    // åä¹‹ false
	pq.podBackoffQ = heap.NewWithRecorder(podInfoKeyFunc, pq.podsCompareBackoffCompleted, metrics.NewBackoffPodsRecorder())
	pq.nsLister = informerFactory.Core().V1().Namespaces().Lister()

	return pq
}
</code></pre>
<p>å¯¹äºåˆå§‹åŒ– backoffQ ä¼šäº§ç”Ÿçš„ä¸¤ä¸ªå‡½æ•°ï¼Œ<a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/internal/queue/scheduling_queue.go#L757-L761" target="_blank"
   rel="noopener nofollow noreferrer" >getBackoffTime</a> ä¸ <a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/internal/queue/scheduling_queue.go#L765-L775" target="_blank"
   rel="noopener nofollow noreferrer" >calculateBackoffDuration</a></p>
<pre><code class="language-go">// getBackoffTime returns the time that podInfo completes backoff
func (p *PriorityQueue) getBackoffTime(podInfo *framework.QueuedPodInfo) time.Time {
	duration := p.calculateBackoffDuration(podInfo)
	backoffTime := podInfo.Timestamp.Add(duration)
	return backoffTime
}

// calculateBackoffDuration is a helper function for calculating the backoffDuration
// based on the number of attempts the pod has made.
func (p *PriorityQueue) calculateBackoffDuration(podInfo *framework.QueuedPodInfo) time.Duration {
	duration := p.podInitialBackoffDuration
	for i := 1; i &lt; podInfo.Attempts; i++ {
		// Use subtraction instead of addition or multiplication to avoid overflow.
		if duration &gt; p.podMaxBackoffDuration-duration {
			return p.podMaxBackoffDuration
		}
		duration += duration
	}
	return duration
}
</code></pre>
<p>å¯¹äºæ•´ä¸ªæ•…éšœé”™è¯¯ä¼šæŒ‰ç…§å¦‚ä¸‹æµç¨‹è¿›è¡Œï¼Œåœ¨åˆå§‹åŒ– <em>scheduler</em> ä¼šæ³¨å†Œä¸€ä¸ª Error å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ç”¨ä½œå¯¹ä¸å¯è°ƒåº¦Podè¿›è¡Œå¤„ç†ï¼Œå®é™…ä¸Šè¢«æ³¨å†Œçš„å‡½æ•°æ˜¯ MakeDefaultErrorFuncã€‚è¿™ä¸ªå‡½æ•°å°†ä½œä¸º Error å‡½æ•°è¢«è°ƒç”¨ã€‚</p>
<pre><code class="language-go">sched := newScheduler(
    schedulerCache,
    extenders,
    internalqueue.MakeNextPodFunc(podQueue),
    MakeDefaultErrorFunc(client, podLister, podQueue, schedulerCache),
    stopEverything,
    podQueue,
    profiles,
    client,
    snapshot,
    options.percentageOfNodesToScore,
)
</code></pre>
<p>è€Œåœ¨ è°ƒåº¦å‘¨æœŸä¸­ï¼Œä¹Ÿå°±æ˜¯ <a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/schedule_one.go#L66-L132" target="_blank"
   rel="noopener nofollow noreferrer" >scheduleOne</a> å¯ä»¥çœ‹åˆ°ï¼Œæ¯ä¸ªæ‰©å±•ç‚¹æ“ä½œå¤±è´¥åéƒ½ä¼šè°ƒç”¨ <a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/schedule_one.go#L812-L834" target="_blank"
   rel="noopener nofollow noreferrer" >handleSchedulingFailure</a> è€Œè¯¥å‡½æ•°ï¼Œä½¿ç”¨äº†æ³¨å†Œçš„ <em>Error</em> å‡½æ•°æ¥å¤„ç†Pod</p>
<pre><code class="language-go">func (sched *Scheduler) scheduleOne(ctx context.Context) {
	...
	defer cancel()
	scheduleResult, err := sched.SchedulePod(schedulingCycleCtx, fwk, state, pod)
	if err != nil {

		var nominatingInfo *framework.NominatingInfo
		if fitError, ok := err.(*framework.FitError); ok {
			if !fwk.HasPostFilterPlugins() {
				klog.V(3).InfoS(&quot;No PostFilter plugins are registered, so no preemption will be performed&quot;)
			} else {
			
				result, status := fwk.RunPostFilterPlugins(ctx, state, pod, fitError.Diagnosis.NodeToStatusMap)
				if status.Code() == framework.Error {
					klog.ErrorS(nil, &quot;Status after running PostFilter plugins for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;status&quot;, status)
				} else {
					fitError.Diagnosis.PostFilterMsg = status.Message()
					klog.V(5).InfoS(&quot;Status after running PostFilter plugins for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;status&quot;, status)
				}
				if result != nil {
					nominatingInfo = result.NominatingInfo
				}
			}
	
			metrics.PodUnschedulable(fwk.ProfileName(), metrics.SinceInSeconds(start))
		} else if err == ErrNoNodesAvailable {
			nominatingInfo = clearNominatedNode
			// No nodes available is counted as unschedulable rather than an error.
			metrics.PodUnschedulable(fwk.ProfileName(), metrics.SinceInSeconds(start))
		} else {
			nominatingInfo = clearNominatedNode
			klog.ErrorS(err, &quot;Error selecting node for pod&quot;, &quot;pod&quot;, klog.KObj(pod))
			metrics.PodScheduleError(fwk.ProfileName(), metrics.SinceInSeconds(start))
		}
        // å¤„ç†ä¸å¯è°ƒåº¦Pod
		sched.handleSchedulingFailure(ctx, fwk, podInfo, err, v1.PodReasonUnschedulable, nominatingInfo)
		return
	}

</code></pre>
<p>æ¥åˆ°äº†æ³¨å†Œçš„ <em>Error</em> å‡½æ•° <code>MakeDefaultErrorFunc</code></p>
<pre><code class="language-go">func MakeDefaultErrorFunc(client clientset.Interface, podLister corelisters.PodLister, podQueue internalqueue.SchedulingQueue, schedulerCache internalcache.Cache) func(*framework.QueuedPodInfo, error) {
	return func(podInfo *framework.QueuedPodInfo, err error) {
		pod := podInfo.Pod
		if err == ErrNoNodesAvailable {
			klog.V(2).InfoS(&quot;Unable to schedule pod; no nodes are registered to the cluster; waiting&quot;, &quot;pod&quot;, klog.KObj(pod))
		} else if fitError, ok := err.(*framework.FitError); ok {
			// Inject UnschedulablePlugins to PodInfo, which will be used later for moving Pods between queues efficiently.
			podInfo.UnschedulablePlugins = fitError.Diagnosis.UnschedulablePlugins
			klog.V(2).InfoS(&quot;Unable to schedule pod; no fit; waiting&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;err&quot;, err)
		} else if apierrors.IsNotFound(err) {
			klog.V(2).InfoS(&quot;Unable to schedule pod, possibly due to node not found; waiting&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;err&quot;, err)
			if errStatus, ok := err.(apierrors.APIStatus); ok &amp;&amp; errStatus.Status().Details.Kind == &quot;node&quot; {
				nodeName := errStatus.Status().Details.Name
				// when node is not found, We do not remove the node right away. Trying again to get
				// the node and if the node is still not found, then remove it from the scheduler cache.
				_, err := client.CoreV1().Nodes().Get(context.TODO(), nodeName, metav1.GetOptions{})
				if err != nil &amp;&amp; apierrors.IsNotFound(err) {
					node := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: nodeName}}
					if err := schedulerCache.RemoveNode(&amp;node); err != nil {
						klog.V(4).InfoS(&quot;Node is not found; failed to remove it from the cache&quot;, &quot;node&quot;, node.Name)
					}
				}
			}
		} else {
			klog.ErrorS(err, &quot;Error scheduling pod; retrying&quot;, &quot;pod&quot;, klog.KObj(pod))
		}

		// Check if the Pod exists in informer cache.
		cachedPod, err := podLister.Pods(pod.Namespace).Get(pod.Name)
		if err != nil {
			klog.InfoS(&quot;Pod doesn't exist in informer cache&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;err&quot;, err)
			return
		}

		// In the case of extender, the pod may have been bound successfully, but timed out returning its response to the scheduler.
		// It could result in the live version to carry .spec.nodeName, and that's inconsistent with the internal-queued version.
		if len(cachedPod.Spec.NodeName) != 0 {
			klog.InfoS(&quot;Pod has been assigned to node. Abort adding it back to queue.&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;node&quot;, cachedPod.Spec.NodeName)
			return
		}

		// As &lt;cachedPod&gt; is from SharedInformer, we need to do a DeepCopy() here.
		podInfo.PodInfo = framework.NewPodInfo(cachedPod.DeepCopy())
        // æ·»åŠ åˆ°unschedulableé˜Ÿåˆ—ä¸­
		if err := podQueue.AddUnschedulableIfNotPresent(podInfo, podQueue.SchedulingCycle()); err != nil {
			klog.ErrorS(err, &quot;Error occurred&quot;)
		}
	}
}
</code></pre>
<p>ä¸‹é¢æ¥åˆ° <code>AddUnschedulableIfNotPresent</code> ï¼Œè¿™ä¸ªä¹Ÿæ˜¯æ“ä½œ <code>backoffQ</code> å’Œ <code>unschedulablePods </code> çš„çœŸæ­£çš„åŠ¨ä½œ</p>
<p><code>AddUnschedulableIfNotPresent</code> å‡½æ•°ä¼šå§æ— æ³•è°ƒåº¦çš„ pod æ’å…¥é˜Ÿåˆ—ï¼Œé™¤éå®ƒå·²ç»åœ¨é˜Ÿåˆ—ä¸­ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œ<code>PriorityQueue</code> å°†ä¸å¯è°ƒåº¦çš„ Pod æ”¾åœ¨ <code>unschedulablePods</code> ä¸­ã€‚ä½†å¦‚æœæœ€è¿‘æœ‰ move requestï¼Œåˆ™å°† pod æ”¾å…¥ <code>podBackoffQ</code> ä¸­ã€‚</p>
<pre><code class="language-go">func (p *PriorityQueue) AddUnschedulableIfNotPresent(pInfo *framework.QueuedPodInfo, podSchedulingCycle int64) error {
	p.lock.Lock()
	defer p.lock.Unlock()
	pod := pInfo.Pod
    // å¦‚æœå·²ç»å­˜åœ¨åˆ™ä¸æ·»åŠ 
	if p.unschedulablePods.get(pod) != nil {
		return fmt.Errorf(&quot;Pod %v is already present in unschedulable queue&quot;, klog.KObj(pod))
	}
	// æ£€æŸ¥æ˜¯å¦åœ¨activeQä¸­
	if _, exists, _ := p.activeQ.Get(pInfo); exists {
		return fmt.Errorf(&quot;Pod %v is already present in the active queue&quot;, klog.KObj(pod))
	}
    // æ£€æŸ¥æ˜¯å¦åœ¨podBackoffQä¸­
	if _, exists, _ := p.podBackoffQ.Get(pInfo); exists {
		return fmt.Errorf(&quot;Pod %v is already present in the backoff queue&quot;, klog.KObj(pod))
	}

	// åœ¨é‡æ–°æ·»åŠ æ—¶ï¼Œä¼šåˆ·æ–° Podæ—¶é—´ä¸ºæœ€æ–°æ“ä½œçš„æ—¶é—´
	pInfo.Timestamp = p.clock.Now()

	for plugin := range pInfo.UnschedulablePlugins {
		metrics.UnschedulableReason(plugin, pInfo.Pod.Spec.SchedulerName).Inc()
	}
    // å¦‚æœæ¥å—åˆ°move requesté‚£ä¹ˆåˆ™æ”¾å…¥BackoffQ
	if p.moveRequestCycle &gt;= podSchedulingCycle {
		if err := p.podBackoffQ.Add(pInfo); err != nil {
			return fmt.Errorf(&quot;error adding pod %v to the backoff queue: %v&quot;, pod.Name, err)
		}
		metrics.SchedulerQueueIncomingPods.WithLabelValues(&quot;backoff&quot;, ScheduleAttemptFailure).Inc()
	} else {
        // å¦åˆ™å°†æ”¾å…¥åˆ° unschedulablePods
		p.unschedulablePods.addOrUpdate(pInfo)
		metrics.SchedulerQueueIncomingPods.WithLabelValues(&quot;unschedulable&quot;, ScheduleAttemptFailure).Inc()

	}

	p.PodNominator.AddNominatedPod(pInfo.PodInfo, nil)
	return nil
}
</code></pre>
<p>åœ¨å¯åŠ¨ <em>scheduler</em> æ—¶ï¼Œä¼šå°†è¿™ä¸¤ä¸ªé˜Ÿåˆ—å¼‚æ­¥å¯ç”¨ä¸¤ä¸ªloopæ¥æ“ä½œé˜Ÿåˆ—ã€‚è¡¨ç°åœ¨ <a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/internal/queue/scheduling_queue.go#L292-L295" target="_blank"
   rel="noopener nofollow noreferrer" >Run()</a></p>
<pre><code class="language-go">func (p *PriorityQueue) Run() {
	go wait.Until(p.flushBackoffQCompleted, 1.0*time.Second, p.stop)
	go wait.Until(p.flushUnschedulablePodsLeftover, 30*time.Second, p.stop)
}
</code></pre>
<p>å¯ä»¥çœ‹åˆ° <a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/internal/queue/scheduling_queue.go#L431-L458" target="_blank"
   rel="noopener nofollow noreferrer" >flushBackoffQCompleted</a> ä½œä¸º <code>BackoffQ</code> å®ç°ï¼›è€Œ <a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/pkg/scheduler/internal/queue/scheduling_queue.go#L462-L478" target="_blank"
   rel="noopener nofollow noreferrer" >flushUnschedulablePodsLeftover</a> ä½œä¸º <code>UnschedulablePods</code> å®ç°ã€‚</p>
<p><code>flushBackoffQCompleted</code> æ˜¯ç”¨äºå°†æ‰€æœ‰å·²å®Œæˆå›é€€çš„ pod ä» <code>backoffQ</code> ç§»åˆ° <code>activeQ</code> ä¸­</p>
<pre><code class="language-go">func (p *PriorityQueue) flushBackoffQCompleted() {
	p.lock.Lock()
	defer p.lock.Unlock()
	broadcast := false
	for { // è¿™å°±æ˜¯heapå®ç°çš„æ–¹æ³•ï¼Œçª¥è§†ä¸‹ï¼Œä½†ä¸å¼¹å‡º
		rawPodInfo := p.podBackoffQ.Peek()
		if rawPodInfo == nil {
			break
		}
		pod := rawPodInfo.(*framework.QueuedPodInfo).Pod
		boTime := p.getBackoffTime(rawPodInfo.(*framework.QueuedPodInfo))
		if boTime.After(p.clock.Now()) {
			break
		}
		_, err := p.podBackoffQ.Pop() // å¼¹å‡ºä¸€ä¸ª
		if err != nil {
			klog.ErrorS(err, &quot;Unable to pop pod from backoff queue despite backoff completion&quot;, &quot;pod&quot;, klog.KObj(pod))
			break
		}
		p.activeQ.Add(rawPodInfo) // æ”¾å…¥åˆ°æ´»åŠ¨é˜Ÿåˆ—ä¸­
		metrics.SchedulerQueueIncomingPods.WithLabelValues(&quot;active&quot;, BackoffComplete).Inc()
		broadcast = true
	}

	if broadcast {
		p.cond.Broadcast()
	}
}
</code></pre>
<p><code>flushUnschedulablePodsLeftover </code> å‡½æ•°ç”¨äºå°†åœ¨ <code>unschedulablePods</code> ä¸­çš„å­˜æ”¾æ—¶é—´è¶…è¿‡ <code>podMaxInUnschedulablePodsDuration</code> å€¼çš„ pod ç§»åŠ¨åˆ° <code>backoffQ</code> æˆ– <code>activeQ</code> ä¸­ã€‚</p>
<p><code>podMaxInUnschedulablePodsDuration</code> ä¼šæ ¹æ®é…ç½®ä¼ å…¥ï¼Œå½“æ²¡æœ‰ä¼ å…¥ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨äº† <em><a href="https://github.com/kubernetes/kubernetes/blob/32c483ea6ee90a3a81f382563c91034470af8a4a/cmd/kube-scheduler/app/options/options.go#L77-L84" target="_blank"
   rel="noopener nofollow noreferrer" >Deprecated</a></em> é‚£ä¹ˆä¼šä¸º5åˆ†é’Ÿã€‚</p>
<pre><code class="language-go">func NewOptions() *Options {
	o := &amp;Options{
		SecureServing:  apiserveroptions.NewSecureServingOptions().WithLoopback(),
		Authentication: apiserveroptions.NewDelegatingAuthenticationOptions(),
		Authorization:  apiserveroptions.NewDelegatingAuthorizationOptions(),
		Deprecated: &amp;DeprecatedOptions{
			PodMaxInUnschedulablePodsDuration: 5 * time.Minute,
		},
</code></pre>
<p>å¯¹äº <code>flushUnschedulablePodsLeftover </code> å°±æ˜¯åšä¸€ä¸ªæ—¶é—´å¯¹æ¯”ï¼Œç„¶åæ·»åŠ åˆ°å¯¹åº”çš„é˜Ÿåˆ—ä¸­</p>
<pre><code class="language-go">func (p *PriorityQueue) flushUnschedulablePodsLeftover() {
	p.lock.Lock()
	defer p.lock.Unlock()

	var podsToMove []*framework.QueuedPodInfo
	currentTime := p.clock.Now()
	for _, pInfo := range p.unschedulablePods.podInfoMap {
		lastScheduleTime := pInfo.Timestamp
		if currentTime.Sub(lastScheduleTime) &gt; p.podMaxInUnschedulablePodsDuration {
			podsToMove = append(podsToMove, pInfo)
		}
	}

	if len(podsToMove) &gt; 0 {
		p.movePodsToActiveOrBackoffQueue(podsToMove, UnschedulableTimeout)
	}
}
</code></pre>
<h2 id="æ€»ç»“è°ƒåº¦ä¸Šä¸‹æ–‡æµç¨‹">æ€»ç»“è°ƒåº¦ä¸Šä¸‹æ–‡æµç¨‹<a hidden class="anchor" aria-hidden="true" href="#æ€»ç»“è°ƒåº¦ä¸Šä¸‹æ–‡æµç¨‹">Â¶</a></h2>
<ul>
<li>åœ¨æ„å»ºä¸€ä¸ª <em>scheduler</em> æ—¶ç»å†å¦‚ä¸‹æ­¥éª¤ï¼š
<ul>
<li>å‡†å¤‡cacheï¼Œinformerï¼Œqueueï¼Œé”™è¯¯å¤„ç†å‡½æ•°ç­‰</li>
<li>æ·»åŠ äº‹ä»¶å‡½æ•°ï¼Œä¼šç›‘å¬èµ„æºï¼ˆå¦‚Podï¼‰ï¼Œå½“æœ‰å˜åŠ¨åˆ™è§¦å‘å¯¹åº”äº‹ä»¶å‡½æ•°ï¼Œè¿™æ˜¯å…¥ç«™ <code>activeQ</code></li>
</ul>
</li>
<li>æ„å»ºå®Œæˆåä¼š runï¼Œrunæ—¶ä¼šrunä¸€ä¸ª <code>SchedulingQueue</code>ï¼Œè¿™ä¸ªæ˜¯ä½œä¸ºä¸å¯è°ƒåº¦é˜Ÿåˆ—
<ul>
<li><code>BackoffQ</code></li>
<li><code>UnschedulablePods</code></li>
<li>ä¸å¯è°ƒåº¦é˜Ÿåˆ—ä¼šæ ¹æ®æ³¨å†Œæ—¶å®šæœŸæ¶ˆè´¹é˜Ÿåˆ—ä¸­Podå°†å…¶æ·»åŠ åˆ° <code>activeQ</code> ä¸­</li>
</ul>
</li>
<li>å¯åŠ¨ä¸€ä¸ª <code>scheduleOne</code> çš„loopï¼Œè¿™ä¸ªæ˜¯è°ƒåº¦ä¸Šä¸‹æ–‡ä¸­æ‰€æœ‰çš„æ‰©å±•ç‚¹çš„æ‰§è¡Œï¼Œä¹Ÿæ˜¯ <code>activeQ</code> çš„æ¶ˆè´¹ç«¯
<ul>
<li><code>scheduleOne</code> è·å– pod</li>
<li>æ‰§è¡Œå„ä¸ªæ‰©å±•ç‚¹ï¼Œå¦‚æœå‡ºé”™åˆ™ <em>Error</em> å‡½æ•° <code>MakeDefaultErrorFunc</code> å°†å…¶æ·»åŠ åˆ°ä¸å¯è°ƒåº¦é˜Ÿåˆ—ä¸­</li>
<li>å›åˆ°ä¸å¯è°ƒåº¦é˜Ÿåˆ—ä¸­æ¶ˆè´¹éƒ¨åˆ†</li>
</ul>
</li>
</ul>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">Â¶</a></h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.sobyte.net/post/2022-02/kubernetes-scheduling-framework-and-extender/" target="_blank"
   rel="noopener nofollow noreferrer" >kubernetes scheduler extender</a></p>
</blockquote>


    
    


<div class="copyrightBlock" >
    <div class="articleSuffix-bg"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 147.78 155.96"> <path d="M10.5,99.81a1.9,1.9,0,0,0-.53-.09,1.66,1.66,0,0,0-1.64,1.65A1.64,1.64,0,0,0,10,103a1.57,1.57,0,0,0,.87-.25l26.76,26.82.45-1.08L11.52,101.91A1.65,1.65,0,0,0,10.5,99.81Zm-.13,2a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.58.58,0,0,1,.57-.57h0a.57.57,0,0,1,.56.58A.55.55,0,0,1,10.37,101.77Z" style="fill:#c5c9e0"></path><path d="M56.15,117.58H39.06l0-.09a1.65,1.65,0,0,0-1.36-1H37.5a1.65,1.65,0,1,0,1.56,2.19H55.7L92.92,156h41.44v-1.08h-41Zm-18.25.94a.56.56,0,0,1-.79,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h0a.58.58,0,0,1,.57.58A.54.54,0,0,1,37.9,118.52Z" style="fill:#c5c9e0"></path><path d="M23.52,50.32a1.65,1.65,0,0,0,1.55-1.11H55.28l48-48.13h31.06V0H102.85l-48,48.13H25.07a1.64,1.64,0,0,0-2.09-1,1.64,1.64,0,0,0,.54,3.2Zm0-2.21a.57.57,0,0,1,0,1.13.57.57,0,1,1,0-1.13Z" style="fill:#c5c9e0"></path><polygon points="102.86 0 102.86 0 102.86 0 102.86 0" style="fill:#c5c9e0"></polygon><path d="M107.72,12.14h26.64V11.07H107.27L57.4,61H3.09a1.66,1.66,0,0,0-1.45-.86H1.52A1.65,1.65,0,1,0,2.81,63a1.59,1.59,0,0,0,.45-.87H57.85ZM2.05,62.23a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h.09a.57.57,0,0,1,.32,1Z" style="fill:#c5c9e0"></path><path d="M134.36,43.22V42.14h-22.3l-9.62,9.63a1.64,1.64,0,0,0-2.19.77,1.61,1.61,0,0,0-.17.71,1.65,1.65,0,1,0,3.29,0,1.61,1.61,0,0,0-.16-.72l9.3-9.32Zm-32.64,10.6a.57.57,0,0,1,0-1.13.57.57,0,0,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M147,52.3l-9,9H111.48a1.64,1.64,0,0,0-1.61-1.33h-.14a1.65,1.65,0,1,0,1.6,2.41h27.19l9.26-9.29L147,52.3Zm-37.15,9.85a.56.56,0,0,1-.56-.57h0a.56.56,0,0,1,.56-.56h0a.57.57,0,1,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M66.79,75.35l11,11.06h56.53V85.33H78.27l-11-11.06H49.49L37.12,86.67a1.64,1.64,0,0,0-2.09,1,1.61,1.61,0,0,0-.09.54,1.65,1.65,0,0,0,3.29,0,1.68,1.68,0,0,0-.26-.89l12-12ZM36.58,88.79a.57.57,0,1,1,.57-.56A.57.57,0,0,1,36.58,88.79Z" style="fill:#c5c9e0"></path><path d="M110.61,95.55,92.8,113.4a1.62,1.62,0,1,0,.77.76l17.49-17.53h23.31V95.55ZM92.49,115.28a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.57-.57h0a.58.58,0,0,1,.56.58A.55.55,0,0,1,92.49,115.28Z" style="fill:#c5c9e0"></path><path d="M97.89,122.3H76.62L64.2,109.85a1.65,1.65,0,0,0-.77-2.2,1.77,1.77,0,0,0-.72-.17h-.14a1.65,1.65,0,0,0,.15,3.29,1.58,1.58,0,0,0,.71-.17l12.74,12.77H98.34l17.48-17.52h18.54v-1.08h-19ZM63.12,109.53a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,1.14,0A.54.54,0,0,1,63.12,109.53Z" style="fill:#c5c9e0"></path> </svg> </div>
    <p>æœ¬æ–‡å‘å¸ƒäº<a href="https://www.oomkill.com/about" target="_blank">Cylonçš„æ”¶è—å†Œ</a>ï¼Œè½¬è½½è¯·è‘—ååŸæ–‡é“¾æ¥~</p>
    <p>é“¾æ¥ï¼š<a href="https://www.oomkill.com/2022/07/ch20-schedule-workflow/" target="_blank">https://www.oomkill.com/2022/07/ch20-schedule-workflow/</a></p>
    <p style="margin-bottom: 0px;">ç‰ˆæƒï¼šæœ¬ä½œå“é‡‡ç”¨<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">ã€Œç½²å-éå•†ä¸šæ€§ä½¿ç”¨-ç›¸åŒæ–¹å¼å…±äº« 4.0 å›½é™…ã€</a> è®¸å¯åè®®è¿›è¡Œè®¸å¯ã€‚</p>
    </div>
</div>
  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://www.oomkill.com/2022/07/ch21-scheduling-algorithm/">
    <span class="title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select: text;"><line x1="19" y1="12" x2="5" y2="12" style="user-select: text;"></line><polyline points="12 19 5 12 12 5" style="user-select: text;"></polyline>
      </polyline></svg>&nbsp; </span>
    
    <span>å¦‚ä½•ç†è§£kubernetesè°ƒåº¦æ¡†æ¶ä¸æ’ä»¶ï¼Ÿ</span>
  </a>
  <a class="next" href="https://www.oomkill.com/2022/07/ch16-scheduler/" >
    <span class="title"> </span>
    
    <span>kubernetesçš„å†³ç­–ç»„ä»¶ - kube-scheduleråŸç†åˆ†æ&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg></span>
  </a>
</nav>

  </footer>

  
  <div class="pagination__title">
    <span class="pagination__title-h"></span>
  </div>
  
  
  
  
    <div class="comments-separator"></div>
    

<h3 class="relatedContentTitle" >ç›¸å…³é˜…è¯»</h3>
<ul class="relatedContent">
	
	<li><a href="/2022/07/ch16-scheduler/"><span>kubernetesçš„å†³ç­–ç»„ä»¶ - kube-scheduleråŸç†åˆ†æ</span></a></li>
	
	<li><a href="/2022/07/ch33-admission-webhook/"><span>æ·±å…¥ç†è§£Kubernetes 4A - Admission Controlæºç è§£æ</span></a></li>
	
	<li><a href="/2022/06/ch27-leader-election/"><span>æºç åˆ†æKubernetes HAæœºåˆ¶ - leader election</span></a></li>
	
	<li><a href="/2022/06/ch15-controller-runtime/"><span>æºç åˆ†æKubernetes controllerç»„ä»¶ - controller-runtime</span></a></li>
	
	<li><a href="/2022/06/ch04-apiserver-aggregation/"><span>æ‰©å±•Kubernetes APIçš„å¦ä¸€ç§æ–¹å¼ - APIServer aggregation</span></a></li>
	
</ul>

  

  
    
      <div class="comments-separator"></div>
<div class="comments">
    <script>
    function loadComment() {
        let theme = localStorage.getItem('pref-theme') === 'dark' ? 'dark' : 'light';
        let s = document.createElement('script');
        s.src = 'https://giscus.app/client.js';
        s.setAttribute('data-repo', 'cylonchau\/cylonchau.github.io');
        s.setAttribute('data-repo-id', 'R_kgDOIRlNSQ');
        s.setAttribute('data-category', 'Announcements');
        s.setAttribute('data-category-id', 'DIC_kwDOIRlNSc4CXy1U');
        s.setAttribute('data-mapping', 'title');
        s.setAttribute('data-reactions-enabled', '1');
        s.setAttribute('data-emit-metadata', '1');
        s.setAttribute('data-input-position', 'top');
        s.setAttribute('data-lang', 'zh-TW');
        s.setAttribute('data-theme', theme);
        s.setAttribute('crossorigin', 'anonymous');
        s.setAttribute('async', '');
        document.querySelector('div.comments').innerHTML = '';
        document.querySelector('div.comments').appendChild(s);
    }
    loadComment();
    </script>
</div>
</article>
    </main>
    
<footer class="footer">
  <p>
  Copyright
  <span>&copy; 2024 <a href="https://www.oomkill.com">Cylon&#39;s Collection</a></span></p>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> on github-page & Theme
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '1' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>

<script>
  document.addEventListener('scroll', function (e) {
      const readProgress = document.getElementById("read_progress");
      const scrollHeight = document.documentElement.scrollHeight;
      const clientHeight = document.documentElement.clientHeight;
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
  })
</script>

<script>
  var menu = document.getElementById('menu')
  if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
          localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
  }

  document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
          e.preventDefault();
          var id = this.getAttribute("href").substr(1);
          if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
              document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                  behavior: "smooth"
              });
          } else {
              document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
          }
          if (id === "top") {
              history.replaceState(null, null, " ");
          } else {
              history.pushState(null, null, `#${id}`);
          }
      });
  });
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
      if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
          mybutton.style.visibility = "visible";
          mybutton.style.opacity = "1";
      } else {
          mybutton.style.visibility = "hidden";
          mybutton.style.opacity = "0";
      }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

<script src="/js/instantclick.min.js" data-no-instant
></script>
<script data-no-instant>
  
  
  
  
  
  
  InstantClick.init();
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.6.0/mermaid.min.js" crossorigin="anonymous"></script>
<script>
    mermaid.init(undefined, '.language-mermaid');
</script>
</body>

</html>
