<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ch6 页面置换算法 | Cylon's Collection</title><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NP3JNCPR" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><meta name=keywords content="操作系统,分页置换算法"><meta name=description content="Overviews 功能与目标 实验设置与评价方法 局部页面算法 最优页面置换算法 先进先出算法 最近最久未使用算法 时钟页面置换算法 最不常用置换算法 Belady现象 LRU FIFO Clock对比 全局页面置换算法 工作集模型 工作集页面置换算法 缺页率置换算法 功能与目标 功能 : 当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。
目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)。 具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。
页面锁定 frame locking：用于描述必须常驻内存的操作系统的关键部分或时间关键（time critical）的应用进程。实现的方式是：在页表中添加锁定标记位(lock bit)。
实验设置与评价方法 实例：记录一个进程对页访问的一个轨迹
举例 : 模拟一个实验环境，记录对应的地址访问序列，虚拟地址跟踪(页号, 偏移)&mldr; (3,0) (1,9) (4,1) (2,1) (5,3) (2,0) &mldr; 而offset可以忽略（页不存在才会产生 page fault），生成的页面轨迹 3, 1, 4, 2, 5, 2, 1, &mldr;（替换为，3,1,4,2,5,2,1） 模拟一个页面置换的行为并且记录产生页缺失数的数量
更少的缺失，更好的性能 局部页面置换算法 最优页面置换算法 基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。
这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.
最优页面置换算法（Optimal Page Replacement）可用作其他算法的性能评价的依据，(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法)
在该算法中，会替换在未来最长持续时间内不会使用的页面。如下图所示有 a b c d e五个页，但是只有四个页帧。此时会产生物理页不够，会产生 Page Fault。"><meta name=author content="cylon"><link rel=canonical href=https://www.oomkill.com/2022/04/ch6-page-replacement-algorithms/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.oomkill.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.oomkill.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.oomkill.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.oomkill.com/favicon.ico><link rel=mask-icon href=https://www.oomkill.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.oomkill.com/2022/04/ch6-page-replacement-algorithms/><noscript><style>#theme-toggle,#top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=/assets/css/pe.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/pe.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/v4-shims.min.css><script defer src=https://cdn.staticfile.net/jquery/3.5.1/jquery.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.css><script defer src=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.js></script><script id=MathJax-script async src=https://cdn.staticfile.net/mathjax/3.2.2/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["\\$","\\$"]]}}</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-NP3JNCPR")</script><meta property="og:title" content="ch6 页面置换算法"><meta property="og:description" content="Overviews 功能与目标 实验设置与评价方法 局部页面算法 最优页面置换算法 先进先出算法 最近最久未使用算法 时钟页面置换算法 最不常用置换算法 Belady现象 LRU FIFO Clock对比 全局页面置换算法 工作集模型 工作集页面置换算法 缺页率置换算法 功能与目标 功能 : 当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。
目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)。 具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。
页面锁定 frame locking：用于描述必须常驻内存的操作系统的关键部分或时间关键（time critical）的应用进程。实现的方式是：在页表中添加锁定标记位(lock bit)。
实验设置与评价方法 实例：记录一个进程对页访问的一个轨迹
举例 : 模拟一个实验环境，记录对应的地址访问序列，虚拟地址跟踪(页号, 偏移)&mldr; (3,0) (1,9) (4,1) (2,1) (5,3) (2,0) &mldr; 而offset可以忽略（页不存在才会产生 page fault），生成的页面轨迹 3, 1, 4, 2, 5, 2, 1, &mldr;（替换为，3,1,4,2,5,2,1） 模拟一个页面置换的行为并且记录产生页缺失数的数量
更少的缺失，更好的性能 局部页面置换算法 最优页面置换算法 基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。
这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.
最优页面置换算法（Optimal Page Replacement）可用作其他算法的性能评价的依据，(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法)
在该算法中，会替换在未来最长持续时间内不会使用的页面。如下图所示有 a b c d e五个页，但是只有四个页帧。此时会产生物理页不够，会产生 Page Fault。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.oomkill.com/2022/04/ch6-page-replacement-algorithms/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-28T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-22T23:00:36+08:00"><meta property="og:site_name" content="Cylon's Collection"><meta name=twitter:card content="summary"><meta name=twitter:title content="ch6 页面置换算法"><meta name=twitter:description content="Overviews 功能与目标 实验设置与评价方法 局部页面算法 最优页面置换算法 先进先出算法 最近最久未使用算法 时钟页面置换算法 最不常用置换算法 Belady现象 LRU FIFO Clock对比 全局页面置换算法 工作集模型 工作集页面置换算法 缺页率置换算法 功能与目标 功能 : 当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。
目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)。 具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。
页面锁定 frame locking：用于描述必须常驻内存的操作系统的关键部分或时间关键（time critical）的应用进程。实现的方式是：在页表中添加锁定标记位(lock bit)。
实验设置与评价方法 实例：记录一个进程对页访问的一个轨迹
举例 : 模拟一个实验环境，记录对应的地址访问序列，虚拟地址跟踪(页号, 偏移)&mldr; (3,0) (1,9) (4,1) (2,1) (5,3) (2,0) &mldr; 而offset可以忽略（页不存在才会产生 page fault），生成的页面轨迹 3, 1, 4, 2, 5, 2, 1, &mldr;（替换为，3,1,4,2,5,2,1） 模拟一个页面置换的行为并且记录产生页缺失数的数量
更少的缺失，更好的性能 局部页面置换算法 最优页面置换算法 基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。
这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.
最优页面置换算法（Optimal Page Replacement）可用作其他算法的性能评价的依据，(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法)
在该算法中，会替换在未来最长持续时间内不会使用的页面。如下图所示有 a b c d e五个页，但是只有四个页帧。此时会产生物理页不够，会产生 Page Fault。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.oomkill.com/posts/"},{"@type":"ListItem","position":2,"name":"ch6 页面置换算法","item":"https://www.oomkill.com/2022/04/ch6-page-replacement-algorithms/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ch6 页面置换算法","name":"ch6 页面置换算法","description":"Overviews 功能与目标 实验设置与评价方法 局部页面算法 最优页面置换算法 先进先出算法 最近最久未使用算法 时钟页面置换算法 最不常用置换算法 Belady现象 LRU FIFO Clock对比 全局页面置换算法 工作集模型 工作集页面置换算法 缺页率置换算法 功能与目标 功能 : 当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。\n目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)。 具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。\n页面锁定 frame locking：用于描述必须常驻内存的操作系统的关键部分或时间关键（time critical）的应用进程。实现的方式是：在页表中添加锁定标记位(lock bit)。\n实验设置与评价方法 实例：记录一个进程对页访问的一个轨迹\n举例 : 模拟一个实验环境，记录对应的地址访问序列，虚拟地址跟踪(页号, 偏移)\u0026hellip; (3,0) (1,9) (4,1) (2,1) (5,3) (2,0) \u0026hellip; 而offset可以忽略（页不存在才会产生 page fault），生成的页面轨迹 3, 1, 4, 2, 5, 2, 1, \u0026hellip;（替换为，3,1,4,2,5,2,1） 模拟一个页面置换的行为并且记录产生页缺失数的数量\n更少的缺失，更好的性能 局部页面置换算法 最优页面置换算法 基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。\n这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.\n最优页面置换算法（Optimal Page Replacement）可用作其他算法的性能评价的依据，(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法)\n在该算法中，会替换在未来最长持续时间内不会使用的页面。如下图所示有 a b c d e五个页，但是只有四个页帧。此时会产生物理页不够，会产生 Page Fault。","keywords":["操作系统","分页置换算法"],"articleBody":"Overviews 功能与目标 实验设置与评价方法 局部页面算法 最优页面置换算法 先进先出算法 最近最久未使用算法 时钟页面置换算法 最不常用置换算法 Belady现象 LRU FIFO Clock对比 全局页面置换算法 工作集模型 工作集页面置换算法 缺页率置换算法 功能与目标 功能 : 当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。\n目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)。 具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。\n页面锁定 frame locking：用于描述必须常驻内存的操作系统的关键部分或时间关键（time critical）的应用进程。实现的方式是：在页表中添加锁定标记位(lock bit)。\n实验设置与评价方法 实例：记录一个进程对页访问的一个轨迹\n举例 : 模拟一个实验环境，记录对应的地址访问序列，虚拟地址跟踪(页号, 偏移)… (3,0) (1,9) (4,1) (2,1) (5,3) (2,0) … 而offset可以忽略（页不存在才会产生 page fault），生成的页面轨迹 3, 1, 4, 2, 5, 2, 1, …（替换为，3,1,4,2,5,2,1） 模拟一个页面置换的行为并且记录产生页缺失数的数量\n更少的缺失，更好的性能 局部页面置换算法 最优页面置换算法 基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。\n这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.\n最优页面置换算法（Optimal Page Replacement）可用作其他算法的性能评价的依据，(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法)\n在该算法中，会替换在未来最长持续时间内不会使用的页面。如下图所示有 a b c d e五个页，但是只有四个页帧。此时会产生物理页不够，会产生 Page Fault。\n前四次因为a b c d 已经存在物理页帧中，故前四次不会产生缺页中断，第5次请求e不在物理页帧，此时会产生page fault，发生页面置换。可以看出目前最久不会被访问的页面为d，故将d替换出。\n先进先出置换算法 先进先出页面置换算法 First In First Out (FIFO)，这是最简单的页面替换算法。在这个算法中，操作系统在一个队列中跟踪内存中的所有页面，最旧的页面在队列的前面。当一个页面需要被替换时，队列前面的页面被移除，进行置换。\n性能较差, 调出的页面有可能是经常要访问的页面。并且有belady现象，FIFO算法很少单独使用.\nFIFO算法实现起来非常简单。通过对主存储器中的队列来跟踪所有页面。一旦页面进入，我们就会将其放入队列并继续。这样，最旧的页面将始位于于队列中的第一位。\n图是FIFO的伪代码\nReference\nfifo-page-replacement\npage replacement algorithms\n实例，0时刻物理页中存放了 a b c d虚拟页，\n当时刻为5时，此时e不在物理页帧中，触发 page fault进行页面置换，假设 0 时刻时 入栈顺序为 a-b-c-d，此算法将会把a置换出，把e置换入。后续的换入换出也是按照进入队列顺序进行替换\n最近最久未使用页面置换算法 最近最久未使用，Least Recently Used。基本思路是LRU会在一段时间内跟踪页面的使用情况，当发生缺页时，将最长时间未使用的页面替换为新请求的页面。\nLRU是与OPT近似的一个算法，该算法基于程序的局部性原理，即在最近时间内, 被频繁地访问页面, 再将来的一小段时间内，还可能会再一次被频繁地访问。\nLRU 根据历史推测未来 OPT 根据未来推测未来 实例，0时刻物理页中存放了 a b c d虚拟页，\n当访问5时刻时，此时该替换的应该为最久没有被访问的页面，此时c上次访问时间为1，c为最久没有被访问的页面。\n时钟页面置换算法 时钟页面置换算法 The Clock Algorithm，是类似于LRU的一种算法，对FIFO的一种改进\n基本思路 :\n需要用到页表项的访问位，当一个页面被装入内存时，把该位初始化为0。 然后如果这个页面被访问，则把该位置设为1; 把各个页面组织成环形链表(类似钟表面)，把指针指向最老的页面(最先进来的)； 当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰；若访问位为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到下一格。 实例：维护一个驻留在内存中的链表，指针指向上一次访问的位置\n使用时钟（或use/reference bit）位来记录页面的访问频率 每当引用页面（被访问）时，都会设置reference bit 为 1 时钟指针扫过页面，寻找 reference bit = 0 的页面，替换时钟扫过一圈未被引用的页面\n实例：0时刻物理页中存放了 a b c d虚拟页，在 1 2 3 4时刻请求时，此时会命中，并且在访问时，将reference bit 设置为1，由下图可见\n当时刻为5时，触发置换条件，此时时钟所有reference bit 都为 1，此时会转到第二圈，由于第一圈全将reference bit 设置为0，故，替换的页为 a，同时指针指向下个位置\n二次机会算法 二次机会置换算法 Second Chance，是对时钟算法的一个改进，具体表现为如下几个方面：\n为每个帧添加一个 drity bit。 当每次引用时，将 该 drity bit 设置为1 ； 这样就为该页面提供了二次机会。 当需要找到被置换出的页面时，请在时钟（维护的帧列表）中循环查找 如 drity bit=1，则将其重置（设置为零）并继续。 如 drity bit=0，则置换出该物理帧中的页面。 增加了 drity bit 如 drity bit=0，此时仅为读操作，在置换时无需做写入操作。这样也被称作，增强时钟算法 Enhance Clock。\n实例：0时刻物理页中存放了 a b c d虚拟页，在 1 2 3 4时刻请求时，此时会命中，并且在访问时，将reference bit 设置为1，并且，区分了读写操作，基于这种方式可以清楚的了解那页可以被置换出。\n因为做了写操作，当时刻为4时，a b 的dirty bit 都为1。在经过两轮后，将00位的页替换出，同时指针指向下一位，则替换出C，并将指针指向下一位\nReference\nSecond Chance Page Replacement Policy\n最不常用置换算法 最不常用置换算法 Least Frequently Used，并不是说算法本身不常用，而是说在该算法中，系统会跟踪内存页的引用次数。当发生 Page Fault时，会置换出使用频率最低的页。\n设计思路， LFU是在每个页表项都有增加一个计数器，对于每次内存引用，MMU 都会递增该计数器。当发生缺页中断时，操作系统选择计数器最小的页作为置换。\n实例，有如下页面，此时物理页帧仅有三个，执行图如下：\n0 1 2 3 0 1 2 3 0 1 2 3 4 5 6 7\nPage Fault = $12 \\div 16 = 75%$\nBelady现象 Belady现象也可以称作Belady异常 beladys anomaly，是在操作系统中，随着增加物理页帧数量会导致``Page fault`数量增加的现象。\n如 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（即替换较少使用的页面），因此，被他置换出去的页面不一定是进程不会访问的。\n如：\nf 标记位为 缺页中断。\nPage Requests 3 2 1 0 3 2 4 3 2 1 0 4 Newest Page 3f 2f 1f 0f 3f 2f 4f 4 4 1f 0f 0 3 2 1 0 3 2 2 2 4 1 1 Oldest Page 3 2 1 0 3 3 3 2 4 4 示例1：当存在3个物理页面时 Page Fault = 9。\nPage Requests 3 2 1 0 3 2 4 3 2 1 0 4 Newest Page 3f 2f 1f 0f 0 0 4f 3f 2f 1f 0f 4f 3 2 1 1 1 0 4 3 2 1 0 3 2 2 2 1 0 4 3 2 1 Oldest Page 3 3 3 2 1 0 4 3 2 示例2：当存在4个物理页面时 Page Fault = 10。\n如何避免：使用stack 算法\n什么是stack算法 堆栈算法是指，大小为N的集合始终是大小为N+1集合的子集。\n例如：一个大小为N页的集合保存在内存中的页面始终是大小为 N + 1 的帧保存的页面的子集。\n如 具有3 帧的内存中的 {0,1,2} 不是具有 4 帧内存中 {0,1,4,5} 的子集 ，这种情况下基于堆栈的算法的。\n从上面belady现象可以看出，从 4 3 2 1 0 4 开始是违反基于堆栈的算法的属性\nPage Requests 4 3 2 1 0 4 Newest Page 4f 3f 2f 1f 0f 4f 0 4 3 2 1 0 1 0 4 3 2 1 Oldest Page 2 1 0 4 3 2 Page Requests 4 3 2 1 0 4 Newest Page 4f 4 4 1f 0f 0 2 2 2 4 1 1 Oldest Page 3 3 3 2 4 4 Reference\nwhy stack-based cache algorithms avoidbeladys-anomaly\npage replacement algorithms\n为什么stack-based算法不会发生belady现象 基于堆栈的算法不会产生Belady 现象，这是因为这些类型的算法会为页面（用于替换）分配一个优先级，该优先级与页帧的数量没有管理。如 Optimal、LRU 和 LFU。此外，此类算法还具有良好的模拟特性，即通过一次引用可以计算出任意数量的页帧的命中率缺页率。\nPage Requests 1 2 3 4 1 2 5 1 2 3 4 5 Newest Page 1 2 3 4 1 2 5 1 2 3 4 5 1 2 3 4 1 2 5 1 2 3 4 Oldest Page 1 2 3 4 1 2 5 1 2 3 Page Fault F F F F F F F F F F Page Requests 1 2 3 4 1 2 5 1 2 3 4 5 Newest Page 1 2 3 4 1 2 5 1 2 3 4 5 1 2 3 4 1 2 5 1 2 3 4 1 2 3 4 1 2 5 1 2 3 Oldest Page 1 2 3 4 4 4 5 1 2 Page Fault F F F F F F F F 由上述两表可以看出，在LRU算法中，每次引用一个页面时，它都会移动到堆栈的顶部，因此堆栈的顶部的n个页面是最近使用的n个页面*。*即使帧数增加到 n+1，堆栈顶部也会有 n+1 个最近使用的页面。 构成基于堆栈的算法。\nLRU / FIFO 和 Clock 的比较 LRU和FIFO都是先进先出的思路，只不过LRU是针对页面最近访问时间来进行排序，所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了)。而FIFO是针对页面进入内存的时间来进行排序，这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的。如果一个页面在进入内存后没有被访问，那么它的最近访问时间就是它进入内存的时间。 换句话说，如果内存当中的所有页面都未曾访问过，那么LRU算法就退化为了FIFO算法。\n例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 …\n全局页面置换算法 局部页面置换算法是基于单一程序来说明的，但对于操作系统来讲，执行的程序有很多，如果每个程序使用固定的页面置换算法会产生一定的问题，所以全局页面置换算法就是解决这种问题的。\n存在问题，随着物理页帧的增加，通常情况下会大大减少缺页的次数，而为每个程序分配固定的物理页帧则会大大限制了程序执行的性能；程序是一个动态变化的过程，对内存的需求是可变的。\n工作集模型 如果局部性原理不成立，那么各种页面置换算法就没有说明分别，也没有什么意义。例如：假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9...，即单调递增，那么在物理页有限的前提下, 不管采用何种置换算法，每次的页面访问都必然导致缺页中断。 如果局部性原理是成立的，那么如何来证明它的存在，如何来对它进行定量地分析? 这就是工作集模型. 什么是工作集：进程当前正在使用的页面集称之为工作集 Working Set，可以用一个二元函数来表示：$W(t, \\tau )$；在区间$[t-\\tau+1..t] $ 内的页数。\nt是当前执行的时刻 $\\tau$ 是工作集窗口 Working-set window，一个定长页面访问的时间窗口 $W(t, \\tau )$ 是工作集的大小，即逻辑页的数量. 如果 Example ($\\tau = 10$ ):\nt1 → WS = {1,2,5,6,7}\nt2 → WS = {3,4}\n由此可知，\n工作集是工作集窗口中的页面集 工作集是窗口是一个移动的窗口，表现形式为对每个内存的引用。 当一个新的引用出现在窗口中，对应的页将被标记位该工作集中的成员 最旧一端的引用将从工作窗口中弹出，相应的页就不会再被标记位工作集中的成员了。 例如：如图所示：一个请求序列，假设 $\\tau = 10$ ，则应该如何计算工作集？\n工作集大小的变化 : 进程开始执行后，随着访问新页面逐步建立较稳定的工作集。当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定；局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值。\nti WS t1 {1,2,5,6,7} t2 {1,5,6,7} t3 {1,2,5,6,7} t4 {1,2,3,5,6,7} t5 {1,2,3,4,5,6,7} Reference\nComputing the working set\n常驻集 常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.\n工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数目，以及所采用的页面置换算法; 如果一个进程的整个工作集都在内存当中，即常驻集 包含 工作集, 那么进程将很顺利地运行，而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态); 当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降。 工作集页面置换算法 如图所示，跟踪最后一个 $\\tau$ 参考（不包括断层参考）\n最后一次$\\tau$ 内存访问期间引用的页面是工作集 $\\tau$ 被称为窗口大小 例如，工作集大小为$\\tau=4$ 0时刻，被引用的页面为 a d e 此时 工作集窗口为 {-2, -1, 0}\n时刻1，工作集窗口为 {-2, -1, 0, 1} 工作集为{a c d e}\n时刻2，此时工作集窗口 {-1, 0, 1,2 } 而 工作集为 {a c d} 因为 e已经不在工作集窗口内了。\n时刻4，产生缺页中断，此时将a换出，因为a已经不在工作集窗口内了\n时刻6，产生缺页，将e换入工作集 此时工作集为 {b c e d}\n时刻7，因d不在工作集窗口内，则将d换出，此时工作集为 {b c d}\n缺页率页面置换算法 计算工作集的另一种方法：\n尝试最小化页面错误 当缺页率较高时，增加工作集 当缺页率较低时，减少工作集 缺页率页面置换算法 Page-Fault-Frequency Page Replacment，即可变分配策略：常驻集大小可变。 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.\n可采用全局页面置换的方式，当发生一个缺页中断时，被置换的页面可以是在其他进程当中，各个并发进程竞争地使用物理页面。 优缺点：性能较好，但增加了系统开销。 具体实现：可以使用缺页率算法来动态调整常驻集的大小. 缺页率： $缺页次数 \\div 内存访问次数$；\n影响因素 :\n页面置换算法 分配给进程的物理页面数目 页面本身的大小 程序的编写方法 缺页集算法实现：保持跟踪缺页发生的概率，当出现缺页异常时，计算并记录从上一次缺页异常起到现在的时间。上次最后一次缺页异常的时间 tlast\n如果两次缺页异常间隔时间 “很大”，则减少工作集\n如果 $t_{current} - t_{last} \u003e \\tau $，则从内存中移除 [$t_{current}$ , $t_{last}$]时间内没有被引用的页。 如果两次缺页异常间隔时间 “很小”，则增加工作集\n如果 $t_{current} - t_{last} \u003c \\tau $，则将缺失的页增加到工作集中。 示例：假设窗口大小为2 $\\tau = 2$\n如果当 $t_{current} - t_{last} \u003e 2$，则移除 [$t_{current}$ , $t_{last}$]时间内没有被引用的页。\n如果当 $t_{current} - t_{last} \u003c 2$，则将缺失的页增加到工作集中\n时刻1：产生缺页异常\n时刻4：产生缺页异常，此时 $t_{current} - t_{last} = 4-3 \u003e 2$，此时工作集窗口为{1,2,3,4}，工作集为 {a,c,d,e}则在工作集窗口内没有被访问到的 a,e 则被从工作集中清除。\n时刻6：产生缺页异常，此时 $t_{current} - t_{last} = 6-4 \\leq 2$，此时工作集窗口为{6,5,4}，工作集为 {b,c,d}；此时增加工作集，将e增加到工作集中\nReference\nPage Fault Frequency\n抖动问题 抖动问题是对工作集与常驻集问题的深入\n工作集：程序在执行过程中对内存访问的固有属性 常驻集：当前程序要访问那些页面放到内存中来 如果分配给一个进程的物理页面太少，不能包含整个的工作集, 即常驻集 属于工作集，那么进程将会造成很多的缺页中断，需要频繁的在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为 “抖动” Thrashing 。\n产生抖动的原因：随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.\n更好的负载控制标准：调整MPL，以便：\n平均缺页间隔时间（ means time between page faults MTBF）= 缺页服务时间（ page fault service time PFST）\n$\\sum WS_i = Size of memory$\n","wordCount":"908","inLanguage":"zh","datePublished":"2022-04-28T00:00:00Z","dateModified":"2023-03-22T23:00:36+08:00","author":{"@type":"Person","name":"cylon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.oomkill.com/2022/04/ch6-page-replacement-algorithms/"},"publisher":{"@type":"Organization","name":"Cylon's Collection","logo":{"@type":"ImageObject","url":"https://www.oomkill.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.oomkill.com/><img src=https://www.oomkill.com/favicon.ico alt aria-label=logo height=20>Cylon's Collection</a><div class=logo-switches><button id=theme-toggle><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.oomkill.com/archives><span>归档</span></a></li><li><a href=https://www.oomkill.com/tags><span>标签</span></a></li><li><a href=https://www.oomkill.com/search><span>搜索</span></a></li><li><a href=https://www.oomkill.com/about accesskey=/><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ch6 页面置换算法</h1><div class=post-meta><span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2022-04-28</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>908 字</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>5 分钟</span></span>
<span class=pe-post-meta-item>&nbsp;·&nbsp;<svg t="1714036239378" fill="currentcolor" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6659" width="256" height="256"><path d="M690 78.2c-18.6-18.8-49-19-67.8-.4s-19 49-.4 67.8l255.4 258.6c67.8 68.6 67.8 178.8.0 247.4L653.4 878.2c-18.6 18.8-18.4 49.2.4 67.8s49.2 18.4 67.8-.4l224-226.4c104.8-106 104.8-276.4.0-382.4L690 78.2zM485.4 101.4c-24-24-56.6-37.4-90.6-37.4H96C43 64 0 107 0 160v299c0 34 13.4 66.6 37.4 90.6l336 336c50 50 131 50 181 0l267-267c50-50 50-131 0-181l-336-336zM96 160h299c8.4.0 16.6 3.4 22.6 9.4l336 336c12.4 12.4 12.4 32.8.0 45.2l-267 267c-12.4 12.4-32.8 12.4-45.2.0l-336-336c-6-6-9.4-14.2-9.4-22.6V160zm192 128a64 64 0 10-128 0 64 64 0 10128 0z" p-id="6660"/></svg></span><ul class=pe-post-meta-item><a href=https://www.oomkill.com/tags/os/>#OS</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary><span class=details>目录</span></summary><div class=inner><ul><li><a href=#overviews aria-label=Overviews>Overviews</a><li><a href=#%e5%8a%9f%e8%83%bd%e4%b8%8e%e7%9b%ae%e6%a0%87 aria-label=功能与目标>功能与目标</a><li><a href=#%e5%ae%9e%e9%aa%8c%e8%ae%be%e7%bd%ae%e4%b8%8e%e8%af%84%e4%bb%b7%e6%96%b9%e6%b3%95 aria-label=实验设置与评价方法>实验设置与评价方法</a><li><a href=#%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=局部页面置换算法>局部页面置换算法</a><ul><li><a href=#%e6%9c%80%e4%bc%98%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=最优页面置换算法>最优页面置换算法</a><li><a href=#%e5%85%88%e8%bf%9b%e5%85%88%e5%87%ba%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=先进先出置换算法>先进先出置换算法</a><li><a href=#%e6%9c%80%e8%bf%91%e6%9c%80%e4%b9%85%e6%9c%aa%e4%bd%bf%e7%94%a8%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=最近最久未使用页面置换算法>最近最久未使用页面置换算法</a><li><a href=#%e6%97%b6%e9%92%9f%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=时钟页面置换算法>时钟页面置换算法</a><li><a href=#%e4%ba%8c%e6%ac%a1%e6%9c%ba%e4%bc%9a%e7%ae%97%e6%b3%95 aria-label=二次机会算法>二次机会算法</a><li><a href=#%e6%9c%80%e4%b8%8d%e5%b8%b8%e7%94%a8%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=最不常用置换算法>最不常用置换算法</a><li><a href=#belady%e7%8e%b0%e8%b1%a1 aria-label=Belady现象>Belady现象</a><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afstack%e7%ae%97%e6%b3%95 aria-label=什么是stack算法>什么是stack算法</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88stack-based%e7%ae%97%e6%b3%95%e4%b8%8d%e4%bc%9a%e5%8f%91%e7%94%9fbelady%e7%8e%b0%e8%b1%a1 aria-label=为什么stack-based算法不会发生belady现象>为什么stack-based算法不会发生belady现象</a></ul><li><a href=#lru--fifo-%e5%92%8c-clock-%e7%9a%84%e6%af%94%e8%be%83 aria-label="LRU / FIFO 和 Clock 的比较">LRU / FIFO 和 Clock 的比较</a></ul><li><a href=#%e5%85%a8%e5%b1%80%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=全局页面置换算法>全局页面置换算法</a><ul><li><a href=#%e5%b7%a5%e4%bd%9c%e9%9b%86%e6%a8%a1%e5%9e%8b aria-label=工作集模型>工作集模型</a><li><a href=#%e5%b8%b8%e9%a9%bb%e9%9b%86 aria-label=常驻集>常驻集</a><li><a href=#%e5%b7%a5%e4%bd%9c%e9%9b%86%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=工作集页面置换算法>工作集页面置换算法</a><li><a href=#%e7%bc%ba%e9%a1%b5%e7%8e%87%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=缺页率页面置换算法>缺页率页面置换算法</a><li><a href=#%e6%8a%96%e5%8a%a8%e9%97%ae%e9%a2%98 aria-label=抖动问题>抖动问题</a></li></div></details></div></aside><script src=/js/pe-toc.min.445eb1bfc5e85dd13b9519fcc2a806522e9629b6224a2974052789ba00ab78af.js integrity="sha256-RF6xv8XoXdE7lRn8wqgGUi6WKbYiSil0BSeJugCreK8="></script><div class=post-content><h2 id=overviews>Overviews<a hidden class=anchor aria-hidden=true href=#overviews>#</a></h2><ul><li>功能与目标</li><li>实验设置与评价方法</li><li>局部页面算法<ul><li>最优页面置换算法</li><li>先进先出算法</li><li>最近最久未使用算法</li><li>时钟页面置换算法</li><li>最不常用置换算法</li><li>Belady现象</li><li>LRU FIFO Clock对比</li></ul></li><li>全局页面置换算法<ul><li>工作集模型</li><li>工作集页面置换算法</li><li>缺页率置换算法</li></ul></li></ul><h2 id=功能与目标>功能与目标<a hidden class=anchor aria-hidden=true href=#功能与目标>#</a></h2><p>功能 : 当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。</p><p>目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)。 具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。</p><p>页面锁定 <code>frame locking</code>：用于描述必须常驻内存的操作系统的关键部分或时间关键（<code>time critical</code>）的应用进程。实现的方式是：在页表中添加锁定标记位(<code>lock bit</code>)。</p><h2 id=实验设置与评价方法>实验设置与评价方法<a hidden class=anchor aria-hidden=true href=#实验设置与评价方法>#</a></h2><p>实例：记录一个进程对页访问的一个轨迹</p><ul><li>举例 : 模拟一个实验环境，记录对应的地址访问序列，虚拟地址跟踪(页号, 偏移)&mldr;<ul><li><code>(3,0)</code> <code>(1,9)</code> <code>(4,1)</code> <code>(2,1)</code> <code>(5,3)</code> <code>(2,0)</code> &mldr;</li></ul></li><li>而offset可以忽略（页不存在才会产生 <code>page fault</code>），生成的页面轨迹<ul><li>3, 1, 4, 2, 5, 2, 1, &mldr;（替换为，3,1,4,2,5,2,1）</li></ul></li></ul><p>模拟一个页面置换的行为并且记录产生页缺失数的数量</p><ul><li>更少的缺失，更好的性能</li></ul><h2 id=局部页面置换算法>局部页面置换算法<a hidden class=anchor aria-hidden=true href=#局部页面置换算法>#</a></h2><h3 id=最优页面置换算法>最优页面置换算法<a hidden class=anchor aria-hidden=true href=#最优页面置换算法>#</a></h3><p>基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。</p><p>这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.</p><p>最优页面置换算法（<code>Optimal Page Replacement</code>）可用作其他算法的性能评价的依据，(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法)</p><p>在该算法中，会<strong>替换在未来最长持续时间内不会使用的页面</strong>。如下图所示有 a b c d e五个页，但是只有四个页帧。此时会产生物理页不够，会产生 <code>Page Fault</code>。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321222007583.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321222007583.png#center alt=image-20220321222007583 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>前四次因为a b c d 已经存在物理页帧中，故前四次不会产生缺页中断，第5次请求e不在物理页帧，此时会产生<code>page fault</code>，发生页面置换。可以看出目前最久不会被访问的页面为d，故将d替换出。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321222225824.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321222225824.png#center alt=image-20220321222225824 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=先进先出置换算法>先进先出置换算法<a hidden class=anchor aria-hidden=true href=#先进先出置换算法>#</a></h3><p>先进先出页面置换算法 <code>First In First Out (FIFO)</code>，这是最简单的页面替换算法。在这个算法中，操作系统在一个队列中跟踪内存中的所有页面，最旧的页面在队列的前面。当一个页面需要被替换时，<strong>队列前面的页面被移除</strong>，进行置换。</p><p>性能较差, 调出的页面有可能是经常要访问的页面。并且有belady现象，FIFO算法很少单独使用.</p><p>FIFO算法实现起来非常简单。通过对主存储器中的队列来跟踪所有页面。一旦页面进入，我们就会将其放入队列并继续。这样，最旧的页面将始位于于队列中的第一位。</p><p>图是FIFO的伪代码</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/quicklatex.com-dbcb178160c7c5f3cc5dff1ce288a146_l3.svg><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/quicklatex.com-dbcb178160c7c5f3cc5dff1ce288a146_l3.svg#center alt="由 QuickLaTeX.com 渲染" onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><blockquote><p>Reference</p><p><a href=https://www.baeldung.com/cs/fifo-page-replacement target=_blank rel="noopener nofollow noreferrer">fifo-page-replacement</a></p><p><a href=https://slideplayer.com/slide/17170897/ target=_blank rel="noopener nofollow noreferrer">page replacement algorithms</a></p></blockquote><p>实例，0时刻物理页中存放了 a b c d虚拟页，</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321225453455.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321225453455.png#center alt=image-20220321225453455 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>当时刻为5时，此时e不在物理页帧中，触发 page fault进行页面置换，假设 0 时刻时 入栈顺序为 a-b-c-d，此算法将会把a置换出，把e置换入。后续的换入换出也是按照进入队列顺序进行替换</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321225600170-16478745692234.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321225600170-16478745692234.png#center alt=image-20220321225600170 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=最近最久未使用页面置换算法>最近最久未使用页面置换算法<a hidden class=anchor aria-hidden=true href=#最近最久未使用页面置换算法>#</a></h3><p>最近最久未使用，<code>Least Recently Used</code>。基本思路是LRU会在一段时间内跟踪页面的使用情况，<strong>当发生缺页时，将最长时间未使用的页面替换为新请求的页面</strong>。</p><p>LRU是与OPT近似的一个算法，该算法基于程序的局部性原理，即在最近时间内, 被频繁地访问页面, 再将来的一小段时间内，还可能会再一次被频繁地访问。</p><ul><li>LRU 根据历史推测未来</li><li>OPT 根据未来推测未来</li></ul><p>实例，0时刻物理页中存放了 a b c d虚拟页，</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321230813035.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321230813035.png#center alt=image-20220321230813035 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>当访问5时刻时，此时该替换的应该为最久没有被访问的页面，此时c上次访问时间为1，c为最久没有被访问的页面。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321230831419.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321230831419.png#center alt=image-20220321230831419 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=时钟页面置换算法>时钟页面置换算法<a hidden class=anchor aria-hidden=true href=#时钟页面置换算法>#</a></h3><p>时钟页面置换算法 <code>The Clock Algorithm</code>，是类似于LRU的一种算法，对FIFO的一种改进</p><p>基本思路 :</p><ul><li>需要用到页表项的访问位，当一个页面被装入内存时，把该位初始化为0。 然后如果这个页面被访问，则把该位置设为1;</li><li>把各个页面组织成环形链表(类似钟表面)，把指针指向最老的页面(最先进来的)；</li><li>当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰；若访问位为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到下一格。</li></ul><p>实例：维护一个驻留在内存中的链表，指针指向上一次访问的位置</p><ul><li>使用时钟（或use/reference bit）位来记录页面的访问频率</li><li>每当引用页面（被访问）时，都会设置<code>reference bit</code> 为 1</li></ul><p>时钟指针扫过页面，寻找 <code>reference bit</code> = 0 的页面，替换时钟扫过一圈未被引用的页面</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321234327704.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321234327704.png#center alt=image-20220321234327704 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>实例：0时刻物理页中存放了 a b c d虚拟页，在 1 2 3 4时刻请求时，此时会命中，并且在访问时，将<code>reference bit</code> 设置为1，由下图可见</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321235251072.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321235251072.png#center alt=image-20220321235251072 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>当时刻为5时，触发置换条件，此时时钟所有<code>reference bit</code> 都为 1，此时会转到第二圈，由于第一圈全将<code>reference bit</code> 设置为0，故，替换的页为 <code>a</code>，同时指针指向下个位置</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321235223407.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220321235223407.png#center alt=image-20220321235223407 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=二次机会算法>二次机会算法<a hidden class=anchor aria-hidden=true href=#二次机会算法>#</a></h3><p>二次机会置换算法 <code>Second Chance</code>，是对时钟算法的一个改进，具体表现为如下几个方面：</p><ul><li>为每个帧添加一个 <code>drity bit</code>。</li><li>当每次引用时，将 该 <code>drity bit</code> 设置为<code>1</code> ； 这样就为该页面提供了二次机会。</li><li>当需要找到被置换出的页面时，请在时钟（维护的帧列表）中循环查找<ul><li>如 <code>drity bit</code>=1，则将其重置（设置为零）并继续。</li><li>如 <code>drity bit</code>=0，则置换出该物理帧中的页面。</li></ul></li></ul><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322161003485.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322161003485.png#center alt=image-20220322161003485 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>增加了 <code>drity bit</code> 如 drity bit=0，此时仅为读操作，在置换时无需做写入操作。这样也被称作，增强时钟算法 <code>Enhance Clock</code>。</p><p>实例：0时刻物理页中存放了 a b c d虚拟页，在 1 2 3 4时刻请求时，此时会命中，并且在访问时，将<code>reference bit</code> 设置为1，并且，区分了读写操作，基于这种方式可以清楚的了解那页可以被置换出。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322162430894.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322162430894.png#center alt=image-20220322162430894 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>因为做了写操作，当时刻为4时，a b 的<code>dirty bit</code> 都为1。在经过两轮后，将00位的页替换出，同时指针指向下一位，则替换出C，并将指针指向下一位</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322162834999.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322162834999.png#center alt=image-20220322162834999 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><blockquote><p>Reference</p><p><a href=http://www.mathcs.emory.edu/~cheung/Courses/355/Syllabus/9-virtual-mem/SC-replace.html target=_blank rel="noopener nofollow noreferrer">Second Chance Page Replacement Policy</a></p></blockquote><h3 id=最不常用置换算法>最不常用置换算法<a hidden class=anchor aria-hidden=true href=#最不常用置换算法>#</a></h3><p>最不常用置换算法 <code>Least Frequently Used</code>，并不是说算法本身不常用，而是说在该算法中，系统会跟踪内存页的引用次数。当发生 <code>Page Fault</code>时，会置换出使用频率最低的页。</p><p>设计思路， LFU是在每个页表项都有增加一个计数器，对于每次内存引用，MMU 都会递增该计数器。当发生缺页中断时，操作系统选择计数器最小的页作为置换。</p><p>实例，有如下页面，此时物理页帧仅有三个，执行图如下：</p><blockquote><p>0 1 2 3 0 1 2 3 0 1 2 3 4 5 6 7</p></blockquote><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/LFU.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/LFU.png#center alt=LFU onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>Page Fault = $12 \div 16 = 75%$</p><h3 id=belady现象>Belady现象<a hidden class=anchor aria-hidden=true href=#belady现象>#</a></h3><p>Belady现象也可以称作Belady异常 <code>beladys anomaly</code>，是在操作系统中，随着增加物理页帧数量会导致``Page fault`数量增加的现象。</p><p>如 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（即替换较少使用的页面），因此，被他置换出去的页面不一定是进程不会访问的。</p><p>如：</p><p><code>f</code> 标记位为 缺页中断。</p><table><thead><tr><th>Page Requests</th><th>3</th><th>2</th><th>1</th><th>0</th><th>3</th><th>2</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>4</th></tr></thead><tbody><tr><td>Newest Page</td><td>3f</td><td>2f</td><td>1f</td><td>0f</td><td>3f</td><td>2f</td><td>4f</td><td>4</td><td>4</td><td>1f</td><td>0f</td><td>0</td></tr><tr><td></td><td></td><td>3</td><td>2</td><td>1</td><td>0</td><td>3</td><td>2</td><td>2</td><td>2</td><td>4</td><td>1</td><td>1</td></tr><tr><td>Oldest Page</td><td></td><td></td><td>3</td><td>2</td><td>1</td><td>0</td><td>3</td><td>3</td><td>3</td><td>2</td><td>4</td><td>4</td></tr></tbody></table><p>示例1：当存在3个物理页面时 Page Fault = 9。</p><table><thead><tr><th>Page Requests</th><th>3</th><th>2</th><th>1</th><th>0</th><th>3</th><th>2</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>4</th></tr></thead><tbody><tr><td><strong>Newest Page</strong></td><td>3f</td><td>2f</td><td>1f</td><td>0f</td><td>0</td><td>0</td><td>4f</td><td>3f</td><td>2f</td><td>1f</td><td>0f</td><td>4f</td></tr><tr><td></td><td></td><td>3</td><td>2</td><td>1</td><td>1</td><td>1</td><td>0</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td>3</td><td>2</td><td>2</td><td>2</td><td>1</td><td>0</td><td>4</td><td>3</td><td>2</td><td>1</td></tr><tr><td><strong>Oldest Page</strong></td><td></td><td></td><td></td><td>3</td><td>3</td><td>3</td><td>2</td><td>1</td><td>0</td><td>4</td><td>3</td><td>2</td></tr></tbody></table><p>示例2：当存在4个物理页面时 Page Fault = 10。</p><p>如何避免：使用stack 算法</p><h3 id=什么是stack算法>什么是stack算法<a hidden class=anchor aria-hidden=true href=#什么是stack算法>#</a></h3><blockquote><p>堆栈算法是指，大小为N的集合始终是大小为N+1集合的子集。</p><p>例如：一个大小为N页的集合保存在内存中的页面始终是大小为 N + 1 的帧保存的页面的子集。</p></blockquote><p>如 具有3 帧的内存中的 <code>{0,1,2}</code> 不是具有 4 帧内存中 <code>{0,1,4,5}</code> 的子集 ，这种情况下基于堆栈的算法的。</p><p>从上面belady现象可以看出，从 4 3 2 1 0 4 开始是违反基于堆栈的算法的属性</p><table><thead><tr><th>Page Requests</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>4</th></tr></thead><tbody><tr><td>Newest Page</td><td>4f</td><td>3f</td><td>2f</td><td>1f</td><td>0f</td><td>4f</td></tr><tr><td></td><td>0</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td></td><td>1</td><td>0</td><td>4</td><td>3</td><td>2</td><td>1</td></tr><tr><td>Oldest Page</td><td>2</td><td>1</td><td>0</td><td>4</td><td>3</td><td>2</td></tr></tbody></table><table><thead><tr><th>Page Requests</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th><th>4</th></tr></thead><tbody><tr><td>Newest Page</td><td>4f</td><td>4</td><td>4</td><td>1f</td><td>0f</td><td>0</td></tr><tr><td></td><td>2</td><td>2</td><td>2</td><td>4</td><td>1</td><td>1</td></tr><tr><td>Oldest Page</td><td>3</td><td>3</td><td>3</td><td>2</td><td>4</td><td>4</td></tr></tbody></table><blockquote><p>Reference</p><p><a href=https://cs.stackexchange.com/questions/59355/how-do-stack-based-cache-algorithms-avoid-beladys-anomaly target=_blank rel="noopener nofollow noreferrer">why stack-based cache algorithms avoidbeladys-anomaly</a></p><p><a href=https://www.geeksforgeeks.org/beladys-anomaly-in-page-replacement-algorithms/ target=_blank rel="noopener nofollow noreferrer">page replacement algorithms</a></p></blockquote><h4 id=为什么stack-based算法不会发生belady现象>为什么stack-based算法不会发生belady现象<a hidden class=anchor aria-hidden=true href=#为什么stack-based算法不会发生belady现象>#</a></h4><p>基于堆栈的算法不会产生Belady 现象，这是因为这些类型的算法会为页面（用于替换）分配一个优先级，该优先级与页帧的数量没有管理。如 <code>Optimal</code>、<code>LRU</code> 和 <code>LFU</code>。此外，此类算法还具有良好的模拟特性，即通过一次引用可以计算出任意数量的页帧的命中率缺页率。</p><table><thead><tr><th>Page Requests</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Newest Page</td><td>1</td><td>2</td><td>3</td><td>4</td><td>1</td><td>2</td><td>5</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td></td><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>1</td><td>2</td><td>5</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>Oldest Page</td><td></td><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>1</td><td>2</td><td>5</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Page Fault</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td></td><td></td><td>F</td><td>F</td><td>F</td></tr></tbody></table><table><thead><tr><th>Page Requests</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Newest Page</td><td>1</td><td>2</td><td>3</td><td>4</td><td>1</td><td>2</td><td>5</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td></td><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>1</td><td>2</td><td>5</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td></td><td></td><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>1</td><td>2</td><td>5</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Oldest Page</td><td></td><td></td><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>4</td><td>4</td><td>5</td><td>1</td><td>2</td></tr><tr><td>Page Fault</td><td>F</td><td>F</td><td>F</td><td>F</td><td></td><td></td><td>F</td><td></td><td></td><td>F</td><td>F</td><td>F</td></tr></tbody></table><p>由上述两表可以看出，在LRU算法中，每次引用一个页面时，它都会移动到堆栈的顶部，因此堆栈的顶部的n个页面是最近使用的n个页面*。*即使帧数增加到 <code>n+1</code>，堆栈顶部也会有 <code>n+1</code> 个最近使用的页面。 构成基于堆栈的算法。</p><h3 id=lru--fifo-和-clock-的比较>LRU / FIFO 和 Clock 的比较<a hidden class=anchor aria-hidden=true href=#lru--fifo-和-clock-的比较>#</a></h3><p>LRU和FIFO都是先进先出的思路，只不过LRU是针对页面最近访问时间来进行排序，所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了)。而FIFO是针对页面进入内存的时间来进行排序，这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的。如果一个页面在进入内存后没有被访问，那么它的最近访问时间就是它进入内存的时间。 换句话说，如果内存当中的所有页面都未曾访问过，那么LRU算法就退化为了FIFO算法。</p><p>例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 &mldr;</p><h2 id=全局页面置换算法>全局页面置换算法<a hidden class=anchor aria-hidden=true href=#全局页面置换算法>#</a></h2><p>局部页面置换算法是基于单一程序来说明的，但对于操作系统来讲，执行的程序有很多，如果每个程序使用固定的页面置换算法会产生一定的问题，所以全局页面置换算法就是解决这种问题的。</p><p>存在问题，随着物理页帧的增加，通常情况下会大大减少缺页的次数，而为每个程序分配固定的物理页帧则会大大限制了程序执行的性能；程序是一个动态变化的过程，对内存的需求是可变的。</p><h3 id=工作集模型>工作集模型<a hidden class=anchor aria-hidden=true href=#工作集模型>#</a></h3><ul><li>如果局部性原理不成立，那么各种页面置换算法就没有说明分别，也没有什么意义。例如：假设进程对逻辑页面的访问顺序是<code>1,2,3,4,5,6,6,7,8,9...</code>，即单调递增，那么在物理页有限的前提下, 不管采用何种置换算法，每次的页面访问都必然导致缺页中断。</li><li>如果局部性原理是成立的，那么如何来证明它的存在，如何来对它进行定量地分析? 这就是工作集模型.</li></ul><p><strong>什么是工作集</strong>：进程当前正在使用的页面集称之为工作集 <code>Working Set</code>，可以用一个二元函数来表示：$W(t, \tau )$；在区间$[t-\tau+1..t] $ 内的页数。</p><ul><li>t是当前执行的时刻</li><li>$\tau$ 是工作集窗口 <code>Working-set window</code>，一个定长页面访问的时间窗口</li><li>$W(t, \tau )$ 是工作集的大小，即逻辑页的数量.</li></ul><blockquote><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322192606257.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322192606257.png#center alt=image-20220322192606257 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>如果 Example ($\tau = 10$ ):</p><p>t1 → WS =<code> {1,2,5,6,7}</code></p><p>t2 → WS = <code>{3,4}</code></p></blockquote><p>由此可知，</p><ul><li>工作集是工作集窗口中的页面集<ul><li>工作集是窗口是一个移动的窗口，表现形式为对每个内存的引用。</li><li>当一个新的引用出现在窗口中，对应的页将被标记位该工作集中的成员</li><li>最旧一端的引用将从工作窗口中弹出，相应的页就不会再被标记位工作集中的成员了。</li></ul></li></ul><p>例如：如图所示：一个请求序列，假设 $\tau = 10$ ，则应该如何计算工作集？</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322193820089.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322193820089.png#center alt=image-20220322193820089 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>工作集大小的变化 : 进程开始执行后，随着访问新页面逐步建立较稳定的工作集。当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定；局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值。</p><table><thead><tr><th>ti</th><th>WS</th></tr></thead><tbody><tr><td>t1</td><td>{1,2,5,6,7}</td></tr><tr><td>t2</td><td>{1,5,6,7}</td></tr><tr><td>t3</td><td>{1,2,5,6,7}</td></tr><tr><td>t4</td><td>{1,2,3,5,6,7}</td></tr><tr><td>t5</td><td>{1,2,3,4,5,6,7}</td></tr></tbody></table><blockquote><p>Reference</p><p><a href=https://www.cs.cornell.edu/courses/cs4410/2016su/slides/lecture13.pdf target=_blank rel="noopener nofollow noreferrer">Computing the working set</a></p></blockquote><h3 id=常驻集>常驻集<a hidden class=anchor aria-hidden=true href=#常驻集>#</a></h3><p>常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.</p><ul><li>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数目，以及所采用的页面置换算法;</li><li>如果一个进程的整个工作集都在内存当中，即常驻集 包含 工作集, 那么进程将很顺利地运行，而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);</li><li>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降。</li></ul><h3 id=工作集页面置换算法>工作集页面置换算法<a hidden class=anchor aria-hidden=true href=#工作集页面置换算法>#</a></h3><p>如图所示，跟踪最后一个 $\tau$ 参考（不包括断层参考）</p><ul><li>最后一次$\tau$ 内存访问期间引用的页面是工作集</li><li>$\tau$ 被称为窗口大小</li><li>例如，工作集大小为$\tau=4$</li></ul><p>0时刻，被引用的页面为 a d e 此时 工作集窗口为 <code>{-2, -1, 0}</code></p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322215333300.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322215333300.png#center alt=image-20220322215333300 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>时刻1，工作集窗口为 <code>{-2, -1, 0, 1} </code>工作集为<code>{a c d e}</code></p><p>时刻2，此时工作集窗口 {-1, 0, 1,2 } 而 工作集为 {a c d} 因为 e已经不在工作集窗口内了。</p><p>时刻4，产生缺页中断，此时将a换出，因为a已经不在工作集窗口内了</p><p>时刻6，产生缺页，将e换入工作集 此时工作集为 {b c e d}</p><p>时刻7，因d不在工作集窗口内，则将d换出，此时工作集为 {b c d}</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322215753155.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322215753155.png#center alt=image-20220322215753155 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=缺页率页面置换算法>缺页率页面置换算法<a hidden class=anchor aria-hidden=true href=#缺页率页面置换算法>#</a></h3><p>计算工作集的另一种方法：</p><ul><li>尝试最小化页面错误<ul><li>当缺页率较高时，增加工作集</li><li>当缺页率较低时，减少工作集</li></ul></li></ul><p>缺页率页面置换算法 <code>Page-Fault-Frequency Page Replacment</code>，即可变分配策略：<strong>常驻集大小可变</strong>。 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.</p><ul><li>可采用全局页面置换的方式，当发生一个缺页中断时，被置换的页面可以是在其他进程当中，各个并发进程竞争地使用物理页面。</li><li>优缺点：性能较好，但增加了系统开销。</li><li>具体实现：可以使用缺页率算法来动态调整常驻集的大小.</li></ul><p>缺页率： $缺页次数 \div 内存访问次数$；</p><p>影响因素 :</p><ul><li>页面置换算法</li><li>分配给进程的物理页面数目</li><li>页面本身的大小</li><li>程序的编写方法</li></ul><p>缺页集算法实现：保持跟踪缺页发生的概率，当出现缺页异常时，计算并记录从上一次缺页异常起到现在的时间。上次最后一次缺页异常的时间 <strong>t<sub>last</sub></strong></p><p>如果两次缺页异常间隔时间 “很大”，则减少工作集</p><ul><li>如果 $t_{current} - t_{last} > \tau $，则从内存中移除 [$t_{current}$ , $t_{last}$]时间内没有被引用的页。</li></ul><p>如果两次缺页异常间隔时间 “很小”，则增加工作集</p><ul><li>如果 $t_{current} - t_{last} &lt; \tau $，则将缺失的页增加到工作集中。</li></ul><p><strong>示例</strong>：假设窗口大小为2 $\tau = 2$</p><p>如果当 $t_{current} - t_{last} > 2$，则移除 [$t_{current}$ , $t_{last}$]时间内没有被引用的页。</p><p>如果当 $t_{current} - t_{last} &lt; 2$，则将缺失的页增加到工作集中</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322224045359.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322224045359.png#center alt=image-20220322224045359 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>时刻1：产生缺页异常</p><p>时刻4：产生缺页异常，此时 $t_{current} - t_{last} = 4-3 > 2$，此时工作集窗口为{1,2,3,4}，工作集为 {a,c,d,e}则在工作集窗口内没有被访问到的 a,e 则被从工作集中清除。</p><p>时刻6：产生缺页异常，此时 $t_{current} - t_{last} = 6-4 \leq 2$，此时工作集窗口为{6,5,4}，工作集为 {b,c,d}；此时增加工作集，将e增加到工作集中</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322224322218.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322224322218.png#center alt=image-20220322224322218 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><blockquote><p>Reference</p><p><a href=http://www.cs.cornell.edu/courses/cs4410/2013su/slides/lecture14.pdf target=_blank rel="noopener nofollow noreferrer">Page Fault Frequency</a></p></blockquote><h3 id=抖动问题>抖动问题<a hidden class=anchor aria-hidden=true href=#抖动问题>#</a></h3><p>抖动问题是对工作集与常驻集问题的深入</p><ul><li>工作集：程序在执行过程中对内存访问的固有属性</li><li>常驻集：当前程序要访问那些页面放到内存中来</li></ul><p>如果分配给一个进程的物理页面太少，不能包含整个的工作集, 即常驻集 属于工作集，那么进程将会造成很多的缺页中断，需要频繁的在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为 &ldquo;抖动&rdquo; <code>Thrashing</code> 。</p><p>产生抖动的原因：随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.</p><p>更好的负载控制标准：调整MPL，以便：</p><p>平均缺页间隔时间（ <code>means time between page faults</code> MTBF）= 缺页服务时间（ <code>page fault service time</code> PFST）</p><p>$\sum WS_i = Size of memory$</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322231054093.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220322231054093.png#center alt=image-20220322231054093 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p></div><div class=pe-copyright><hr><blockquote><p>本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。</p><p>文章标题：ch6 页面置换算法</p><p>文章链接：<a href=https://www.oomkill.com/2022/04/ch6-page-replacement-algorithms/ target=_blank>https://www.oomkill.com/2022/04/ch6-page-replacement-algorithms/</a></p><p>许可协议：<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></p></blockquote></div><div class=comments-separator></div><h3 class=relatedContentTitle>相关阅读</h3><ul class=relatedContent><li><a href=/2022/04/ch5-virtual-memory/><span>ch5 虚拟内存</span></a></li><li><a href=/2022/04/ch4-non-contiguous-memory-allocation/><span>ch4 操作内存管理 - 非连续内存分配</span></a></li><li><a href=/2022/04/ch3-contiguous-memory-allocation/><span>ch3 操作内存管理 - 连续内存分配</span></a></li></ul><div class=comments-separator></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.oomkill.com/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=https://www.oomkill.com/2022/04/ch7-process-management/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></polyline></svg>&nbsp;</span>
<span>ch7 进程管理</span>
</a><a class=next href=https://www.oomkill.com/2022/04/ch5-virtual-memory/><span class=title></span>
<span>ch5 虚拟内存&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span></a></nav></footer><div class=pe-comments-decoration><p class=pe-comments-title></p><p class=pe-comments-subtitle></p></div><div id=pe-comments></div><script src=/js/pe-go-comment.min.86a214102576ba5f9b7bdc29eed8d58dd56e34aef80b3c65c73ea9cc88443696.js integrity="sha256-hqIUECV2ul+be9wp7tjVjdVuNK74Czxlxz6pzIhENpY="></script><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"cylonchau/cylonchau.github.io","data-repo-id":"R_kgDOIRlNSQ","data-category":"Announcements","data-category-id":"DIC_kwDOIRlNSc4CXy1U","data-mapping":"pathname","data-term":"posts/ch6 Page Replacement Algorithms","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":getStoredTheme(),"data-lang":"zh-TW","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#pe-comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.oomkill.com/>Cylon's Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> on
<a href=https://pages.github.com/ rel=noopener target=_blank>GitHub Pages</a> & Theme
        <a href=https://github.com/tofuwine/PaperMod-PE rel=noopener target=_blank>PaperMod-PE</a></span></footer><div class=pe-right-sidebar><a href=javascript:void(0); id=theme-toggle-float class=pe-float-btn><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a><a href=#top class=pe-float-btn id=top-link><span id=pe-read-progress></span></a></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>