<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Programming on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/categories/programming/</link>
    <description>Recent content in Programming on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 28 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ch0 ide</title>
      <link>https://www.oomkill.com/2022/09/ch0-ide/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch0-ide/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="visual-studio使用">Visual Studio使用</h2>
<h3 id="离线安装包">离线安装包</h3>
<p>在页面 <sup><a href="#4">[4]</a></sup> 下载安装引导命令，下载完成后使用命令（对于C++来说）</p>
<pre><code class="language-bat">vs_Professional.exe --layout ‪1111 --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --lang en-US zh-CN
</code></pre>
<p>随后会触发下载，等待下载完成后，在 <code>--layout</code> 指定的目录上点击 <em><strong>vs_setup</strong></em> 开始离线安装。</p>
<blockquote>
<p>Note: 对于完全脱离C盘安装可以使用下面的脚本，更改变量为要安装的路径</p>
</blockquote>
<pre><code class="language-bat">:: 关闭终端回显
@echo off

SET ROOT_PATH=D:\Program Files\Microsoft Visual Studio
SET X86_PATH=%ROOT_PATH%\Program Files (x86)
SET X86_VS_PATH=%X86_PATH%\Microsoft Visual Studio
SET X86_SDK_PATH=%X86_PATH%\Microsoft SDKs
SET X86_KITS_PATH=%X86_PATH%\Windows Kits
SET X86_AV_PATH=%X86_PATH%\Application Verifier

SET X64_PATH=%ROOT_PATH%\Program Files
rem SET X64_VS_PATH=%X64_PATH%\Microsoft Visual Studio
SET X64_AV_PATH=%X64_PATH%\Application Verifier
SET X64_SQL_PATH=%X64_PATH%\Microsoft SQL Server

SET PD_PATH=%ROOT_PATH%\ProgramData
SET PD_VS_PATH=%PD_PATH%\Microsoft\VisualStudio
SET PD_PC_PATH=%PD_PATH%\Package Cache

@echo =======link directory to %ROOT_PATH%=======:

SET S_X86_SKD_PATH=C:\Program Files (x86)\Microsoft SDKs
SET S_X86_VS_PATH=C:\Program Files (x86)\Microsoft Visual Studio
SET S_X86_KITS_PATH=C:\Program Files (x86)\Windows Kits
SET S_X86_AV_PATH=C:\Program Files (x86)\Application Verifier

SET S_X64_AV_PATH=C:\Program Files\Application Verifier
SET S_X64_SQL_PATH=C:\Program Files\Microsoft SQL Server

SET S_PD_VS_PATH=C:\ProgramData\Microsoft\VisualStudio
SET S_PD_PC_PATH=C:\ProgramData\Package Cache


pause
@echo =======setting visual studio environment=======:


@echo =======check directory exist=======:

if not exist %ROOT_PATH% (
	echo &quot;%ROOT_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%ROOT_PATH%&quot;
)

if not exist %X86_PATH% (
	echo &quot;%X86_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%X86_PATH%&quot;
)

if not exist %X86_VS_PATH% (
	echo &quot;%X86_VS_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%X86_VS_PATH%&quot;
)

if not exist %X86_SDK_PATH% (
	echo &quot;%X86_SDK_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%X86_SDK_PATH%&quot;
)

if not exist %X86_KITS_PATH% (
	echo &quot;%X86_KITS_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%X86_KITS_PATH%&quot;
)

if not exist %X86_AV_PATH% (
	echo &quot;%X86_AV_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%X86_AV_PATH%&quot;
)

if not exist %X64_PATH% (
	echo &quot;%X64_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%X64_PATH%&quot;
)

if not exist %X64_AV_PATH% (
	echo &quot;%X64_AV_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%X64_AV_PATH%&quot;
)

if not exist %X64_SQL_PATH% (
	echo &quot;%X64_SQL_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%X64_SQL_PATH%&quot;
)

if not exist %PD_PATH% (
	echo &quot;%PD_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%PD_PATH%&quot;
)

if not exist %PD_VS_PATH% (
	echo &quot;%PD_VS_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%PD_VS_PATH%&quot;
)

if not exist %PD_PC_PATH% (
	echo &quot;%PD_PC_PATH%目录不存在，已创建该目录！&quot;
	md &quot;%PD_PC_PATH%&quot;
)


@echo =======link directory to %ROOT_PATH%=======:
:: x86 link
mklink /j &quot;%S_X86_SKD_PATH%&quot; &quot;%X86_SDK_PATH%&quot;
mklink /j &quot;%S_X86_VS_PATH%&quot;  &quot;%X86_VS_PATH%&quot;
mklink /j &quot;%S_X86_KITS_PATH%&quot; &quot;%X86_KITS_PATH%&quot;
mklink /j &quot;%S_X86_AV_PATH%&quot;  &quot;%X86_AV_PATH%&quot;

:: x64 link
mklink /j &quot;%S_X64_AV_PATH%&quot; &quot;%X64_AV_PATH%&quot;
mklink /j &quot;%S_X64_SQL_PATH%&quot; &quot;%X64_SQL_PATH%&quot;

:: ProgramData link
mklink /j &quot;%S_PD_VS_PATH%&quot; &quot;%PD_VS_PATH%&quot; 
mklink /j &quot;%S_PD_PC_PATH%&quot; &quot;%PD_PC_PATH%&quot;
pause
</code></pre>
<h3 id="vs快捷键">VS快捷键</h3>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + k,Ctrl + f</td>
<td>自动格式化代码</td>
</tr>
<tr>
<td>Ctrl + k,Ctrl + c</td>
<td>注释代码</td>
</tr>
<tr>
<td>Ctrl + k,Ctrl + u</td>
<td>取消注释代码</td>
</tr>
<tr>
<td>F9</td>
<td>设置断点</td>
</tr>
<tr>
<td>F5</td>
<td>调试运行</td>
</tr>
<tr>
<td>Ctrl + F5</td>
<td>不调试运行</td>
</tr>
<tr>
<td>Ctrl + Shift + b</td>
<td>编译，不运行</td>
</tr>
<tr>
<td>F10</td>
<td>next调试</td>
</tr>
<tr>
<td>F11</td>
<td>step调试</td>
</tr>
</tbody>
</table>
<h3 id="调试">调试</h3>
<p>添加行号：工具&ndash;》选项 &ndash;》文本编辑器&ndash;》C/C++ &ndash;》行号</p>
<p>调试步骤</p>
<ul>
<li>设置断点。F5启动调试</li>
<li>停止（断点处）的位置，是尚未执行的指令。</li>
<li>逐语句执行一下条 （F11）：进入函数内部，逐条执行跟踪。</li>
<li>逐过程执行一下条 （F10）：不进入函数内部，逐条执行程序。</li>
<li>监视：调试 &ndash;》窗口 &ndash;》监视：输入监视变量名。自动监视变量值的变化。</li>
</ul>
<h2 id="vs-code使用">VS Code使用</h2>
<p>安装扩展 <em><strong>C/C++ Extension Pack</strong></em>，<em><strong>Code Runner</strong></em></p>
<p>调试相关快捷键：</p>
<ul>
<li>F5 进入调试</li>
<li>F9 切换断点</li>
<li>F10 单步跳过（逐过程执行）</li>
<li>F11 单步执行（逐语句执行，可进入执行函数体）</li>
<li>Shift+F5 停止调试</li>
<li>Ctrl+Shift+F5重启调试</li>
<li>Ctrl+F5 开始执行，不进入断点</li>
<li>Ctrl+F9 启用/停止断点</li>
<li>Ctrl+Shift+F9 删除全部断点</li>
<li>Ctrl+b 隐藏/打开侧边框</li>
<li>Ctrl+` 隐藏/打开terminal</li>
<li>Ctrl+j 隐藏/打开下边框（plannel）</li>
<li>Ctrl+Shift+D 打开侧边框 Run and Debug</li>
<li>Ctrl+Shift+E 打开侧边框 Explorer</li>
<li>Ctrl+Alt+N run code</li>
</ul>
<p>配置 <em><strong>launch.json</strong></em> 根据提示，替换gcc路径即可</p>
<pre><code class="language-json">    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;gcc.exe - 生成和调试活动文件&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${fileDirname}\\${fileBasenameNoExtension}.exe&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;miDebuggerPath&quot;: &quot;D:\Program Files\mingw64\bin\gdb.exe&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ],
            &quot;preLaunchTask&quot;: &quot;C/C++: gcc.exe build active file&quot;
        }
    ]
}
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch01 变量和数据类型</title>
      <link>https://www.oomkill.com/2022/09/ch01-parmeter-and-data-structrue/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch01-parmeter-and-data-structrue/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="c语言关键字-sup-idkeywordsa-href11asup">C语言关键字 <sup id="keywords"><a href="#1">[1]</a></sup></h2>
<p>==C语言有32个关键字==</p>
<ul>
<li><em><strong>auto</strong></em>：定义自动变量，主要是声明变量的生存周期</li>
<li><em><strong>break</strong></em>, <em><strong>continue</strong></em> : break 语句在遇到最内层循环时立即终止。还用于终止 switch 语句。</li>
<li><em><strong>case</strong></em>, <em><strong>switch</strong></em>, <em><strong>default</strong></em>：使用 switch 和 case 语句声明一个switch分支</li>
<li><em><strong>char</strong></em>：用于声明character 类型的变量</li>
<li><em><strong>const</strong></em>：声明常量</li>
<li><em><strong>do&hellip;while</strong></em>：</li>
<li><em><strong>double</strong></em>： double-precision 浮点数变量类型</li>
<li><em><strong>float</strong></em>：single-precision 浮点数的变量类型</li>
<li><em><strong>if</strong></em>, <em><strong>else</strong></em>：声明if/else 条件判断</li>
<li><em><strong>enum</strong></em>：用于声明枚举类型</li>
<li><em><strong>extern</strong></em>：关键字声明变量或函数在其声明的文件之外具有外部链接。</li>
<li><em><strong>for</strong></em>：C 语言的三种循环之一，for循环</li>
<li><em><strong>goto</strong></em>： 用于将程序的控制权转移到指定的标签</li>
<li><em><strong>int</strong></em>：声明 integer 类型的变量</li>
<li><em><strong>short</strong></em>, <em><strong>long</strong></em>, <em><strong>signed</strong></em>, <em><strong>unsigned</strong></em>：是类型修饰符，它们改变基本数据类型的含义以产生新类型。
<ul>
<li><em><strong>short int</strong></em>： -32768 to 32767</li>
<li><em><strong>long int</strong></em>：  -2147483648 to 214743648</li>
<li><em><strong>signed int</strong></em>： -32768 to 32767</li>
<li><em><strong>unsigned int</strong></em>： 0 to 65535</li>
</ul>
</li>
<li><em><strong>return</strong></em>： 终止函数并返回值</li>
<li><em><strong>sizeof</strong></em>：评估变量或常量的大小</li>
<li><em><strong>register</strong></em>：创建比普通变量快得多的寄存器变量。</li>
<li><em><strong>static</strong></em>：创建一个静态变量。静态变量的值持续到程序结束。</li>
<li><em><strong>struct</strong></em>：用于声明结构体。结构体可以包含不同类型的变量。</li>
<li><em><strong>typedef</strong></em>：用于将类型与标识符显式关联。</li>
<li><em><strong>union</strong></em>：用于将不同类型的变量分组在一个名称下。</li>
<li><em><strong>void</strong></em>：没有任何意义，函数修饰为没有返回值，参数修饰为没有参数</li>
<li><em><strong>volatile</strong></em>：提醒编译器它后面所定义的变量随时都有可能改变</li>
</ul>
<h2 id="c语言控制语句">C语言控制语句</h2>
<p>==C语言有9种控制语句== (<em><strong>control statements</strong></em>)</p>
<ul>
<li>If..else</li>
<li>for</li>
<li>while</li>
<li>do..while</li>
<li>continue</li>
<li>break</li>
<li>switch</li>
<li>goto</li>
<li>return</li>
</ul>
<h2 id="c语言运算符-supa-href22asup">C语言运算符 <sup><a href="#2">[2]</a></sup></h2>
<p>==C语言有45种运算符== (<em><strong>operator</strong></em>)</p>
<ul>
<li>算数运算符 (<em><strong>Arithmetic Operators</strong></em>) ：<code>+</code>, <code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></li>
<li>赋值运算符 (<em><strong>Assignment Operators</strong></em>) ：<code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code></li>
<li>关系运算符 (<em><strong>Relational Operators</strong></em>)：<code>==</code>，<code>&gt;</code> ，<code>&lt;</code>，<code>!=</code> ，<code>&gt;=</code>，<code>&lt;=</code></li>
<li>逻辑运算符 (<em><strong>Logical Operators</strong></em>)：<code>&amp;&amp;</code>，<code>||</code>，<code>!</code></li>
<li>位运算符 (<em><strong>Bitwise Operators</strong></em>)：<code>&amp;</code>，<code>|</code>，<code>^</code>，<code>~</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code></li>
<li>逗号运算符 (<em><strong>Comma Operator</strong></em>)：链接相关表达式 ，<code>int a, c = 5, d;</code></li>
<li>sizeof运算符(<em><strong>sizeof operator</strong></em>)：一元运算符，它返回数据的大小（常量、变量、数组、结构）</li>
<li>杂项运算符（）：<code>&amp;</code> 取址，<code>*</code> 取指针，<code>?:</code> 二元条件表达式</li>
</ul>
<h2 id="gcc编译四部曲-supa-href33asup">GCC编译四部曲 <sup><a href="#3">[3]</a></sup></h2>
<ul>
<li>预处理 (<em><strong>Preprocessing</strong></em>)：在预处理步骤，将生成一个扩展名为 <code>.i</code> 的文件；使用命令 <code>gcc -E file.c</code> 操作
<ul>
<li>头文件展开，不检查语法错误，将展开所有头（include）文件（任意）</li>
<li>宏定义替换</li>
<li>删除注释</li>
<li>展开条件编译，根据条件来展开指令</li>
</ul>
</li>
<li>编译 (<em><strong>Compilation</strong></em>) ：会生成一个扩展名为 <code>.s</code> 的文件，命令是：<code>gcc -S file.c</code>
<ul>
<li>检查语法错误</li>
<li>将文件翻译成汇编语言</li>
</ul>
</li>
<li>汇编 (<em><strong>Assembler</strong></em>)：将汇编代码转换为纯二进制代码或机器代码（零和一）。此代码也称为目标代码；将生成一个带有 <code>.o</code> 扩展名的文件：<code>gcc -c file.c</code></li>
<li>链接 (<em><strong>Linker</strong></em>)：链接是编译的最后一步。链接器将来自多个模块的所有目标代码合并为一个，如果使用了库也会引用。这个步骤也是包含前三个步骤的。<code>gcc file.o -o hello.exe</code>
<ul>
<li>接收由汇编步骤生成的 .o 扩展名文件</li>
<li>数据地址回填</li>
<li>数据段合并</li>
<li>库引入</li>
</ul>
</li>
</ul>
<h2 id="变量">变量</h2>
<p>变量 (<em><strong>variables</strong></em>) 是用于存储数据的内存位置名称，可以改变的内容</p>
<h3 id="变量的命名规则">变量的命名规则</h3>
<ul>
<li>不能以数字开头</li>
<li>由数字、字母，甚至是下划线 (<code>_</code>) 等特殊符号组成</li>
<li>变量名不能是任何<a href="#keywords">关键字 </a></li>
<li>变量名中不能有空格或空白</li>
<li>变量名是==区分大小写的==</li>
</ul>
<h3 id="变量的数据类型">变量的数据类型</h3>
<p>C 语言中数据类型主要包含以下类型</p>
<table>
<thead>
<tr>
<th><strong>变量类型</strong></th>
<th>实际代表名称</th>
<th><strong>描述</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>Character</td>
<td>代表1bytes(8bit)，是以单引号引起的字符</td>
<td>通常以单个字母的形式使用X、r等，或 ASCII 字符集。</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>自然整数</td>
<td>用来存储整数，如 4, 300, 8000 &hellip;</td>
</tr>
<tr>
<td>float</td>
<td>Floating- Point</td>
<td>单精度浮点数</td>
<td>表示实数值或小数值（7位小数），例如 20.8, 18.56 &hellip;</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>双精度浮点值</td>
<td>比float类型要大 4bytes,允许15位小数</td>
</tr>
<tr>
<td>void</td>
<td>Void</td>
<td>表示没有类型。</td>
<td>这种数据类型是为了用于修饰没有意义函数或变量，如函数用其修饰标识没有返回值，参数用其修饰表示没有参数。</td>
</tr>
</tbody>
</table>
<h3 id="变量声明与定义">变量声明与定义</h3>
<ul>
<li><strong>变量的定义</strong>  (<em>Declaration</em>)：告诉编译器应为变量创建多少存储空间或者在哪里创建存储空间（借助于数据类型）</li>
<li>**变量声明 **(<em>Definition</em>)：只声明不赋值的变量叫做变量定义， <code>int a</code></li>
</ul>
<p>定义与声明的区别：</p>
<ul>
<li>变量定义会开辟内存空间。变量声明不会开辟内存空间</li>
<li>变量要想使用必须有定义</li>
<li>声明指示编译器存在变量，而定义表示编译器为变量创建的存储位置和存储量</li>
</ul>
<h3 id="变量的分类">变量的分类</h3>
<ul>
<li>全局变量 (<em><strong>global</strong></em>) ：在块或函数之外声明的变量称为全局变量</li>
<li>局部变量 (<em><strong>Local</strong></em>)：在块或函数中声明的一种变量</li>
<li>静态变量 (<em><strong>static</strong></em>)：使用 <em>static</em> 关键字声明的变量。该变量在各种函数调用之间保留给定值</li>
<li>自动变量 (<em><strong>auto</strong></em>)：变量具有自动存储期，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失</li>
<li>外部变量 (<em><strong>extren</strong></em>)：能够在多个源文件中共享一个变量 <code> extern int a=10;</code></li>
</ul>
<h3 id="变量的数据大小-sup-iddatatypea-href66asup">变量的数据大小 <sup id="datatype"><a href="#6">[6]</a></sup></h3>
<p>C 编程语言有两种基本数据类型：基本与衍生</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>范围</strong></th>
<th><strong>大小（以字节为单位）</strong></th>
<th>格式化符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned char</td>
<td>0 ~ 255</td>
<td>1</td>
<td>%c</td>
</tr>
<tr>
<td>signed char/char</td>
<td>-128 ~ +127</td>
<td>1</td>
<td>%c</td>
</tr>
<tr>
<td>unsigned int</td>
<td>0 ~ 65535</td>
<td>2</td>
<td>%u</td>
</tr>
<tr>
<td>signed int or int</td>
<td>-32,768 ~ +32767</td>
<td>2</td>
<td>%d</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>0~ 65535</td>
<td>2</td>
<td>%hu</td>
</tr>
<tr>
<td>signed short int/short int</td>
<td>-32,768 ~ +32767</td>
<td>2</td>
<td>%hd</td>
</tr>
<tr>
<td>unsigned long int</td>
<td>0 ~ +4,294,967,295</td>
<td>4</td>
<td>%lu</td>
</tr>
<tr>
<td>signed long int/long int</td>
<td>-2,147,483,648 ~ 2,147,483,647</td>
<td>4</td>
<td>%ld</td>
</tr>
<tr>
<td>long long int</td>
<td>-(2^63) to (2^63)-1</td>
<td>8</td>
<td>%lld</td>
</tr>
<tr>
<td>unsigned long long int</td>
<td>0 to 18,446,744,073,709,551,615</td>
<td>8</td>
<td>%llu</td>
</tr>
<tr>
<td>float  <sup><a href="#5">[5]</a></sup></td>
<td>7位精度</td>
<td>4</td>
<td>%f</td>
</tr>
<tr>
<td>double <sup><a href="#5">[5]</a></sup></td>
<td>15位精度</td>
<td>8</td>
<td>%lf</td>
</tr>
</tbody>
</table>
<h3 id="变量类型">变量类型</h3>
<p>C语言中根据变量的声明周期和范围可以被分为两种类型 局部变量和全局变量与静态变量</p>
<h4 id="局部变量">局部变量</h4>
<p>局部变量 (<em><strong>local variables</strong></em>) 被声明在函数内部，只要函数存在，它们就只存在于内存中，直到函数结束，局部变量就会消失！</p>
<p>例如创建一个局部变量 a，a在函数运行时被创建在stack段中，当函数foo() 结束，被释放，故下列代码编译错误。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void	foo(void)
{
	int	a;

	a = 10;
	printf(&quot;Foo function: Variable a = %d\n&quot;, a);
} // the variable 'a' ceases to exist in RAM here.

int	main(void)
{
	foo();
	printf(&quot;Main: Variable a = %d\n&quot;, a);
	// ERROR : main does not know any variable named 'a'!
	return (0);
}
</code></pre>
<blockquote>
<p>Notes：函数的参数也是局部变量，如果需要外部更改，则通过指针方式传递进去</p>
</blockquote>
<h4 id="全局变量">全局变量</h4>
<p>全局变量  (<em><strong>global variables</strong></em>)  是指在函数外部声明的变量；全局变量随函数生命周期结束时消失，因为全局变量被存储在内存结构的data分段中，是属于二进制文件本身的。另外==默认情况下，未被赋值的全局变量会被初始化为 0==。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int	a; // Global variable initialized to 0 by default

void	foo(void)
{
	a = 42; // Global variable accessible without
		// having been declared in the function
	printf(&quot;Foo: a = %d\n&quot;, a); // a == 42
}

int	main(void)
{
	printf(&quot;Main: a = %d\n&quot;, a); // a == 0
	foo();
	printf(&quot;Main: a = %d\n&quot;, a); // a == 42
	a = 200;
	printf(&quot;Main: a = %d\n&quot;, a); // a == 200
	return (0);
}
</code></pre>
<blockquote>
<p>Notes：局部变量的作用域高于全局变量，如果同名会被覆盖</p>
</blockquote>
<p><strong>全局变量的作用域</strong></p>
<p>如果想在一个文件中使用另一个文件中定义的全局变量，需要使用关键字 ”<em><strong>extern</strong></em>“ 再次声明。这代表告诉编译器正在声明我们在程序文件的其他地方定义的变量。</p>
<p>例如下面代码中，<code>main.c</code> 中，使用 <code>extern</code> 关键字声明全局变量，表示我们在其他地方定义了这个变量。并做了 <code>foo()</code> 函数原型的声明。并在 <code>foo.c</code> 文件中，定义了全局变量 <code>a</code> 及 <code>foo()</code> 函数</p>
<p>main.c</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

extern int	a; // 在其他文件内定义的全局变量

void foo(void);	// 定义在其他方面的函数，这种写法等同于extern void foo(void);

int	main(void)
{
	printf(&quot;Main: a = %d\n&quot;, a); // a == 100
	foo();
	printf(&quot;Main: a = %d\n&quot;, a); // a == 42
	a = 200;
	printf(&quot;Main: a = %d\n&quot;, a); // a == 200
	return (0);
}
</code></pre>
<p>void.c</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int	a = 100; // 全局变量的定义

void foo(void)
{
	a = 42;
	printf(&quot;Foo: a = %d\n&quot;, a); // a == 42
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-c">Main: a = 100
Foo: a = 42
Main: a = 42
Main: a = 200
</code></pre>
<p>也可以使用头文件来定义，这种方式比上面的更好，示例只是说明全局变量</p>
<h4 id="静态变量">静态变量</h4>
<p>静态变量是指使用关键字 “<em><strong>static</strong></em>&quot; 修饰的变量，静态变量可以分为 <strong>静态全局变量</strong> 与 <strong>静态局部变量</strong> ，静态变量默认是全局的，因为他存储的地方是data区而不是堆，栈中。</p>
<p>静态变量有两点区分与全局变量：</p>
<ul>
<li>在函数内部定义的静态变量是这个函数的全局变量（第一个结束的括号）</li>
<li>在函数外声明的静态变量仅在这个声明他的文件内有效。</li>
</ul>
<p>下面代码会编译异常，因为b生命周期存在与for循环中</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void test()
{
    static int a = 10;
    for(int i=0; i&lt;10; i++)
    {
        static int b = 10;
        a++;
        b++;
    }

    printf(&quot;value a is %d\n&quot;,a);
    printf(&quot;value b is %d\n&quot;,b);
}

void main()
{
    test();
}
</code></pre>
<h5 id="局部静态变量">局部静态变量</h5>
<p>局部静态变量不能说是真正的局部变量，因为其存储内存位置与局部变量不同，局部变量存储在堆，栈中，而静态变量存储在data中只是说会被限制在对应的作用域中。</p>
<p>下面代码说明了普通局部变量和静态局部变量的区别，由于存储位置不同，静态局部变量只是被访问限制在作用域中，而不会随函数结束释放掉。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void foo(void)
{
	int	a = 100;
	static int	b = 100;

	printf(&quot;a = %d, b = %d\n&quot;, a, b);
	a++;
	b++;
}

int	main(void)
{
	foo();
	foo();
	foo();
	foo();
	foo();
	return (0);
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-c">a = 100, b = 100
a = 100, b = 101
a = 100, b = 102
a = 100, b = 103
a = 100, b = 104
</code></pre>
<h5 id="全局静态变量">全局静态变量</h5>
<p>全局静态变量是声明在函数外面用static修饰的变量，与全局变量不同的是，静态全局变量访问域被限制在声明它们的文件中，无法从程序的另一个文件中访问它。</p>
<p>在全局变量部分，可以通过关键字 ”<em><strong>extern</strong></em>“ 来访问全局变量，如果此时声明一个静态变量 a ，那么通过跨文件的方式这时编译器会提示 ”undefined reference to ‘a&rsquo;“。通常情况下使用这种场景被用于加速编译。</p>
<h4 id="global-vs-local-vs-static">global VS local VS static</h4>
<ul>
<li>作用域方面不同：局部变量作用域仅在 同一个 <code>{}</code>，而静态变量和全局变量在为整个进程</li>
<li>访问作用域不同：全局变量为进程共享，局部变量为函数运行时，静态全局变量为定义它的文件，静态全局变量为 同一个 <code>{}</code></li>
<li>存储位置不同，局部变量被存储与堆，栈中，而静态变量和全局变量被存储在data中</li>
</ul>
<h2 id="类型转换">类型转换</h2>
<h3 id="隐式类型转换">隐式类型转换</h3>
<p>隐式类型 (<em><strong>Implicit</strong></em>) 转换也称自动类型转换，这种类型的转换包含如下特点：</p>
<ul>
<li>编译器自动完成，无需用户干预触发</li>
<li>当表达式中存在多种类型时触发，这是为了保证数据不被丢失</li>
<li>所有的数据类型都将升级为该类型最大值</li>
<li>转换的顺序为：bool -&gt; char -&gt; short int -&gt; int -&gt; unsigned int -&gt; long -&gt; unsigned -&gt; long long -&gt; float -&gt; double -&gt; long double</li>
<li>该转换类型会存在一些问题，如符号消失，数据丢失等。</li>
</ul>
<pre><code class="language-c">#include&lt;stdio.h&gt;
int main()
{
    int x = 10;    // integer x
    char y = 'a';  // character c
  
    // y 被隐式转换为 char类型，a=97
    x = x + y;
     
    // 计算中，存在浮点数值，结果将被转换为float
    float z = x + 1.0;

    
    // 自动转换为long long
    int h = 2147483648;
    // int 到 short int值溢出将为23352减去int大小65536
    short int g = 88888 + x;
    printf(&quot;x = %d, z = %f\n&quot;, x, z);
    printf(&quot;g = %li, h = %lli\n&quot;, g, h);
    return 0;
}
</code></pre>
<h3 id="显式类型转换">显式类型转换</h3>
<p>用户定义类型转换的过程称为显式类型转换 (<em><strong>Explicit</strong></em>)</p>
<pre><code class="language-c">(type) expression
</code></pre>
<p>显示转换示例</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
  
int main()
{
    float x = 1.2;
    // 显示转换一个float为int
    int sum = (int) x + 1;
  
    printf(&quot;sum = %d&quot;, sum);
  
    return 0;
}
</code></pre>
<h2 id="进制转换">进制转换</h2>
<h3 id="十进制">十进制</h3>
<p>十进制转二进制： 除2反向取余法</p>
<p>十进制转八进制：除8反向取余法</p>
<p>十进制转十六进制：除16反向取余法</p>
<p>例如：16进制转10进制</p>
<ul>
<li>将十进制数除以 16。将除法视为整数除法</li>
<li>写下余数（十六进制）</li>
<li>将结果再次除以 16。将除法视为整数除法</li>
<li>重复步骤 2 和 3，直到结果为 0</li>
<li>求出的十六进制值是从最后到第一个的余数的数字序列</li>
</ul>
<p>427的16进制</p>
<ul>
<li>
<p>将数字除以 16，余数（小数部分乘16为余数），最终为1AB</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/decimal-to-hexadecimal.png" alt="Decimal To Hexadecimal Conversion" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
</li>
</ul>
<h3 id="八进制">八进制</h3>
<p>8进制转10进制：从后向前，8的0次方，8的1次方，8的2次方&hellip;按照该顺序乘8的</p>
<ul>
<li>8进制75转10进制为：$56+5=61$</li>
<li>8进制77655转10进制为：$7(8^4)+7(8^3)+6(8^2)+5(8^1)+5(8^0)=28672+3584+384+40+5=32685$</li>
</ul>
<p>2进制转8进制：自右向左，每3位一组，按421码转换。高位不足三位补0</p>
<ul>
<li>
<p>1 010 111 010 110 二进制转八进制如下表，最后算出结果为12726</p>
</li>
<li>
<table>
<thead>
<tr>
<th>4</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="十六进制">十六进制</h3>
<p><strong>16进制转10进制</strong>：从后向前依次展开，16的0次方，16的1次方，16的2次方&hellip;，每位相加，例如：</p>
<ul>
<li>0x1A = $16 + 10 = 26$</li>
<li>15DE = $1(16^3)+5(16^2)+13(16^1)+14= 4096+1280+208+14=5598$</li>
</ul>
<p><strong>16进制转二进制</strong>：4位一组一次填充。例如 0X1A的二进制，即00011010如下</p>
<table>
<thead>
<tr>
<th>8</th>
<th>4</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><strong>二进制转16进制</strong>：自右向左，每4位一组，按8421码转换。高位不足三位补0</p>
<p>例如 0001 0011 1111的16进制为，如下表 1 3 F(15)</p>
<table>
<thead>
<tr>
<th>8</th>
<th>4</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<h2 id="源码反码补码">源码反码补码</h2>
<p>源码 (*** true form****),  反码 (<em><strong>1‘s complement</strong></em>) <sup><a href="#7">[7]</a></sup>, 补码 (<em><strong>2‘s complement</strong></em>) <sup><a href="#8">[8] </a></sup>是操作系统中存储和计算数据的一种方式</p>
<p>任何数据都以二进制机器码存储与计算机中。对于的机器码，第一位是用来表示正负值的：0是正数，1是负数。故要表示 <em><strong>-2</strong></em>，对应的机器码是 <em><strong>10000010</strong></em>。</p>
<p>机器码不可以直接通过权重展开计算，例如 <em><strong>10000010</strong></em> 为 $1(2^7) + 1(2^1) = 130$ 。因为第一位是1，所以是负数，接下来计算后一位的权重展开为 $-2$</p>
<ul>
<li>
<p>原码：机器码表示的值成为源码：如 43  = 00101011，-43 = 10101011</p>
</li>
<li>
<p>反码：符号位不变，其余位取反：如 43  = 00101011，-43 = 11010100</p>
</li>
<li>
<p>补码：符号位不变，counter code then LSB (<em><strong>least significant bit</strong></em>) + 1：如 43  = 00101011，-43 = 11010101</p>
<ul>
<li>
<table>
<thead>
<tr>
<th>128</th>
<th>64</th>
<th>32</th>
<th>16</th>
<th>8</th>
<th>4</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0+1(如果需要进位则进一位)</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note：二进制 10000000 为 -128</p>
</blockquote>
<p>反码, 补码 是为了计算和存储正负数诞生的，正如 <a href="#datatype">C语言的数据结构</a> 中 有符号和没符号表示的数值位置不一样。</p>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.programiz.com/c-programming/list-all-keywords-c-language" target="_blank"
   rel="noopener nofollow noreferrer" >keywords c language</a></p>
<p><sup id="2">[2]</sup> <a href="https://www.tutorialspoint.com/cprogramming/c_operators.htm" target="_blank"
   rel="noopener nofollow noreferrer" >Arithmetic Operators</a></p>
<p><sup id="3">[3]</sup> <a href="https://medium.com/@danielavasquez_77768/the-four-stages-of-compilation-c-programming-and-gcc-compiler-9faadf2e273a" target="_blank"
   rel="noopener nofollow noreferrer" >four stages of compilation c</a></p>
<p><sup id="4">[4]</sup> <a href="https://docs.microsoft.com/en-us/visualstudio/install/create-an-offline-installation-of-visual-studio?view=vs-2022" target="_blank"
   rel="noopener nofollow noreferrer" >offline installation visual studio</a></p>
<p><sup id="5">[5]</sup> <a href="https://www.geeksforgeeks.org/difference-float-double-c-cpp/" target="_blank"
   rel="noopener nofollow noreferrer" >difference float double</a></p>
<p><sup id="6">[6]</sup> <a href="https://www.geeksforgeeks.org/data-types-in-c" target="_blank"
   rel="noopener nofollow noreferrer" >data type in c</a></p>
<p><sup id="7">[7]</sup> <a href="https://www.tutorialspoint.com/one-s-complement" target="_blank"
   rel="noopener nofollow noreferrer" >1‘s complement</a></p>
<p><sup id="8">[8]</sup> <a href="https://www.tutorialspoint.com/two-s-complement" target="_blank"
   rel="noopener nofollow noreferrer" >2‘s complement</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch02 格式化与流程控制</title>
      <link>https://www.oomkill.com/2022/09/ch02-control-statements-and-format/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch02-control-statements-and-format/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="格式化">格式化</h2>
<h3 id="printf">printf</h3>
<p>printf() 用于打印消息以及变量的值。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
int main() {
   int a = 24;
   printf(&quot;Welcome! \n&quot;);
   printf(&quot;The value of a : %d&quot;,a);
   getchar();
   return 0;
}
</code></pre>
<h3 id="sprintf">sprintf</h3>
<p>sprintf() 不打印字符串，是将字符值和格式化结构一并存储在一个数组中。</p>
<pre><code class="language-c">int main()
{
    char buffer[50];
    int a = 10, b = 20, c;
    c = a + b;
    sprintf(buffer, &quot;Sum of %d and %d is %d&quot;, a, b, c);
 
    // The string &quot;sum of 10 and 20 is 30&quot; is stored
    // into buffer instead of printing on stdout
    printf(&quot;%s&quot;, buffer);
 
    return 0;
}
</code></pre>
<h3 id="scanf">scanf</h3>
<p>从标准输入读取用户输入的</p>
<table>
<thead>
<tr>
<th>type</th>
<th style="text-align:center">Argument &amp; Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>*****</td>
<td style="text-align:center">读取标准输入用户输入的值，但不存储在对应接受的变量中</td>
</tr>
<tr>
<td>width</td>
<td style="text-align:center">这个操作中读取的最大字符</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">指定要读取的数据类型以及预期如何读取数据</td>
</tr>
</tbody>
</table>
<p>修饰符类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">标识符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left"><code>%d</code></td>
</tr>
<tr>
<td style="text-align:left"><code>char</code></td>
<td style="text-align:left"><code>%c</code></td>
</tr>
<tr>
<td style="text-align:left"><code>float</code></td>
<td style="text-align:left"><code>%f</code></td>
</tr>
<tr>
<td style="text-align:left"><code>double</code></td>
<td style="text-align:left"><code>%lf</code></td>
</tr>
<tr>
<td style="text-align:left"><code>short int</code></td>
<td style="text-align:left"><code>%hd</code></td>
</tr>
<tr>
<td style="text-align:left"><code>unsigned int</code></td>
<td style="text-align:left"><code>%u</code></td>
</tr>
<tr>
<td style="text-align:left"><code>long int</code></td>
<td style="text-align:left"><code>%li</code></td>
</tr>
<tr>
<td style="text-align:left"><code>long long int</code></td>
<td style="text-align:left"><code>%lli</code></td>
</tr>
<tr>
<td style="text-align:left"><code>unsigned long int</code></td>
<td style="text-align:left"><code>%lu</code></td>
</tr>
<tr>
<td style="text-align:left"><code>unsigned long long int</code></td>
<td style="text-align:left"><code>%llu</code></td>
</tr>
<tr>
<td style="text-align:left"><code>signed char</code></td>
<td style="text-align:left"><code>%c</code></td>
</tr>
<tr>
<td style="text-align:left"><code>unsigned char</code></td>
<td style="text-align:left"><code>%c</code></td>
</tr>
<tr>
<td style="text-align:left"><code>long double</code></td>
<td style="text-align:left"><code>%Lf</code></td>
</tr>
</tbody>
</table>
<p>格式化</p>
<table>
<thead>
<tr>
<th style="text-align:center">Description</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">接受字符类型保存在数组中</td>
<td style="text-align:center">scanf(&quot;%19c&quot;, &amp;a);</td>
<td style="text-align:center">&lsquo;1234567890abcfefg&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">整型类型</td>
<td style="text-align:center">scanf(&quot;%d&quot;, &amp;testInteger);</td>
<td style="text-align:center">&lsquo;10&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">多个接收值</td>
<td style="text-align:center">scanf(&quot;%d%f&quot;, &amp;a, &amp;b);</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>scanf的缺点</p>
<ul>
<li>如果存储空间不足，数据能存储到内存中，但不被保护。</li>
<li>scanf 函数接收字符串时， 碰到 空格 和 换行 会自动终止。不能使用 scanf 的 %s 接收带有空格的字符串。</li>
</ul>
<h3 id="格式化标记符-sup-a-href11asup">格式化标记符 <sup ><a href="#1">[1]</a></sup></h3>
<h4 id="标记符">标记符</h4>
<table>
<thead>
<tr>
<th>标记符</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>%i / %d</td>
<td>int</td>
</tr>
<tr>
<td>%c</td>
<td>char</td>
</tr>
<tr>
<td>%f</td>
<td>float</td>
</tr>
<tr>
<td>%s</td>
<td>string</td>
</tr>
<tr>
<td>%u</td>
<td>unsigned decimal</td>
</tr>
<tr>
<td>%o</td>
<td>octal</td>
</tr>
<tr>
<td>%x</td>
<td>hexadecimal</td>
</tr>
</tbody>
</table>
<h4 id="对字符串填充">对字符串填充</h4>
<p>在 % 符号后添加一个零 (0)，可以对 printf 整数输出进行零填充</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>printf(&quot;%03d&quot;, 0);</td>
<td>000</td>
</tr>
<tr>
<td>printf(&quot;%03d&quot;, 1);</td>
<td>001</td>
</tr>
<tr>
<td>printf(&quot;%03d&quot;, 123456789);</td>
<td>123456789</td>
</tr>
<tr>
<td>printf(&quot;%03d&quot;, -10);</td>
<td>-10</td>
</tr>
<tr>
<td>printf(&quot;%03d&quot;, -123456789);</td>
<td>-123456789</td>
</tr>
</tbody>
</table>
<p>对于此类格式化方式总结有如下几种模式</p>
<table>
<thead>
<tr>
<th style="text-align:center">Description</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">填充5位（默认以空白填充，左对齐填充）</td>
<td style="text-align:center">printf(&quot;&rsquo;%5d&rsquo;&quot;, 10);</td>
<td style="text-align:center">&rsquo;     10'</td>
</tr>
<tr>
<td style="text-align:center">填充5位（右对齐填充）</td>
<td style="text-align:center">printf(&quot;&rsquo;%-5d&rsquo;&quot;, 10);</td>
<td style="text-align:center">&lsquo;10     '</td>
</tr>
<tr>
<td style="text-align:center">填充5位“0”（默认左对齐填充）</td>
<td style="text-align:center">printf(&quot;&rsquo;%05d&rsquo;&quot;, 10);</td>
<td style="text-align:center">&lsquo;00010&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">有符号的表示的数字（默认左对齐填充）</td>
<td style="text-align:center">printf(&quot;&rsquo;%+5d&rsquo;&quot;, 10);</td>
<td style="text-align:center">&rsquo;      +10&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">有符号的表示的数字，右对齐填充空白</td>
<td style="text-align:center">printf(&quot;&rsquo;%-+5d&rsquo;&quot;, 10);</td>
<td style="text-align:center">&lsquo;+10    '</td>
</tr>
</tbody>
</table>
<h4 id="浮点数格式化">浮点数格式化</h4>
<table>
<thead>
<tr>
<th style="text-align:center">Description</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">保留1位小数</td>
<td style="text-align:center">printf(&quot;&rsquo;%.1f&rsquo;&quot;, 10.3456);</td>
<td style="text-align:center">&lsquo;10.3&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">保留2位小数</td>
<td style="text-align:center">printf(&quot;&rsquo;%.2f&rsquo;&quot;, 10.3456);</td>
<td style="text-align:center">&lsquo;10.35&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">整数位最少8位宽度，小数位2位</td>
<td style="text-align:center">printf(&quot;&rsquo;%8.2f&rsquo;&quot;, 10.3456);</td>
<td style="text-align:center">&rsquo;  10.35&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">整数位最少8位宽度，小数位4位</td>
<td style="text-align:center">printf(&quot;&rsquo;%8.4f&rsquo;&quot;, 10.3456);</td>
<td style="text-align:center">&rsquo; 10.3456'</td>
</tr>
<tr>
<td style="text-align:center">整数位最少8位，小数位2位，不足8位将用0填充（默认左对齐填充）</td>
<td style="text-align:center">printf(&quot;&rsquo;%08.2f&rsquo;&quot;, 10.3456);</td>
<td style="text-align:center">&lsquo;00010.35&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">整数位最少8位，小数位2位，不足8位将用空白右对齐填充</td>
<td style="text-align:center">printf(&quot;&rsquo;%-8.2f&rsquo;&quot;, 10.3456);</td>
<td style="text-align:center">&lsquo;10.35  '</td>
</tr>
<tr>
<td style="text-align:center">打印更大的浮点数，小数位2位</td>
<td style="text-align:center">printf(&quot;&rsquo;%-8.2f&rsquo;&quot;, 101234567.3456);</td>
<td style="text-align:center">&lsquo;101234567.35&rsquo;</td>
</tr>
</tbody>
</table>
<h4 id="字符串格式化">字符串格式化</h4>
<table>
<thead>
<tr>
<th style="text-align:center">Description</th>
<th style="text-align:center">Code</th>
<th style="text-align:center">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串输出</td>
<td style="text-align:center">printf(&quot;&rsquo;%s&rsquo;&quot;, &ldquo;Hello&rdquo;);</td>
<td style="text-align:center">&lsquo;Hello&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">保证输出结果是10位，不足位用空白填充（默认左对齐填充）</td>
<td style="text-align:center">printf(&quot;&rsquo;%10s&rsquo;&quot;, &ldquo;Hello&rdquo;);</td>
<td style="text-align:center">&rsquo;   Hello&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">保证输出结果是10位，不足位用空白右对齐填充</td>
<td style="text-align:center">printf(&quot;&rsquo;%-10s&rsquo;&quot;, &ldquo;Hello&rdquo;);</td>
<td style="text-align:center">&lsquo;Hello   '</td>
</tr>
</tbody>
</table>
<h3 id="特殊字符">特殊字符</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>audible alert</td>
</tr>
<tr>
<td>\b</td>
<td>backspace（退格）</td>
</tr>
<tr>
<td>\f</td>
<td>form feed （换页）</td>
</tr>
<tr>
<td>\n</td>
<td>newline（换行）</td>
</tr>
<tr>
<td>\r</td>
<td>carriage return（回车）</td>
</tr>
<tr>
<td>\t</td>
<td>tab</td>
</tr>
<tr>
<td>\v</td>
<td>vertical tab（垂直制表符）</td>
</tr>
<tr>
<td>\</td>
<td>backslash （反斜杠）</td>
</tr>
</tbody>
</table>
<h2 id="运算符">运算符</h2>
<p>C语言中运算符优先级为下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">关联性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left"><code>++</code> <code>--</code></td>
<td style="text-align:left">前缀/后缀 自增/减</td>
<td style="text-align:left">从左向右</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>()</code></td>
<td style="text-align:left">函数调用</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>[]</code></td>
<td style="text-align:left">数组下标 (subscripting)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">结构体成员访问</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>-&gt;</code></td>
<td style="text-align:left">指针结构体成员访问</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left"><code>++</code> <code>--</code></td>
<td style="text-align:left">前缀/后缀 自增/减</td>
<td style="text-align:left">从右向左</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>+</code> <code>-</code></td>
<td style="text-align:left">(Unary) 一元 +/-（正负号）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>!</code> <code>~</code></td>
<td style="text-align:left">逻辑非与按位非</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>(type)</code></td>
<td style="text-align:left">转换</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">取消引用</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">地址符</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>sizeof</code></td>
<td style="text-align:left">Size-of</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left"><code>*</code> <code>/</code> <code>%</code></td>
<td style="text-align:left">Multiplication, division, remainder</td>
<td style="text-align:left">从左向右</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left"><code>+</code> <code>-</code></td>
<td style="text-align:left">Addition and subtraction</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left"><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td style="text-align:left">Bitwise left shift and right shift</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left"><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>==</code> <code>!=</code></td>
<td style="text-align:left">关系运算符 &lt; , ≤ , &gt; , ≥ ,= ,  ≠</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">按位与</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">按位异或</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:left">`</td>
<td style="text-align:left">`</td>
<td style="text-align:left">按位异或</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:left"><code>&amp;&amp;</code></td>
<td style="text-align:left">逻辑与</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:left">`</td>
<td style="text-align:left"></td>
<td style="text-align:left">`</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:left"><code>?:</code></td>
<td style="text-align:left">三元运算(Ternary conditional)</td>
<td style="text-align:left">从右向左</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left">赋值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>+=</code> <code>-=</code></td>
<td style="text-align:left">按和差赋值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>*=</code> <code>/=</code> <code>%=</code></td>
<td style="text-align:left">按乘积，商，余赋值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td>
<td style="text-align:left">按左，右位移赋值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>&amp;=</code> <code>^=</code> `</td>
<td style="text-align:left">=`</td>
<td style="text-align:left">按位 与或非赋值</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:left"><code>,</code></td>
<td style="text-align:left">逗号</td>
<td style="text-align:left">从左向右</td>
</tr>
</tbody>
</table>
<h2 id="流程控制-supa-href22asup">流程控制 <sup><a href="#2">[2]</a></sup></h2>
<p>C语言中提供了两种流程控制(<em><strong>flow control</strong></em>)</p>
<ul>
<li>Branching</li>
<li>Looping</li>
</ul>
<h3 id="branching">Branching</h3>
<p>分支 (<em><strong>Branching</strong></em>) 将决定采取什么动作，循环将决定采取某种行动的次数。</p>
<h4 id="if">if</h4>
<p>形态1：</p>
<pre><code class="language-c">if (expression)
  statement;

if (expression)
{
    Block of statements;
}
</code></pre>
<p>形态2:</p>
<pre><code class="language-c">if (expression)
{
    Block of statements;
}
else
{
    Block of statements;
}
</code></pre>
<p>形态3：</p>
<pre><code class="language-c">if (expression)
{
    Block of statements;
}
else if(expression)
{
    Block of statements;
}
else
{
    Block of statements;
}
</code></pre>
<h3 id="三元运算">三元运算</h3>
<p><code>&lt;value1&gt; ? &lt;value2&gt; : &lt;value3&gt;</code> 是三元运算符，因为它需要三个值，这是 C 中唯一的三元运算符。语法</p>
<pre><code class="language-c">if condition is true ? then X return value : otherwise Y value;
</code></pre>
<h3 id="switch">switch</h3>
<pre><code class="language-c">switch( expression )
{
    case constant-expression1:	statements1;
    [case constant-expression2:	statements2;]    
    [case constant-expression3:	statements3;]
    [default : statements4;]
}
</code></pre>
<p><em><strong>break</strong></em> 关键字用作退出 switch 语句。在 switch case 中满足条件，则执行继续到下一个 case 子句，如果没有明确指定执行应该退出 switch 语句。</p>
<p><em><strong>default</strong></em> 关键字用于在所有case中都不满足条件，则执行default</p>
<p>case穿透：case分支中如果,没有 <em><strong>break</strong></em>；那么它会向下继续执行下一个case分支.</p>
<h3 id="if-vs-switch">if VS switch</h3>
<ul>
<li><strong>检查表达式</strong>：if-else 可以基于值或条件检查表达式，而 switch 语句仅基于字符表达式或整数类型检查表达式。</li>
<li><strong>运行速度</strong>：在大量条件检查中进行选择，switch 语句的运行速度将比使用 if-else 的逻辑快得多。</li>
<li><strong>适合条件不同</strong>：if-else 适合导致布尔值的可变条件，而 switch 适合固定值。</li>
<li><strong>可读性</strong>：if-else较switch-case语句可读性较差</li>
</ul>
<h3 id="looping">Looping</h3>
<p>循环 (<em><strong>Looping</strong></em>) 提供了一种重复命令和控制重复次数的方法。</p>
<h3 id="while">while</h3>
<p>while 是 c 语言中最基础的循环，while将检查expression，直到expression为false将推出循环</p>
<pre><code class="language-c">while ( expression )
{
   Single statement 
   or
   Block of statements;
}
</code></pre>
<h3 id="for">for</h3>
<p>for是类似与while的循环，只是语法上不同，for提供了三个表达式</p>
<pre><code class="language-c">for( expression1; expression2; expression3)
{
   Single statement
   or
   Block of statements;
}
</code></pre>
<ul>
<li>expression1 - 通常用于初始化变量（在此初始化的变量作用域仅为该循环中）</li>
<li>expression2 - 条件表达式，只要该表达式为true则循环将一直被执行</li>
<li>expression3 -  修饰符，通常用于变量的自增自减操作</li>
<li>三个表达式都可以为空，这种场景下循环将一直进行</li>
</ul>
<h3 id="dowhile">do&hellip;while</h3>
<p>类似与while ，只不过do..while循环，在循环结束开始检查测试条件。这意味着循环的内容将==至少执行一次==。</p>
<pre><code class="language-c">do
{
   Single statement
   or
   Block of statements;
}
while(expression);
</code></pre>
<h3 id="break-vs-continue">break VS continue</h3>
<p>C语言提供了两个命令来控制循环：</p>
<ul>
<li>break，退出循环或switch</li>
<li>continue，跳过当前迭代 (<em><strong>iteration</strong></em>)，继续循环</li>
</ul>
<pre><code class="language-c">#include 
main()
{
    int i;
    int j = 10;

    for( i = 0; i &lt;= j; i ++ )
    {
       if( i == 5 )
       {
          continue;
       }
       printf(&quot;Hello %d\n&quot;, i );
    }
}
</code></pre>
<p>输出结果将没有第五次迭代</p>
<pre><code class="language-bash">Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
Hello 6
Hello 7
Hello 8
Hello 9
Hello 10
</code></pre>
<h2 id="goto">goto</h2>
<p>goto 声明在C语言中提供了了一个无条件跳转到goto label出的</p>
<pre><code class="language-c">goto label;
..
.
label: statement;
</code></pre>
<p>下面例子中，将从10开始执行，跳过15继续从16开始到20结束。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
 
int main () {

   /* 局部变量定义 */
   int a = 10;

   /* do循环体 */
   LOOP:do {
   
      if( a == 15) {
         /* 跳出迭代 */
         a = a + 1;
         goto LOOP;
      }
		
      printf(&quot;value of a: %d\n&quot;, a);
      a++;

   }while( a &lt; 20 );
   return 0;
}
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://alvinalexander.com/programming/printf-format-cheat-sheet/" target="_blank"
   rel="noopener nofollow noreferrer" >printf format</a></p>
<p><sup id="2">[2]</sup> <a href="https://www.tutorialspoint.com/ansi_c/c_control_statements.htm" target="_blank"
   rel="noopener nofollow noreferrer" >control_statements</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch03 数组</title>
      <link>https://www.oomkill.com/2022/09/ch03-array/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch03-array/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="array-supa-href11asup">Array <sup><a href="#1">[1]</a></sup></h2>
<ul>
<li>数组是由单个元素组成的一组数据类型的变量</li>
<li>数组的元素存储在连续的内存位置</li>
<li>声明数组时应提及数组的大小</li>
<li>数组的计数从0开始</li>
<li>数组为一位数组与多维数组</li>
<li>数组首元素的地址与数组地址相同</li>
<li>数组包含  int, float, char, double 数据类型</li>
</ul>
<h3 id="declaration-and-initialization">Declaration and Initialization</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int my_array1[20];</td>
<td>指定大小，来声明一个有20个元素的int数组</td>
</tr>
<tr>
<td>char my_array2[5];</td>
<td>指定大小，来声明一个有5个元素的char数组</td>
</tr>
<tr>
<td>int my_array[] = {100, 200, 300, 400, 500}</td>
<td>声明时初始化一个数组（编译器自动求数组元素个数）</td>
</tr>
<tr>
<td>int my_array1[5] = {100, 200, 300, 400, 500};</td>
<td>声明时初始化</td>
</tr>
<tr>
<td>int my_array2[5] = {100, 200, 300};</td>
<td>声明时初始化（剩余未初始化的元素，默认 0 值）</td>
</tr>
<tr>
<td>int my_array2[5] = {0};</td>
<td>声明时初始化（声明一个全0值的数组）</td>
</tr>
<tr>
<td>int arr[10]; <br/>arr[0] = 5;<br/>arr[1] = 6;<br/>arr[2] = 7;</td>
<td>声明数组并初始化值（这种方法为初始化部分的默认值为随机数）</td>
</tr>
<tr>
<td>char str[] = &ldquo;zhangsan&rdquo;</td>
<td>声明一个字符串（字符串是一个char类型数组）</td>
</tr>
</tbody>
</table>
<h3 id="advantages-and-disadvantages">Advantages and Disadvantages</h3>
<p>缺点**：大小限制**：声明（定义）后是固定的大小，不能通过运行时改变其大小</p>
<p>优点：</p>
<ul>
<li>代码优化，可以通过数组更好的对数据进行检索或排序</li>
<li>随机存储，可以将数据存储在不同的位置</li>
</ul>
<h3 id="muitl-dimensional-supa-href55asup">muitl-dimensional <sup><a href="#5">[5]</a></sup></h3>
<p>数组中的数组，又称为多维数组(*** multidimensional arrays***)。包含 2D 3D数组。2D是包含行(<em><strong>rows</strong></em>), 列(<em><strong>columns</strong></em>) 的数组；而3D数组是在2D的基础上，增加了一个维度。包含如下：</p>
<ul>
<li>第一个维度：大小</li>
<li>第二个维度：二维数组的行</li>
<li>第三个维度：二维数组的列</li>
</ul>
<p>而更高维度的数组，实际上就是在3D, 4D&hellip; 上再增加一个维度。</p>
<h4 id="declare">declare</h4>
<p>声明一个多维数组方式如下，声明一个二维数组</p>
<pre><code class="language-c">float x[3][4];
</code></pre>
<h4 id="initialization">Initialization</h4>
<table>
<thead>
<tr>
<th>初始化方式</th>
<th>说明</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>常规初始化</td>
<td></td>
<td>int arr[3][5] = {<br/>    {2, 3, 54, 56, 7 },<br/>    {2, 67, 4, 35, 9},<br/>    {1, 4, 16, 3, 78}<br/>};</td>
</tr>
<tr>
<td>不完全初始化</td>
<td>未被初始化的数值为 <strong>0</strong></td>
<td>int arr[3][5] = { <br/>    {2, 3}, <br/>    {2, 67, 4, }, <br/>    {1, 4, 16, 78}<br/>};</td>
</tr>
<tr>
<td></td>
<td>初始化一个 初值全为0的二维数组</td>
<td>int arr[3][5] = {0};</td>
</tr>
<tr>
<td></td>
<td>系统自动分配行列</td>
<td>int arr[3][5] = {2, 3, 2, 67, 4, 1, 4, 16, 78};</td>
</tr>
<tr>
<td>不完全指定行列初始化</td>
<td>二维数组定义必须指定列值</td>
<td>int arr[][] = {1, 3, 4, 6, 7};（==错误示例==）</td>
</tr>
<tr>
<td></td>
<td>二维数组定义可以不指定行值</td>
<td>int arr[][2] = { 1, 3, 4, 6, 7 };</td>
</tr>
</tbody>
</table>
<p>示例：遍历一个二维数组</p>
<pre><code class="language-c">#include &lt;math.h&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    int row,colume;
	int arr[][2] = {1, 3, 4, 6, 7, 10};
    row = sizeof(arr)/ sizeof(arr[0]);
    colume =  sizeof(arr[0])/ sizeof(arr[0][0]);
    
    for(int i=0;i&lt;row;i++)
    {
        for(int j=0;j&lt;colume;j++)
        {
            printf(&quot;%d &quot;, arr[i][j]);
        } 
        printf(&quot;\n&quot;);
    }
}
</code></pre>
<p>声明和便利一个三维数组</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main()
{
    int i, j, k;
    int arr[3][3][3]= {
        {
            {11, 12, 13},
            {14, 15, 16},
            {17, 18, 19}
        },
        {
            {21, 22, 23},
            {24, 25, 26},
            {27, 28, 29}
        },
        {
            {31, 32, 33},
            {34, 35, 36},
            {37, 38, 39}
        },
	};
    printf(&quot;:::3D Array Elements:::\n&quot;);
    for(i=0;i&lt;3;i++)
    {
        for(j=0;j&lt;3;j++)
        {
            for(k=0;k&lt;3;k++)
            {
            printf(&quot;%d\t&quot;,arr[i][j][k]);
            }
            printf(&quot;\n&quot;);
        }
        printf(&quot;\n&quot;);
    }
}
</code></pre>
<h2 id="string-supa-href33asup">String <sup><a href="#3">[3]</a></sup></h2>
<p>字符串 (<em><strong>string</strong></em>) 是一组字符 (<em><strong>char</strong></em>)，以 ”\0“ 结尾，抽象来说，C语言中字符串就是数组类型的char</p>
<p>定义，定义一个值为”colour“的字符串。</p>
<pre><code class="language-c">char message[6] = {'C', 'o', 'l', 'o', 'u', 'r', '\0'};
</code></pre>
<p>而 &ldquo;\0&rdquo; 可以省略，定义可以如下</p>
<pre><code class="language-c">char message[]= “Colour”; 
</code></pre>
<p><strong>C语言初始化字符串的4中方法</strong></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>char str[] = &ldquo;hello world&rdquo;;</td>
<td>分配不带大小的字符串</td>
</tr>
<tr>
<td>char str[50] = &ldquo;hello world&rdquo;;</td>
<td>分配具有预定义大小的字符串</td>
</tr>
<tr>
<td>char str[14] = { &lsquo;h&rsquo;,&rsquo;e&rsquo;,&rsquo;l&rsquo;,&rsquo;l&rsquo;,&lsquo;o&rsquo;,&rsquo;\0&rsquo;};</td>
<td>按字符分配大小的字符串</td>
</tr>
<tr>
<td>char str[] = { &lsquo;h&rsquo;,&rsquo;e&rsquo;,&rsquo;l&rsquo;,&rsquo;l&rsquo;,&lsquo;o&rsquo;,&rsquo;\0&rsquo;};</td>
<td>不带大小的按字符分配大小的字符串</td>
</tr>
</tbody>
</table>
<p>在C语言中，数组和字符串都是二等公民，一旦声明后，不支持赋值运算符</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
int main()
{
    char message[6] = {'C', 'o', 'l', 'o', 'u', 'r'};
    message = &quot;aaaaaa&quot;;
    printf(&quot;sum = %c\n&quot;, message);
  
    return 0;
}
</code></pre>
<p>上面代码对字符串二次赋值，这种编译器直接报错</p>
<pre><code class="language-bash">1.c: In function 'main':
1.c:6:13: error: assignment to expression with array type
     message = &quot;aaaaaa&quot;;
</code></pre>
<blockquote>
<p>Notes：复制字符串可以使用函数 strcpy()</p>
</blockquote>
<h4 id="字符串获取">字符串获取</h4>
<ul>
<li>
<p><strong>scanf</strong>：</p>
<ul>
<li>
<p>存储字符串的空间必须足够大，防止溢出。</p>
</li>
<li>
<p>获取字符串，<code>%s</code>， 遇到 空格 和 <em><strong>\n</strong></em> 终止。</p>
</li>
<li>
<p>使用“正则表达式”可以获取带有空格的字符串，如：<code>scanf(&quot;%[^\n]&quot;, str);</code></p>
</li>
</ul>
</li>
<li>
<p><strong>gets</strong>：类似与 <em><strong>scanf</strong></em> ；从stdin中读取字符串保存在变量中，遇到换行符终止（可以获取带有“空格”的字符串）。</p>
<ul>
<li>参数：用来存储字符串的空间地址</li>
<li>返回值：返回实际获取到的字符串首地址。</li>
</ul>
</li>
<li>
<p><strong>fgets</strong>：从指定流读取一行字符串，遇到换行符或到达结尾终止</p>
<ul>
<li>*str：存储读取字符串的变量指针。</li>
<li>n：读取的最大字符</li>
<li>*stream：输入流的对象指针，如stdin</li>
</ul>
</li>
</ul>
<h4 id="字符串写入">字符串写入</h4>
<ul>
<li>
<p><strong>puts</strong>：将一行字符串写入输出流 (<em><strong>stdout</strong></em>)， 输出字符串后会自动添加 \n 换行符。</p>
</li>
<li>
<p><code>char* str</code>：被打印的字符串</p>
</li>
<li>
<p><em><strong>return value</strong></em>：成功返回非0的integer，失败返回  <code>EOF</code></p>
</li>
<li>
<p><strong>fputs</strong>：将字符串写入指定流，不包含换行符 <code>\n</code></p>
<ul>
<li><code>const char *str</code>：写入的以NULL字符结尾的字符串</li>
<li><code>FILE *stream</code>： FILE 对象的指针，代表要将字符串写入的流</li>
<li><em><strong>return value</strong></em>：成功返回非0的integer，失败返回  <code>EOF</code></li>
</ul>
</li>
</ul>
<h3 id="array-vs-string-supa-href22asup">Array VS String <sup><a href="#2">[2]</a></sup></h3>
<ul>
<li><strong>数据类型不同</strong>：数组可以保存 int, float, doubles类型，字符串只能保存char类型</li>
<li><strong>长度不同</strong>：数组长度是固定的，字符串长度可变（通过指针）</li>
<li><strong>数据结构不同</strong>：数组可以是一维或多维，字符串是一维数组，结束是一个空字符 ”\0&quot;</li>
</ul>
<h3 id="char--vs-char-">char * VS char []</h3>
<table>
<thead>
<tr>
<th>char a[10]</th>
<th>char *a</th>
</tr>
</thead>
<tbody>
<tr>
<td>a是一个数组</td>
<td>a是一个指针</td>
</tr>
<tr>
<td>sizeof为数组的大小</td>
<td>sizeof为指针类型的大小</td>
</tr>
<tr>
<td>存储在内存中的栈段</td>
<td>a的地址被存储在栈中，但是内容被存储在.rodata中</td>
</tr>
<tr>
<td>a不可以被修改</td>
<td>a可以被修改</td>
</tr>
<tr>
<td>a[0]可以被修改</td>
<td>a[0]不可以被修改，因为内容在.rodata</td>
</tr>
<tr>
<td></td>
<td>char *a=&ldquo;text&rdquo;; <br>*a 存储的 text 内容，只读区内容不能修改 <br/>a 代表存储的 .rodata的地址 <br/>a=&ldquo;text1&rdquo; text1位于内存中其他地方的，将这个地址赋值给a</td>
</tr>
</tbody>
</table>
<h3 id="字符串的拷贝">字符串的拷贝</h3>
<ul>
<li>
<p>使用指针运算方式</p>
<pre><code class="language-c">void copy_string02(char* dest, char* src){
	while (*source != '\0' /* *src != 0 */){
		*dest = *src;
		src++;
		dest++;
	}
}
</code></pre>
</li>
<li>
<p>使用数组方式</p>
<pre><code class="language-c">void copy_string01(char* dest, char* src ){
	for (int i = 0; src[i] != '\0';i++){
		dest[i] = src[i];
	}
}
</code></pre>
</li>
<li>
<p>使用while循环</p>
<pre><code class="language-c">void copy_string03(char* dest, char* source){
	// 判断时赋值结尾 0=0也会退出循环
	while (*dest++ = *source++){}
}
</code></pre>
</li>
</ul>
<h3 id="字符串的格式化">字符串的格式化</h3>
<ul>
<li>用于将字符串打印在标准输出的：<code>int printf(const char* str, ...);</code></li>
<li>用于将字符串格式化打印在缓冲区中的（stdin, stdout, stderr是隐式缓冲资源）：<code>int fprintf(FILE *fptr, const char *str, ...);</code></li>
<li>用于格式化而不打印的：<code>int sprintf(char *str, const char *string,...); </code></li>
</ul>
<h2 id="array-sorting">array sorting</h2>
<h3 id="杯子交换">杯子交换</h3>
<p>三杯水交换算法 ( <em><strong>The Cup Swapping algorithm</strong></em>)</p>
<p>有两杯装满水的杯子来代表变量的值，如果需要交换两杯水到对方，就如同交换两个变量的值，此时需要第三个杯子来交换液体，就像第三个变量用作临时存储变量的值一样。</p>
<p>例如，数组的倒序可以使用该方法，也是其他算法中的基础。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
	int arr[] = {22,321,56,1,66,23,9,10}; 
    // 数组的长度
	int len = sizeof(arr) / sizeof(arr[0]);
    // 临时变量 
	int tmp;		 

	// 交换 数组元素，做逆序
    for (int i=0;i&lt;len;i++)
	{
        if (i &gt; len/2) {
            break;
        }
		tmp = arr[i]; // 第三杯水
		arr[i] = arr[len-i-1];
		arr[len-i-1] = tmp;
	}
}
</code></pre>
<h3 id="冒泡-supa-href44asup">冒泡 <sup><a href="#4">[4]</a></sup></h3>
<p>冒泡排序 (<em><strong>bubble sort</strong></em>) 是最简单的排序算法，其核心是==如果两个相邻元素的位置排序不对，就交换相邻的元素==，例如： <em><strong>arr[] = {5, 1, 4, 2, 8}</strong></em> ，从前两个元素开始比较检查哪个更大</p>
<ul>
<li>
<p>第一轮（迭代）：</p>
<ul>
<li>
<p>( <strong>5</strong> <strong>1</strong> 4 2 8 ) -&gt; ( <strong>1</strong> <strong>5</strong> 4 2 8 )，比较前两个元素 5 &gt; 1 交换两个位置。</p>
</li>
<li>
<p>( 1 <strong>5</strong> <strong>4</strong> 2 8 ) –&gt; ( 1 <strong>4</strong> <strong>5</strong> 2 8 )，5 &gt; 4 交换两个位置</p>
</li>
<li>
<p>( 1 4 <strong>5</strong> <strong>2</strong> 8 ) –&gt; ( 1 4 <strong>2</strong> <strong>5</strong> 8 )，5 &gt; 2 交换两个位置</p>
</li>
<li>
<p>( 1 4 2 <strong>5</strong> <strong>8</strong> ) -&gt; ( 1 4 2 <strong>5</strong> <strong>8</strong> )，(8 &gt; 5)，不会交换，至此最后一位排序正确</p>
</li>
</ul>
</li>
<li>
<p>第二轮</p>
<ul>
<li>( <strong>1</strong> <strong>4</strong> 2 5 8 ) -&gt;  ( <strong>1</strong> <strong>4</strong> 2 5 8 )</li>
<li>( 1 <strong>4</strong> <strong>2</strong> 5 8 ) –&gt;  ( 1 <strong>2</strong> <strong>4</strong> 5 8 )，4 &gt; 2 交换两个位置</li>
<li>( 1 2 <strong>4</strong> <strong>5</strong> 8 ) -&gt;  ( 1 2 <strong>4</strong> <strong>5</strong> 8 )</li>
<li>( 1 2 4 <strong>5</strong> <strong>8</strong> ) -&gt;  ( 1 2 4 <strong>5</strong> <strong>8</strong> )</li>
</ul>
</li>
<li>
<p>第三轮（没法发生交换）</p>
<ul>
<li>( <strong>1</strong> <strong>2</strong> 4 5 8 ) -&gt; ( <strong>1</strong> <strong>2</strong> 4 5 8 )</li>
<li>( 1 <strong>2</strong> <strong>4</strong> 5 8 ) -&gt; ( 1 <strong>2</strong> <strong>4</strong> 5 8 )</li>
<li>( 1 2 <strong>4</strong> <strong>5</strong> 8 ) -&gt; ( 1 2 <strong>4</strong> <strong>5</strong> 8 )</li>
<li>( 1 2 4 <strong>5</strong> <strong>8</strong> ) -&gt; ( 1 2 4 <strong>5</strong> <strong>8</strong> )</li>
</ul>
</li>
</ul>
<p><strong>算法实现</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 三杯水交换
void swap(int* x, int* y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}
 
// 冒泡实现
void bubbleSort(int arr[], int n)
{
    int i, j;
    for (i = 0; i &lt; n - 1; i++)
 
        // Last i elements are already in place
        for (j = 0; j &lt; n - i - 1; j++)
            if (arr[j] &gt; arr[j + 1])
                swap(&amp;arr[j], &amp;arr[j + 1]);
}
 
// 打印数组
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i &lt; size; i++)
        printf(&quot;%d &quot;, arr[i]);
    printf(&quot;\n&quot;);
}

int main()
{
    int arr[] = { 64, 34, 25, 12, 22, 11, 90 };
    int n = sizeof(arr) / sizeof(arr[0]);
    bubbleSort(arr, n);
    printf(&quot;Sorted array: \n&quot;);
    printArray(arr, n);
    return 0;
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-c">Sorted array: 
11 12 22 25 34 64 90 
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.cs.uic.edu/~jbell/CourseNotes/C_Programming/Arrays.html" target="_blank"
   rel="noopener nofollow noreferrer" >Arrays in c</a></p>
<p><sup id="2">[2]</sup> <a href="https://pediaa.com/what-is-the-difference-between-array-and-string/" target="_blank"
   rel="noopener nofollow noreferrer" >difference between array and string</a></p>
<p><sup id="3">[3]</sup> <a href="https://www.tutorialspoint.com/cprogramming/c_strings.htm" target="_blank"
   rel="noopener nofollow noreferrer" >string in c</a></p>
<p><sup id="4">[4]</sup> <a href="https://www.geeksforgeeks.org/bubble-sort/" target="_blank"
   rel="noopener nofollow noreferrer" >bubble sort with c</a></p>
<p><sup id="5">[5]</sup> <a href="https://iq.opengenus.org/3d-array-in-c/" target="_blank"
   rel="noopener nofollow noreferrer" >3d array in c</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch04 函数</title>
      <link>https://www.oomkill.com/2022/09/ch04-function/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch04-function/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="concept-supa-href11asup">concept <sup><a href="#1">[1]</a></sup></h2>
<p>函数 (<em><strong>function</strong></em>) 是执行任务的语句块。</p>
<p><strong>函数的作用</strong>：</p>
<ul>
<li>提高代码的可重用性并减少冗余</li>
<li>代码模块化</li>
<li>代码易读性</li>
<li>使代码模块化</li>
</ul>
<h2 id="函数的分类">函数的分类</h2>
<p>C语言中有两种类型的函数：</p>
<ul>
<li>标准库函数：C中的内置函数，在头文件中定义
<ul>
<li><code>#include &lt;stdio.h&gt;</code></li>
</ul>
</li>
<li>用户自定义函数：用户自定义的函数
<ul>
<li><code>#include &quot;stdio.h&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="函数三部曲">函数三部曲</h2>
<p>C语言中函数分为三个方面，声明(<em><strong>declaration</strong></em>)，定义(<em><strong>defining</strong></em>)，调用(<em><strong>calling</strong></em>)</p>
<h3 id="声明">声明</h3>
<p>声明是让编译器知道函数的名称、参数信息、参数的返回值的类型。</p>
<pre><code class="language-c">(type) function_name({type args...});
</code></pre>
<p><strong>隐式声明</strong>(<em><strong>implicit</strong></em>) ：当在main之后定义的函数而未声明，默认编译器会做隐式声明。</p>
<blockquote>
<p>ISO/IEC 9899:1990 中 关于函数声明的部分：</p>
<p>函数在调用前必须有一个可用的声明，如果没有被声明，则该函数默认被隐式声明，该隐式声明没有参数，返回值为int <sup><a href="#2">[2]</a></sup></p>
</blockquote>
<h3 id="定义">定义</h3>
<p>C中函数定义的语法如下</p>
<pre><code class="language-c">return_type function_name(arg1, arg2, ... argn)
{
	function body // 函数中要处理任务的逻辑
}
</code></pre>
<ul>
<li><em><strong>return_type</strong></em>：函数返回值的数据类型</li>
<li><em><strong>function_name</strong></em>：函数名</li>
<li><em><strong>arg1, arg2, &hellip;argn</strong></em>：参数列表（可选），定义传递给函数的数据类型、顺序和参数的数量。</li>
<li><em><strong>function body</strong></em>：调用函数时任务处理和执行的语句</li>
</ul>
<h3 id="调用">调用</h3>
<p>调用是指要由编译器执行的函数，可以在任何部分调用</p>
<h2 id="虚函数void">虚函数void</h2>
<p>如果函数没有返回值，则使用关键字 <em><strong>void</strong></em>，主要用于两个方面：</p>
<ul>
<li>打印具体信息供用户阅读的函数</li>
<li>引用参数，函数通常不是用于返回一个内容，而是修改引用参数的，无需返回值</li>
</ul>
<p><em><strong>void</strong></em> 关键字使用注意：</p>
<ul>
<li>
<p>void仅用于限定函数返回值，函数参数，不可以修饰变量，因为无法对无类型的变量分配指针</p>
</li>
<li>
<p>void修饰指针时表示泛指针，可以无需强制转换为其他类型的指针</p>
<pre><code class="language-c">void *ptr=NULL;
char * a=&quot;1234&quot;;
printf(&quot;a %s\n&quot;, a);
ptr = a;
printf(&quot;%s\n&quot;, (char*)ptr);
</code></pre>
</li>
</ul>
<h2 id="宏函数">宏函数</h2>
<p>宏函数是指带有参数的宏(<em><strong>Macro-Arguments</strong></em>)，具有类似函数的功能，例如下列时一个获取最小值的宏函数</p>
<pre><code class="language-c">#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))
    char a='a';
    char b='b';
    char x = min(a, b);         // →  x = ((a) &lt; (b) ? (a) : (b));
    char y = min(1, 2);         // →  y = ((1) &lt; (2) ? (1) : (2));
    printf(&quot;x is %c, y is %c\n&quot;, x, y);
</code></pre>
<h3 id="宏函数危险部分">宏函数危险部分</h3>
<p>在上面例子中存在一些不安全部分</p>
<ul>
<li>
<p>错误嵌套：</p>
</li>
<li>
<p><strong>括号优先级</strong>：<code>#define ceil_div(x, y) x + y</code> 因为宏函数带有的括号是围绕这个宏函数的，会存在运算符优先级问题，如果用上述宏函数进行输出得到的结果为：<code>ceil_div(2, 3) * 10 = 32</code> ，因为括号不是表达式的括号</p>
<ul>
<li>解决方法：每一个宏函数的参数需要用括号括起来 <code>#define ceil_div(x, y) (x + y)</code></li>
</ul>
</li>
<li>
<p><strong>吞分号</strong>：<code>#define NEW_MACRO()  ({ int x = 1; int y = 2; x+y; })</code> 上述宏函数在GCC预处理步骤替换时，通常调用宏函数的部分会加分号 <code>NEW_MACRO();</code> ，例如下列代码中</p>
<pre><code class="language-c">if(1) 
    SKIP_SPACES();
else 
    ...
</code></pre>
<p>被替换后为</p>
<pre><code class="language-c">if(1) 
{ 
    int x = 1; int y = 2; x+y; 
}; // 《这里的分号会跳过else
else 
    ...
</code></pre>
<p>通常情况下使用do&hellip;while替换</p>
<pre><code class="language-c">#define NEW_MACRO() do { int x = 1; int y = 2; x+y; } while (0)

if(1) 
	do{
        int x = 1; int y = 2; x+y;
    }
	while(0);
else 
    ...
</code></pre>
</li>
<li>
<p><strong>重复替换的副作用</strong>：<code>#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</code> 这个宏函数在gcc预处理中如果调用时是 <code>next = min (x + y, foo (z));</code> 将被重复替换，如下列代码所示：</p>
<pre><code class="language-c">next = ((x + y) &lt; (foo (z)) ? (x + y) : (foo (z)));  // 参数Y被替换为两个foo
</code></pre>
<pre><code>
代表foo被执行两次，这种显然不安全，推荐使用typeof

`c
efine min(X, Y)                \
 typeof (X) x_ = (X);          \
peof (Y) y_ = (Y);          \
_ &lt; y_) ? x_ : y_; })
</code></pre>
<pre><code>
</code></pre>
</li>
<li>
<p><strong>直接自引用</strong>：是指定义的宏引用自己，例如 <code>#define foo (4 + foo)</code>，为了方式无限扩展为 <code>(4+(4+foo))</code>, <code>(4+(4+(4+foo)))</code> &hellip; 直到内存耗尽，这种情况编译器将不允许 <code>each undeclared identifier is reported only once for each function it appears in</code></p>
</li>
<li>
<p><strong>间接自引用</strong>：指a引用b，b引用a，例如下列代码，是不被允许的</p>
<pre><code class="language-c">#define x (4 + y) 
#define y (2 * x)
</code></pre>
</li>
<li>
<p>参数的换行符不被允许</p>
</li>
</ul>
<h2 id="函数的退出">函数的退出</h2>
<ul>
<li>exit() 是一个终止当前进程的系统调用（无论在代码哪里调用）；非C语言内置功能</li>
<li>return：向调用函数提供退出状态并将控制权返回给调用函数，C语言内置功能</li>
</ul>
<h2 id="多文件编程-supa-href33asup">多文件编程 <sup><a href="#3">[3]</a></sup></h2>
<p>多文件程序(<em><strong>multi-file</strong></em>) 是指多个含有不同功能的代码文件（ .c 文件模块），编译到一起，生成一个二进制文件。</p>
<p>通常包含三部分：</p>
<ul>
<li>
<p>编译：通过编译器编译多个文件程序</p>
</li>
<li>
<p>函数原型（声明）：告知编译器如何使用，表现为：</p>
<ul>
<li>函数在一个文件中定义，在另一个文件中调用</li>
<li>想对文件中的函数重新排序</li>
<li>函数相互调用，递归</li>
</ul>
</li>
<li>
<p>头文件：使多个文件中的函数可以访问定义和声明，通常情况下包含：</p>
<ul>
<li>全局变量和全局常量</li>
<li>类，结构体，联合体，枚举等</li>
<li>创建类型名称的 typedef 语句</li>
<li>函数声明</li>
<li>包含其他文件的语句，如math.h</li>
</ul>
</li>
</ul>
<p><strong>防止头文件重复包含</strong></p>
<p>windows</p>
<pre><code class="language-c">#pragma once
</code></pre>
<p>linux</p>
<pre><code class="language-c">#ifndef __HEAD_H__
#define __HEAD_H__

.... head file body

#endif
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.programiz.com/c-programming/c-functions" target="_blank"
   rel="noopener nofollow noreferrer" >c function</a></p>
<p><sup id="2">[2]</sup> <a href="https://stackoverflow.com/questions/434763/are-prototypes-required-for-all-functions-in-c89-c90-or-c99" target="_blank"
   rel="noopener nofollow noreferrer" >Are prototypes required for all functions in C89, C90 or C99?</a></p>
<p><sup id="3">[3]</sup> <a href="https://www.cs.hmc.edu/~geoff/classes/hmc.cs070.200401/notes/multi-file.html" target="_blank"
   rel="noopener nofollow noreferrer" >multi-file</a></p>
<p><sup id="4">[4]</sup> <a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html#Macros" target="_blank"
   rel="noopener nofollow noreferrer" >Macros</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch05 指针</title>
      <link>https://www.oomkill.com/2022/09/ch05-pointer/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch05-pointer/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="指针">指针</h2>
<h3 id="指针声明-supa-href11asup">指针声明 <sup><a href="#1">[1]</a></sup></h3>
<p>指针/指针变量 (<em><strong>pointer</strong></em>) 是用于存储地址的变量</p>
<p>使用 <code>&amp;</code> 运算符 来访问变量的地址。例如</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main()
{
   int a = 100;
   printf(&quot;%x&quot;, &amp;a);
}
</code></pre>
<p>输出结果为 16进制的内存地址</p>
<pre><code class="language-c">61fe1c
</code></pre>
<p>使用地址运算符 <code>*</code> 可以从变量地址中获取变量的值，这个行为被称为间接引用/解引用(<em><strong>indirection/dereferencing</strong></em>)。例如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main()
{
   int a = 100;
   printf(&quot;%d&quot;, *(&amp;a)); 
   // 也可以写为，因为*与&amp;优先级相同，从右到左的顺序，所以有没有()意思是相同的
   printf(&quot;%d&quot;, *&amp;a);
}
</code></pre>
<p>输出结果为 100</p>
<h3 id="指针变量">指针变量</h3>
<p>指针变量是指存储一个变量的地址的变量，可以使用符号 <code>*</code> 来修饰变量，定义语法为：</p>
<pre><code class="language-c">dataType *pointerVariableName = &amp;variableName;
</code></pre>
<p>例如，下面的两个输出结果是相同的地址</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main()
{
   int a = 100;
   int *pointer;
   pointer = &amp;a;
   printf(&quot;address of a is: %x\n&quot;,&amp;a);
   printf(&quot;address of pointer is: %x\n&quot;,pointer);
}

address of a is: 61fe14
address of pointer is: 61fe14
</code></pre>
<blockquote>
<p>Notes：指针可以通过变量修改也可以直接通过地址进行修改，指针变量就是通过地址进行修改</p>
</blockquote>
<h4 id="修饰符说明">修饰符说明</h4>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>两个用途：<br>指针变量的声明<br>返回被引用变量的值</td>
</tr>
<tr>
<td>&amp;</td>
<td>返回变量地址</td>
</tr>
</tbody>
</table>
<h4 id="使用const修饰指针-supa-href33asup">使用const修饰指针 <sup><a href="#3">[3]</a></sup></h4>
<p>使用关键字 <code>const</code> 修饰的指针变量是不能改变指针变量所指向的地址的变量，通俗来讲即不能被改变值的指针变量</p>
<p>声明语句</p>
<pre><code class="language-c">&lt;type of pointer&gt; *const &lt;name of pointer&gt;;  
int *const ptr;  
</code></pre>
<p><strong>const位置</strong>：const修饰的部分（const所在位置）不可改变</p>
<ul>
<li>
<p>例如 <code>const int *p;</code> 与 <code>int const *p;</code> 这里修饰的都是 <code>*p</code> 故</p>
<ul>
<li>
<p><code>*p</code> （变量地址）不能被改变</p>
</li>
<li>
<p><code>p</code> （变量值）可以被改变</p>
</li>
<li>
<pre><code class="language-c">  #include&lt;stdio.h&gt;
  #include&lt;stdlib.h&gt;
  void main()
  {
    int a = 10;
    int b = 20;
    int const *p;
    *p = &amp;b; // result assignment of read-only location '*p'
    p = 30; // result 30

    printf(&quot;%d&quot;,p);
  }
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>int * const p; </code> const在*后p前，这里修饰的都是 <code>p</code> 故</p>
<ul>
<li>p不可以被修改</li>
<li>*p 可以被修改</li>
</ul>
</li>
<li>
<p><code>const int *const p;</code> 这里 const 修饰 * 和 p，所以两个都不可修改</p>
</li>
</ul>
<blockquote>
<p>Notes：通常情况下常用只有第一种情况</p>
</blockquote>
<p><strong>使用场景</strong>：最为参数形参修饰该参数为只读参数，例如 printf</p>
<pre><code class="language-c">int printf (const char *__format, ...)
</code></pre>
<h3 id="指针的类型-supa-href22asup">指针的类型 <sup><a href="#2">[2]</a></sup></h3>
<p>C语言中包含多种指针类型：</p>
<ul>
<li>空指针(<em><strong>Null Pointer</strong></em>)</li>
<li>野指针(<em><strong>Wild Pointer</strong></em>)</li>
<li>悬空指针(<em><strong>Dangling pointer</strong></em>)</li>
<li>泛型指针(<em><strong>void Pointer</strong></em>)</li>
<li>一些早期Dos中的概念
<ul>
<li>近指针(<em><strong>Near</strong></em>)：不能存储大小大于 16 位的地址</li>
<li>远指针(<em><strong>Far</strong></em>)：32 位大小的指针</li>
<li>大指针(<em><strong>Huge</strong></em>)：类似于远指针。</li>
</ul>
</li>
</ul>
<h4 id="空指针">空指针</h4>
<p>在声明期间将 NULL 分配给指针的指针称为 空 (<em><strong>NULL</strong></em>) 指针，例如</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main()
{
   int *var = NULL;
   printf(&quot;address of var is: %p\n&quot;,var);
}
</code></pre>
<ul>
<li>空指针不能解引用：NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针</li>
<li>空指针不能拷贝内容：<code>strcpy(*p,&quot;1111);</code></li>
</ul>
<h4 id="泛型指针">泛型指针</h4>
<p>使用 <code>void</code> 关键字声明指针变量，可以接受任意一种类型的变量地址，如果需要使用泛型指针，需要强转为对应类型才可以使用。如下示例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main()
{
   int a = 6666;
   void *p = &amp;a;
   printf(&quot;address of p is: %p\n&quot;, (int*) p);
   printf(&quot;value of p is: %d\n&quot;, *(int*) p);
}

address of p is: 000000000061FE14
value of p is: 6666
</code></pre>
<h4 id="野指针">野指针</h4>
<p>野指针是指，没有有效地址的空间的指针，例如声明了指针变量没有对其赋值，这种情况下会出现 <code>Segmentation fault</code> 异常。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main()
{
   int *p;
   printf(&quot;address of p is: %p\n&quot;, *p); 
}
</code></pre>
<p>再例如一个无效的地址空间也会发生  <code>Segmentation fault</code> 异常；例如下列赋值中，指针p赋值被视为一个内存地址，而不是变量的值，这个地址无效。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main()
{
   int *p;
   *p = 10000;
   printf(&quot;address of p is: %p\n&quot;, *p);
}
</code></pre>
<p>野指针出现场景：</p>
<ul>
<li>指针变量声明但未初始化</li>
<li>指针释放后未置空</li>
<li>指针操作超出变量作用域</li>
</ul>
<p>避免野指针的出现：</p>
<ul>
<li>初始化置 NULL</li>
<li>释放后置 NULL</li>
</ul>
<h4 id="悬空指针">悬空指针</h4>
<p>悬空指针是指”已经被释放的内存“的指针变量，此时这个地址空间是无效的。如下所示</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void main()
{

  int *P=(int *)malloc(sizeof(int));
  int a=5;
  P=&amp;a;
  free(P);
  printf(&quot;After deallocating its memory *p=%d&quot;, *P);
}
</code></pre>
<h3 id="指针的偏移量">指针的偏移量</h3>
<p>指针步长是指指针在运算是偏移多少字节</p>
<ul>
<li>
<p>指针+1之后跳跃的字节数取决于指针的类型，int 4, char 1, struct struct长度</p>
</li>
<li>
<p>指针解引用时需要转换成对应的数据类型，从而判断被解引用后的大小，<code>* (int *) p</code> 指针类型变量转换为指针int类型变量</p>
</li>
<li>
<p>对于结构体指针来说，offsetof函数定位属性对应的偏移量</p>
<pre><code class="language-c">#include&lt;stddef.h&gt;
offsetof(&lt;struct struct_name&gt;, &lt;obj_name&gt;)
</code></pre>
</li>
</ul>
<h2 id="指针数组">指针数组</h2>
<p>在C语言中 数组是由两部分组成，数组名与数组本身。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
void main()
{
	int a[10] = {0};
	a[1] = 20;
	for (int i=0; i&lt; sizeof(a) / sizeof(a[0]); i++){
		printf(&quot;%d\n&quot;,a[i]);
	}
	printf(&quot;arr %p = &amp;arr %p&quot;, a, &amp;a[0]);
   
}
</code></pre>
<p>上面例子中，变量a是一个数组，而变量a代表的是一个指向该数组第一个元素的地址，<code>a=&amp;a[0]</code> ，这是一个const修饰的指针是不可以被改变的。</p>
<p>可以看到变量a和 <code>&amp;a[0]</code> 值是相同的，而一个const修饰的指针变量是不可改变的，故a不能被赋值，下列代码是不合法的。总结为：<strong>不允许将任何地址分配给数组变量</strong></p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
void main()
{
	int a[10] = {0};
	int b[1] = {0};
	int c = 10;
	a = &amp;b;
	a = &amp;c;
	for (int i=0; i&lt; sizeof(a) / sizeof(a[0]); i++){
		printf(&quot;%d\n&quot;,a[i]);
	}
	printf(&quot;arr %p = &amp;arr %p&quot;, a, &amp;a[0]);
   
}
</code></pre>
<h3 id="使用指针访问数组">使用指针访问数组</h3>
<p>上面知道了，数组变量指向的是数组的起始元素（第一个元素）的地址指针，那么通过指针可以对数组进行访问。</p>
<p>因为 <code>a = &amp;a[0]</code> 那么 <code>a[0] = *a</code>，由此可推导出下列公式：</p>
<ul>
<li><code>&amp;a[1] = a+1</code> （取数组元素的地址）   那么 <code>a[1] = *(a+1)</code> （取数组元素的值）</li>
<li><code>&amp;a[2] = a+2</code>   那么 <code>a[2] = *(a+2)</code></li>
</ul>
<p>这种情况下数组的访问就有四种方法</p>
<h3 id="array-vs-pointer-supa-href44asup">Array VS Pointer <sup><a href="#4">[4]</a></sup></h3>
<ul>
<li>数组名是常量，指针是变量</li>
<li>sizeof(array) 得到的是数组实际占用内存空间的字节数，sizeof(pointer) 是4/8 取决于操作系统</li>
</ul>
<h3 id="指针运算">指针运算</h3>
<h4 id="左值和右值-supa-href55asup">左值和右值 <sup><a href="#5">[5]</a></sup></h4>
<p>了解对于指针运算前，需要对左值(<em><strong>lvalue</strong></em>)和右值(<em><strong>rvalue</strong></em>)进行了解</p>
<ul>
<li>左值：通常来说是在占有内存地址（即具有地址）的对象
<ul>
<li>具有存储数据的内力，例如变量</li>
<li>不能是函数，表达式，或常量</li>
<li>综合来说，左值可以是以下几种：
<ul>
<li>任何类型的变量：int, float, pointer, struct等</li>
<li>数组的下标表达式，如a[1]</li>
<li>括号内的表达式（指针）</li>
<li>指针的间接引用</li>
<li>常量（不可改变的左值）</li>
<li>通过指针访问对象属性或成员 (-&gt; or .)</li>
</ul>
</li>
</ul>
</li>
<li>右值：在内存中没有占有内存地址的对象
<ul>
<li>返回不可改变的表达式或值，例如a+b是一个常量，函数运行结果是一个右值</li>
</ul>
</li>
</ul>
<p><strong>左值的示例</strong></p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
void main()
{	
	// 声明变量a为int类型
	int a;
	// a是一个左值，引用对象为int
	a = 1;
	// 左值a出现在右边的场景
	int b = a; 
	
	// 非法，a是左值
	9 = a;

	// 左值，*p是指针，p就是值，*p+4是后面一个int类型的地址，是左值
	int *p;
	int a = 10;
	p = &amp;a;
	// 这里实际上是指针运算，p+0为自己，p存储指针 *p为值，那么a=10000,p=10000
	*(p+0) = 10000;   
	printf(&quot;%p\n&quot;,a);
	printf(&quot;%p\n&quot;,*p);
	printf(&quot;%d\n&quot;,a);
	printf(&quot;%d\n&quot;,*p);
}
</code></pre>
<p><strong>右值的示例</strong></p>
<pre><code class="language-c">// 声明变量a b
int a = 1, b;

// 非法，a+1为常量，不是左值
a + 1 = b; 
 
// 声明指针变量 p q
int *p, *q; // *p, *q 为左值
 
*p = 1; // 合法，左值可以赋值
 
// 非法 - &quot;p + 2&quot; 是右值
p + 2 = 18;
 
q = p + 5; // &quot;p + 5&quot; 是右值，合法
 
// 解引用表达式是左值
*(p + 2) = 18;
 
p = &amp;b;
 
int arr[20]; // 数组元素访问arr[12] = *(arr+12) 所以是左值有效
 
struct S { int m; };
 
struct S obj; // obj and obj.m are lvalues
 
// ptr-&gt; 等于  (*ptr).m 是左值有效
</code></pre>
<p>一元表达式需要有左值，当a是左值&amp;a才生效，12本身是一个右值，不能&amp;12</p>
<pre><code class="language-c">int a, *p; // a 和 *p都是左值
p = &amp;a; // 合法，&amp;a是常量为右值，p是左值
&amp;a = p; // 缺少左值，非法
</code></pre>
<p>三元表达式是一个右值（C++是左值）</p>
<pre><code class="language-c">(  x &lt; y ? y : x) = 10; // c无效，c++有效
</code></pre>
<p><strong>左值 VS 右值</strong></p>
<ul>
<li>左值为内存中可识别的对象，右值为一个常量（广义上，不是const）</li>
<li>左值可以在左边和右边，右值必须在右边</li>
<li>右值必须有左值才生效</li>
<li>指针运算可左可右，变量运算是右值</li>
</ul>
<h4 id="arithmetic-supa-href66asup">arithmetic <sup><a href="#6">[6]</a></sup></h4>
<p>C语言中，指针支持四种算术运算符，吧地址当作数值进行算数运算</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>可以将值赋值给指针</td>
</tr>
<tr>
<td>+</td>
<td>从指针加整数值以指向不同的内存位置。</td>
</tr>
<tr>
<td>-</td>
<td>从指针中减去整数值以指向不同的内存位置</td>
</tr>
<tr>
<td>比较运算（==, !=, &lt;, &gt;, &lt;= , &gt;=）</td>
<td>仅比较两个指针地址，例如<br>pointer == NULL</td>
</tr>
<tr>
<td>++</td>
<td>指针使用递增运算符将向前位移一位</td>
</tr>
<tr>
<td>&ndash;</td>
<td>指针使用递减运算符将向后位移一位</td>
</tr>
</tbody>
</table>
<ul>
<li>当对指针变量进行递增和递减操作时，会改变指针变量本身所在地址空间</li>
<li>当对指针变量进行+-运算时，不会改变指针变量本身</li>
</ul>
<h3 id="指针数组-1">指针数组</h3>
<p>指针数组是指数组存储的内容是指针，即数组内所有的元素都是指针</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
void main()
{	
	int a = 10;
	int b = 20;
	int c = 30;
	int *arr[] = {&amp;a, &amp;b, &amp;c};
}
</code></pre>
<p>指针数组本质也是一个多级指针，例如一个2D数组每行(<em><strong>rows</strong></em>) 存储的值是一列(<em><strong>colums</strong></em>)的地址</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
void main()
{	
	int a[] = { 10 };
	int b[] = { 20 };
	int c[] = { 30 };
	int *arr[] = {a, b, c};
}
</code></pre>
<h3 id="pointer-vs-array">Pointer VS Array</h3>
<ul>
<li>sizeof
<ul>
<li><code>sizeof(array)</code> 返回数组中所有元素占用内存的大小</li>
<li><code>sizeof(pointer)</code> 只返回指针变量本身用内存的大小</li>
</ul>
</li>
<li>&amp;运算符
<ul>
<li>数组名是 <code>&amp;array[0]</code> 的别名，返回数组中第一个元素的地址</li>
<li><code>&amp;pointer</code> 返回指针的地址</li>
</ul>
</li>
<li>指针变量可以赋值，而数组变量不可以</li>
<li>数组是收集了相同类型元素的集合，而指针是一个存储地址的变量</li>
</ul>
<h2 id="多级指针-supa-href77asup">多级指针 <sup><a href="#7">[7]</a></sup></h2>
<p>一个指针用于存储变量的地址，而另一个指针用于存储第一个指针的地址，这种指针被称为多级指针 (<em><strong>Multi-Pointer or Pointer to Pointer</strong></em>)</p>
<p>声明多级指针必须在指针变量名称前多家一个 ”*“</p>
<pre><code class="language-c">int **p;
</code></pre>
<p>通过示例更好的了解多级指针</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
  
// C program to demonstrate pointer to pointer
int main()
{
    int var = 123;
  
    // pointer for var
    int *ptr1;
  
    // double pointer for ptr2
    int **ptr2;

	// third pointer for ptr2
    int ***ptr3;
  
    // storing address of var in ptr1
    ptr1 = &amp;var;
    // Storing address of ptr2 in ptr1
    ptr2 = &amp;ptr1;
	// Storing address of ptr3 in ptr2
	ptr3 = &amp;ptr2;
      
    // Displaying value of var using
    // both single and double pointers
    printf(&quot;Value of var = %d\n&quot;, var );
    printf(&quot;Value of var using single pointer = %d\n&quot;, *ptr1 );
    printf(&quot;Value of var using double pointer = %d\n&quot;, **ptr2);
	printf(&quot;Value of var using third pointer = %d\n&quot;,  ***ptr3);
    
  	return 0;
}
</code></pre>
<p>输出结构</p>
<pre><code class="language-c">Value of var = 123
Value of var using single pointer = 123
Value of var using double pointer = 123
Value of var using third pointer = 123
</code></pre>
<p>Note：</p>
<ul>
<li>多级指针，不能跨越定义，即二级指针必须拥有一级指针才可以</li>
<li>此时的 <code>*ptr</code>  可以是左值或右值
<ul>
<li>作为左值时，存储数据到该变量存储的地址空间内</li>
<li>作为右值时，取出该空间内的内容</li>
</ul>
</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
  
// C program to demonstrate pointer to pointer
int main()
{
    int var = 123;
  
    // pointer for var
    int *ptr1;
  
    // double pointer for ptr2
    int **ptr2;

	// third pointer for ptr2
    int ***ptr3;
  
    // storing address of var in ptr1
    ptr1 = &amp;var;
    // Storing address of ptr2 in ptr1
    ptr2 = &amp;ptr1;
	// Storing address of ptr3 in ptr2
	ptr3 = &amp;ptr2;
      
    // Displaying value of var using
    // both single and double pointers
	***ptr3 = 100;
	printf(&quot;l-value test, the result of value = %d\n&quot;, var );
    printf(&quot;l-value test, the result of ptr1 = %d\n&quot;,  *ptr1);
	printf(&quot;l-value test, the result of ptr2 = %d\n&quot;,  **ptr2);
    printf(&quot;l-value test, the result of ptr3 = %d\n&quot;,  ***ptr3);

	var = (***ptr3+1);
	printf(&quot;r-value test, the result of value = %d\n&quot;, var );
	return 0;
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-bash">l-value test, the result of value = 100
l-value test, the result of ptr1 = 100
l-value test, the result of ptr2 = 100
l-value test, the result of ptr3 = 100
r-value test, the result of value = 101
</code></pre>
<h3 id="指针和函数">指针和函数</h3>
<h3 id="指向普通数据类型的指针">指向普通数据类型的指针</h3>
<p>指针可以被当作函数参数传递，会改变原有的变量值</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void swap(int *n1, int *n2);

int main()
{
    int num1 = 5, num2 = 10;

    // address of num1 and num2 is passed
    swap( &amp;num1, &amp;num2);

    printf(&quot;num1 = %d\n&quot;, num1);
    printf(&quot;num2 = %d&quot;, num2);
    return 0;
}

void swap(int* n1, int* n2)
{
    int temp;
    temp = *n1;
    *n1 = *n2;
    *n2 = temp;
}
</code></pre>
<h3 id="指向函数的指针--supa-href88asup">指向函数的指针  <sup><a href="#8">[8]</a></sup></h3>
<p>C语言中，指针也可以被指向一个函数，下面代码是一个指向函数的指针</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
// 定义一个无返回值的常规函数
void fun(int a)
{
    printf(&quot;Value of a is %d\n&quot;, a);
}
  
int main()
{
    // fun_ptr是一个指针类型，他指向函数fun的地址
    void (*fun_ptr)(int) = &amp;fun;
  
    /* 也可以写为如下代码
       void (*fun_ptr)(int);
       fun_ptr = &amp;fun; 
    */
  
    // 调用指向函数的指针
    (*fun_ptr)(10);
  
    return 0;
}
</code></pre>
<p>声明指针函数函数的说明，通常情况下声明函数语法为 <code>int foo(int);</code>  则代表声明了一个foo函数，具有int类型参数和int类型的返回值，而在中间加一个 ”*&quot; 则可以表示一个指针函数的定义 <code>int * foo(int);</code> 这种类型是错误的。</p>
<p>因为在c语言中，<code>*</code> 的优先级要高于 <code>()</code>， 上面说到的情况则表示了声明一个foo函数，int类型的参数和 *int 类型的返回值。所以必须使用 () 改变其优先级</p>
<pre><code class="language-c">int (*foo)(int);
</code></pre>
<h3 id="函数指针数组">函数指针数组</h3>
<p>函数指针数组是指元素为函数指针的数组，有些特殊的地方是，定义时不能定义为数组指针，需要定义为函数指针，函数指针数组也可以替代switch</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void add(int a, int b)
{
    printf(&quot;Addition is %d\n&quot;, a+b);
}
void subtract(int a, int b)
{
    printf(&quot;Subtraction is %d\n&quot;, a-b);
}
void multiply(int a, int b)
{
    printf(&quot;Multiplication is %d\n&quot;, a*b);
}
  
int main()
{
    // fun_ptr_arr is an array of function pointers
    void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply};
    unsigned int ch, a = 15, b = 10;
  
    printf(&quot;Enter Choice: 0 for add, 1 for subtract and 2 &quot;
            &quot;for multiply\n&quot;);
    scanf(&quot;%d&quot;, &amp;ch);
  
    if (ch &gt; 2) return 0;
  
    (*fun_ptr_arr[ch])(a, b);
  
    return 0;
}
</code></pre>
<p>关于函数指针的说明：</p>
<ul>
<li>普通指针指向的数据，函数指针指向的是代码</li>
<li>函数名代表函数的地址</li>
<li>函数去指不用加取址符 “&amp;”，函数指针变量调用不用加“ * ”</li>
<li>函数指针可以作为参数，也可以作为返回值</li>
</ul>
<h3 id="数组与函数">数组与函数</h3>
<ul>
<li><strong>数组作为参数时</strong>：数组作为函数参数传入时，传递不再是整个数组，而是数组的第一元素的地址，也就是指针，此时不能用size()获取数组的元素，获取到的时指针类型的大小。</li>
<li><strong>数组作为返回值时</strong>：不允许返回数组，返回的是数组第一个元素指针，sizeof() 查看的大小也是指针类型的大小</li>
</ul>
<h2 id="main函数的参数">main函数的参数</h2>
<p>在C语言中main()函数之前提供了一个函数 <code>_start()</code>，但通常情况下 main() 是作为程序执行的第一个函数。main() 函数提供了两个参数，<em><strong>argc</strong></em> 和 <em><strong>argv</strong></em> 。</p>
<ul>
<li><em><strong>argc</strong></em> 命令行传入的参数数量，int类型</li>
<li><em><strong>argv</strong></em> 命令行传入的实际参数，参数索引从1开始，0为程序本身名称
<ul>
<li>正常情况下声明main函数：<code> main(int argc, char *argv[])</code></li>
<li><code>**argv</code> 是 <code>*argv[]</code> 的另一种表现方式 <code>main(int argc, char **argv)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>Notes：这里有一个比较难理解的地方就是二级指针作为形参来替换指针数组。</p>
<p>由于二级指针变量存放为一个一级指针的地址，而数组名本身是数组首元素的地址，其后的每一个元素都是指针就是将首元素指针传入。由于上面讲到数组作为参数传入时传入的是指针而不是数组本身。所以 *argv[] 与 **argv 是等价的。</p>
</blockquote>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/" target="_blank"
   rel="noopener nofollow noreferrer" >c pointer</a></p>
<p><sup id="2">[2]</sup> <a href="https://www.guru99.com/c-pointers.html" target="_blank"
   rel="noopener nofollow noreferrer" >pointer type</a></p>
<p><sup id="3">[3]</sup> <a href="https://www.javatpoint.com/const-pointer-in-c" target="_blank"
   rel="noopener nofollow noreferrer" >const pointer</a></p>
<p><sup id="4">[4]</sup> <a href="https://www.freecodecamp.org/news/pointers-in-c-are-not-as-difficult-as-you-think/#1-what-exactly-are-pointers" target="_blank"
   rel="noopener nofollow noreferrer" >pointer VS array</a></p>
<p><sup id="5">[5]</sup> <a href="https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/" target="_blank"
   rel="noopener nofollow noreferrer" >lvalue VS rvlaue</a></p>
<p><sup id="6">[6]</sup> <a href="https://aticleworld.com/pointer-arithmetic/" target="_blank"
   rel="noopener nofollow noreferrer" >pointer arithmetic</a></p>
<p><sup id="7">[7]</sup> <a href="https://www.geeksforgeeks.org/double-pointer-pointer-pointer-c/" target="_blank"
   rel="noopener nofollow noreferrer" >pointer to pointer</a></p>
<p><sup id="8">[8]</sup> <a href="https://www.geeksforgeeks.org/function-pointer-in-c/" target="_blank"
   rel="noopener nofollow noreferrer" >function pointer in c</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch06 内存布局</title>
      <link>https://www.oomkill.com/2022/09/ch06-memory-layout/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch06-memory-layout/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>在编写程序时包含任意指令如，已初始化和未初始化数据，局部变量，函数等都是用于动态分配内存的指令。当程序编译后（默认生成 <code>x.out</code> 文件）这是一个可执行的链接文件( <em><strong>Executable and linking format</strong></em>)。在执行时这些不组织成几部分，包含不同的内存分段 (<em><strong>segments</strong></em>)</p>
<blockquote>
<p>ELF：这是系统中标准二进制格式，其一些功能包含，动态链接，动态加载，对程序运行时控制。</p>
</blockquote>
<p>可以使用 <code>size {ELF_file}</code> 查看被分配的每个段的大小（Linux操作系统）；</p>
<ul>
<li><code>dec</code> 列给出的是这个程序 text + data + bss 段的总大小，用十进制表示</li>
<li><code>text</code> 段是存储可执行命令的段</li>
<li><code>data</code> 段包含所有初始化数据，全局与静态变量</li>
<li><code>BSS</code> 段包含未初始化数据</li>
</ul>
<pre><code class="language-bash">$ size 1 
   text    data     bss     dec     hex filename
   1843     584       8    2435     983 1
</code></pre>
<h2 id="memory-layout-in-c-supa-href11asup">Memory Layout in C <sup><a href="#1">[1]</a></sup></h2>
<p>在C语言中内存布局模型包含六个部分</p>
<ul>
<li>命令行参数 (<em><strong>Command Line Arguments</strong></em>)</li>
<li>栈 (<em><strong>Stack</strong></em>)</li>
<li>堆 (<em><strong>Heap</strong></em>)</li>
<li>未初始化数据段 (<em><strong>Uninitialized Data Segment BSS</strong></em>)</li>
<li>已初始化数据段 (<em><strong>Initialized Data Segment</strong></em>)</li>
<li>文本/代码段 (<em><strong>Text/Code Segment</strong></em>)</li>
</ul>
<p>这6部分结构可以再划分为两种类型：</p>
<ul>
<li>静态内存结构 (<em><strong>Static Memory Layout</strong></em>)：包含代码段, 数据段</li>
<li>动态内存结构 (<em><strong>Dynamic Memory Layout</strong></em>)：包含栈, 堆</li>
</ul>
<p>通过Overview中可以看到可以执行文件包含一些段，而缺少一些段，这部分是由运行时构建出来的。</p>
<p>整个C程序的内存布局为下图所示</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/Memory-layout.png" alt="C程序的内存布局" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：memory layout C</center>
<center><em>Source：</em>https://hackthedeveloper.com/memory-layout-c-program/</center><br>
<h2 id="静态内存布局">静态内存布局</h2>
<p>静态内存布局中，包含代码段(<em><strong>Code Segment</strong></em>)，数据段(<em><strong>Data Segment</strong></em>)；数据段中又分为已初始化段，通常称为数据分段(<em><strong>DS</strong></em>)，未初始化分段(<em><strong>BSS</strong></em>)。</p>
<h3 id="代码段">代码段</h3>
<p>代码段包含可执行的机器指令，这部分包含了程序的逻辑，为了防止堆, 栈的溢出，代码段在内存结构中处于布局中最下方。而且为了防止指令被修改，这部分是只读的。</p>
<ul>
<li>已编译二进制文件</li>
<li>只读段，防止程序被修改</li>
<li>可共享</li>
</ul>
<p>可以通过 <code>objdump -S &lt;file&gt;</code> 来导出代码段中存的汇编代码</p>
<h3 id="已初始化数据段">已初始化数据段</h3>
<p>所有已初始化的静态变量和全局变量都被存储在DS中，该段具有写权限，程序可以在运行时修改该段中变量的值。</p>
<p>定义一个C程序，通过size观看其data段的大小</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
char main()
{
    return '1';
}
</code></pre>
<p>size输出为528</p>
<pre><code class="language-c">$ size 1
   text    data     bss     dec     hex filename
   1358     528       8    1894     766 1
</code></pre>
<p>通过增加两个变量，一个全局变量一个静态变量，观看编译后可执行文件data段的大小与之前大小相比较</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

static int a = 10; // int 类型占4byte
char b = 'a'; 	  // char 类型占1byte

char main()
{
    return '1';
}
</code></pre>
<p>size查看data输出值为533 与之前 528 增加 5 bytes，与定义的类型相符合</p>
<pre><code class="language-c">size 1
   text    data     bss     dec     hex filename
   1358     533       3    1894     766 1
</code></pre>
<h3 id="未初始化数据段">未初始化数据段</h3>
<p>未初始化数据段包含如下内容</p>
<ul>
<li>未初始化的全局和静态变量</li>
<li>初始化为0或空指针的变量</li>
</ul>
<p>接着上述例子，添加两个变量，一个不初始化值，一个初始化为0</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int a;
static int b=0;
char main()
{
    return '1';
}
</code></pre>
<p>通过 size 命令可以看出，这些都被分配到 BSS 部分</p>
<pre><code class="language-c">$ size 1
   text    data     bss     dec     hex filename
   1358     528      16    1902     76e 1
</code></pre>
<p>对于初始化段与未初始化段和只读数据段 (<em><strong>.rodata</strong></em>) 都会被分配到数据段中</p>
<h2 id="动态内存布局">动态内存布局</h2>
<p>动态内存是指程序运行时创建的的内存</p>
<h3 id="heap">heap</h3>
<p>堆段是由BSS往上更高部分动态内存分配的段，heap段具有以下特点</p>
<ul>
<li>
<p>程序运行可以没有heap段</p>
</li>
<li>
<p>heap位于在BSS之上stack之下，与stack成反方向增长和减少</p>
</li>
<li>
<p>运行时分配内存</p>
</li>
<li>
<p>由函数 <code>malloc()</code> , <code>calloc()</code> , <code>free()</code> 等函数管理</p>
</li>
<li>
<p>heap段内存由进程中共享库和动态模块等共享内存</p>
</li>
</ul>
<p>heap对于stack来说，最大的特点就是没有自动的内存管理功能，所有内存的申请和销毁都是通过开发者自行定义的，C中的Glibc API 提供了申请和销毁heap内存的功能。</p>
<ul>
<li>函数 <code>malloc()</code> / <code>calloc()</code> 用户空间实现的库函数，用于申请heap内存，可用于windows/linux</li>
<li>函数 <code>free()</code> 释放由 <code>malloc()</code> / <code>calloc()</code> 申请的内存</li>
<li><code>brk()</code> / <code>sbrk()</code> 是linux下的系统调用，在内核空间实现的库函数</li>
</ul>
<p>下列代码为heap内存分配示例</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 

int func()
{
    int a = 10;
    int *aptr = &amp;a;
    int *ptr = (int *)malloc(sizeof(int));
    *ptr = 20;
    printf(&quot;Heap Memory Value = %d\n&quot;, *ptr);
    printf(&quot;Pointing in Stack = %d\n&quot;, *aptr);
    free(ptr);
}

int main()
{
    func();
    return 0;
}
</code></pre>
<p>下图为上述代码的图形化布局，通过申明一个指针变量 *ptr 指向了通过函数 <code>malloc()</code> 申请的 heap内存</p>
<blockquote>
<p>Notes: heap变量的存储实际存储时在物理内存上，而heap,stack.. 都是虚拟内存中某个进程的地址空间，通过MMU将其转为物理地址进行读写。<sup><a href="#2">[2]</a></sup></p>
</blockquote>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/heap-layout.png" alt="堆内存布局" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：heap layout of C</center>
<center><em>Source：</em>https://hackthedeveloper.com/memory-layout-c-program/</center><br>
<h3 id="stack">stack</h3>
<p>stack是与heap相邻的地区，并与heap以反方向增长，当遇到heap时表示可用内存耗尽。stack段具有如下特点：</p>
<ul>
<li>程序运行必须拥有的内存段</li>
<li>以先进先出 (<em><strong>LIFO</strong></em>) 的顺序添加和移除数据</li>
<li>包含以下内容
<ul>
<li>所有局部变量</li>
<li>函数参数（逆序）</li>
<li>函数调用的返回地址</li>
<li>基于指针的函数调用</li>
</ul>
</li>
<li>stack段自动分配和销毁内存，开发者无法控制stack段内存
<ul>
<li>当函数执行完函数局部变量会从stack中弹出释放，也就是局部变量的作用域范围</li>
</ul>
</li>
</ul>
<p>例如</p>
<pre><code class="language-c">#include 
int sum(int a, int b)
{
    return a + b;
}
float avg(int a, int b)
{
    int s = sum(a, b);
    return (float)s / 2;
}
int main()
{
    int a = 10;
    int b = 20;
    printf(&quot;Average of %d, %d = %f\n&quot;, a, b, avg(a, b));
    return 0;
}
</code></pre>
<p>下图是上述代码对于stack内存段执行时的说明，如图所示，整个如下：</p>
<ul>
<li>当main函数被执行时会被压入stack中</li>
<li>main函数会调用avg函数求平均值，此时avg被压入stack</li>
<li>avg执行sum函数，sum被压入stack</li>
<li>此时正在执行的帧时位于最顶层的，被称为基指针 (<em><strong>base pointer</strong></em>)</li>
<li>栈帧指向stack段顶部，存储stack最顶部地址</li>
<li>s是一个指针保存着sum的位置，即sum函数的结尾，依次类推</li>
</ul>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/Stack-Layout.png" alt="堆栈布局" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：stack layout of C</center>
<center><em>Source：</em>https://hackthedeveloper.com/memory-layout-c-program/</center><br>
<h4 id="栈异常">栈异常</h4>
<p>栈异常常见异常情况有</p>
<ul>
<li>栈溢出 (<em><strong>Stack Overflow</strong></em>)：栈溢出是指超出stack的大小，例如很长的函数调用，造成该错误原因如下：
<ul>
<li>递归函数调用</li>
<li>大数据声明</li>
</ul>
</li>
<li>栈毁坏 (<em><strong>Stack Corruption</strong></em>)：是指stack段中的某些内存位置由于错误的编码而被无意访问，导致内存位置发生变化。由于数据毁坏位置发生在Stack段因此被称为 “<em><strong>Stack Corruption</strong></em>” <sup><a href="#4">[4]</a></sup></li>
</ul>
<p>例如下面代码模拟了一个 SC 异常</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int copy(char *argv)
{   
    char name[10];
    strcpy(name, argv);
}

int main(int argc, char **argv)
{
    copy(argv[1]);
    printf(&quot;Exit\n&quot;);
    return 0;
}
</code></pre>
<p>输出结果为：可以看到当char大小大于10，会覆盖其他stack位置，使程序无法继续执行从而输出“Exit”。</p>
<pre><code class="language-bash">$ gcc .\1.c -o 1.exe
$ .\1.exe testargs
Exit

$ .\1.exe testargs000000000000000000
</code></pre>
<h3 id="stack-vs-heap-supa-href33asup">Stack VS Heap <sup><a href="#3">[3]</a></sup></h3>
<ul>
<li>Stack与Heap都存储与RAM中</li>
<li>Stack自动管理内存，而Heap则需要手动申请和取消</li>
<li>Stack分配速度快（一段程序启动时预先分配好的连续内存），而Heap分配速度较慢（动态分配的非连续内存）</li>
<li>Stack在使用是会出现溢出问题，而Heap可以分配大数据</li>
<li>Stack常见错误为内存溢出，Heap常见错误为内存泄漏</li>
</ul>
<p><em><strong>Stack</strong></em> 和 <em><strong>Heap</strong></em> 的一些常见问题</p>
<ul>
<li>默认Stack大小为多少：Linux中通过 <code>ulimit -s</code> 可以查看</li>
<li>默认的Heap大小为多少：没有默认的Heap大小，在32位操作系统中，每个进程可以看到连续的4GB空间，这个空间没有被映射到物理地址中，而是根据使用情况进行映射，在64位操作系统中，这个空间会更大</li>
<li><strong>stack和heap存放在哪里</strong>？：在虚拟内存中，通过MMU进行映射到物理地址上</li>
<li><strong>如何手动配置heap</strong>？：可以使用 <code>ulimit -v</code> 设置虚拟内存的大小</li>
</ul>
<h2 id="函数调用栈">函数调用栈</h2>
<p>函数调用与栈有不可密切的关系，在一个函数调用过程所需要的信息一般包括以下几个方面：</p>
<ul>
<li>函数返回地址</li>
<li>函数参数</li>
<li>变量</li>
<li>保存的上下文 ：包括在函数调用前后需要保持不变的寄存器。</li>
</ul>
<p>当在调用一个函数时，控制流从调用函数转移到被调用函数。如下列代码在运行时产生了如下几项疑问：</p>
<ul>
<li>函数参数和用于调用函数的变量的区别</li>
<li>为什么具有多个相同名称但位于不同函数中的变量可以共存？</li>
<li>为什么函数doing有一定的限制？</li>
<li>为什么未初始化的局部变量可能包含任何值？</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt; 

int mogrify(int a, int b){
    int tmp = a*4 - b / 3;
    return tmp;                // (mogrify函数返回值)
}
double truly_half(int x){
    double tmp = x / 2.0;                   
    return tmp;
}
int main(){
    int a = 7, y = 17;    
    int mog = mogrify(a,y);              // 调用mogrify
    printf(&quot;Done with mogrify\n&quot;); 

    double x = truly_half(y);            // 调用truly_half
    printf(&quot;Done with truly_half\n&quot;); 

    a = mogrify(x, mog);                  // 第二次调用mogrify

    printf(&quot;Results: %d %lf\n&quot;,mog,x);   // (last_print)
    return 0;                            // (main函数返回)
}
</code></pre>
<p>输出</p>
<pre><code class="language-bash">lila [stack-demo-code]% gcc simple_calls.c
lila [stack-demo-code]% ./a.out
Done with mogrify
Done with truly_half
Results: 23 8.500000
</code></pre>
<h3 id="栈行为-supa-href44asup">栈行为 <sup><a href="#4">[4]</a></sup></h3>
<ul>
<li>
<p><strong>main函数的调用</strong></p>
<p>上述代码调用stack发生的变化，程序从第一行的 main() 函数开始。 main() 有 3 个局部变量：a,y 是int，x 是double。栈的初始状态如下表（其中地址栏为虚构地址）</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Line</th>
<th>Var</th>
<th>Value</th>
<th>Addr</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>main()</td>
<td>12行开始</td>
<td>a</td>
<td>?</td>
<td>1024</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>y</td>
<td>?</td>
<td>1028</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mod</td>
<td>?</td>
<td>1032</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>?</td>
<td>1036</td>
<td></td>
</tr>
</tbody>
</table>
  <center>表1</center><br>
</li>
<li>
<p><strong>main函数的第一行被执行</strong></p>
<p>在运行 main（从第 12 行开始）时，会为所有局部变量分配了栈空间，但没有定义值（随机被初始化）在向下移动时，为局部变量a,y 定义了值。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Line</th>
<th>Var</th>
<th>Value</th>
<th>Addr</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>main()</td>
<td>13行</td>
<td>a</td>
<td>7</td>
<td>1024</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>y</td>
<td>17</td>
<td>1028</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mod</td>
<td>?</td>
<td>1032</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>?</td>
<td>1036</td>
<td></td>
</tr>
</tbody>
</table>
  <center>表2</center><br>
</li>
<li>
<p><strong>mogrify()被调用</strong>
在第13行时产生一个函数调用，main函数被暂停，至函数 mogrify 完成。函数调用使一个栈push到调用栈，如下表所示。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Line</th>
<th>Var</th>
<th>Value</th>
<th>Addr</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>main()</td>
<td>13行</td>
<td>a</td>
<td>7</td>
<td>1024</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>y</td>
<td>17</td>
<td>1028</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mod</td>
<td>?</td>
<td>1032</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>?</td>
<td>1036</td>
<td></td>
</tr>
<tr>
<td>mogrify()</td>
<td>4行</td>
<td>a</td>
<td>7</td>
<td>1044</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>b</td>
<td>17</td>
<td>1048</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>tmp</td>
<td>?</td>
<td>1052</td>
<td></td>
</tr>
</tbody>
</table>
  <center>表3</center><br>
</li>
<li>
<p><strong>mogrify()第一行被执行</strong>
此时从 mogrify 的第一行开始，完成后返回至 main 函数，将在第 13 行继续执行。表3中由于没有执行到tmp，所以还没被分配值。</p>
<p>表4是 完成mogrify 函数执行，局部变量 tmp 被赋值。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Line</th>
<th>Var</th>
<th>Value</th>
<th>Addr</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>main()</td>
<td>13行</td>
<td>a</td>
<td>7</td>
<td>1024</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>y</td>
<td>17</td>
<td>1028</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mod</td>
<td>?</td>
<td>1032</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>?</td>
<td>1036</td>
<td></td>
</tr>
<tr>
<td>mogrify()</td>
<td>5行</td>
<td>a</td>
<td>7</td>
<td>1044</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>b</td>
<td>17</td>
<td>1048</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>tmp</td>
<td>23</td>
<td>1052</td>
<td></td>
</tr>
</tbody>
</table>
  <center>表4</center><br>
</li>
<li>
<p><strong>mogrify()函数返回</strong></p>
<p>mogrify函数返回在这里有两个作用：</p>
<ul>
<li>返回值被存储在调用函数位置：main函数 （第 13 行）变量 mog 中。</li>
<li>弹出栈帧，从调用堆栈中移除。</li>
</ul>
<p>此时状态为表5</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Line</th>
<th>Var</th>
<th>Value</th>
<th>Addr</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>main()</td>
<td>14</td>
<td>a</td>
<td>7</td>
<td>1024</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>y</td>
<td>17</td>
<td>1028</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mod</td>
<td>23</td>
<td>1032</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>?</td>
<td>1036</td>
<td></td>
</tr>
</tbody>
</table>
  <center>表5</center><br>
</li>
<li>
<p><strong>执行Printf()</strong></p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Line</th>
<th>Var</th>
<th>Value</th>
<th>Addr</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>main()</td>
<td>13行</td>
<td>a</td>
<td>7</td>
<td>1024</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>y</td>
<td>17</td>
<td>1028</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mod</td>
<td>?</td>
<td>1032</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>x</td>
<td>?</td>
<td>1036</td>
<td></td>
</tr>
<tr>
<td>printf()</td>
<td>lib call</td>
<td>format</td>
<td>?</td>
<td>1044</td>
<td>pointer</td>
</tr>
</tbody>
</table>
  <center>表6</center><br>
<p>printf()也是作为函数，将另一个栈帧推入栈中，并为其参数和局部变量预留空间。 printf()是一个可变参数的函数。</p>
</li>
<li>
<p><strong>第二次函数调用</strong></p>
<p>从第 16 行起，调用了函数 <code>truly_half</code> 此时会将一个栈帧推入调用栈。此时状态如表5相同</p>
</li>
<li>
<p><strong>调用函数truly_half()</strong></p>
<p>当函数 <code>truly_half()</code> 被调用，对应的栈帧被push到main的栈帧下，表7中所示的地址（局部变量）与之前 <code>mogrify()</code> 函数是相同的地址，这是因为栈中的空间是可重用的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Line</th>
<th style="text-align:center">Var</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main()</td>
<td style="text-align:center">16</td>
<td style="text-align:center">a</td>
<td style="text-align:center">7</td>
<td style="text-align:center">1024</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">y</td>
<td style="text-align:center">17</td>
<td style="text-align:center">1028</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">mog</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1032</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">?</td>
<td style="text-align:center">1036</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>truly_half()</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">x</td>
<td style="text-align:center">17</td>
<td style="text-align:center">1044</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">tmp</td>
<td style="text-align:center">?</td>
<td style="text-align:center">1048</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
  <center>表7</center><br>
</li>
<li>
<p><strong>truly_half()被执行</strong></p>
<p>执行 <code>truly_half</code> 函数的第二行返回计算后的值来赋值给 main 中的局部变量 x，并从调用栈中弹出 <code>truly_half</code> 的栈帧，如表8所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Line</th>
<th style="text-align:center">Var</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main()</td>
<td style="text-align:center">16</td>
<td style="text-align:center">a</td>
<td style="text-align:center">7</td>
<td style="text-align:center">1024</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">y</td>
<td style="text-align:center">17</td>
<td style="text-align:center">1028</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">mog</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1032</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">?</td>
<td style="text-align:center">1036</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>truly_half()</code></td>
<td style="text-align:center">9</td>
<td style="text-align:center">x</td>
<td style="text-align:center">17</td>
<td style="text-align:center">1044</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">tmp</td>
<td style="text-align:center">8.5</td>
<td style="text-align:center">1048</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
  <center>表8</center><br>
</li>
<li>
<p><strong>返回main函数控制流</strong></p>
<p>main函数中会打印这个值，此时内存结构为表8所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Line</th>
<th style="text-align:center">Var</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main()</td>
<td style="text-align:center">17</td>
<td style="text-align:center">a</td>
<td style="text-align:center">7</td>
<td style="text-align:center">1024</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">y</td>
<td style="text-align:center">17</td>
<td style="text-align:center">1028</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">mog</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1032</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">8.5</td>
<td style="text-align:center">1036</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<center>表9</center><br>
</li>
<li>
<p><strong>再次调用函数mogrify()</strong></p>
<p>此时，main函数在第19行暂停，在 <code>mogrify()</code> 第一行开始。</p>
<p>需要注意的一点是 <code>mogrify()</code> 参数类型是int，这里会强制转换 8 字节double 为一个 4 字节的int，小数点被省去。如表10所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Line</th>
<th style="text-align:center">Var</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main()</td>
<td style="text-align:center">19</td>
<td style="text-align:center">a</td>
<td style="text-align:center">7</td>
<td style="text-align:center">1024</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">y</td>
<td style="text-align:center">17</td>
<td style="text-align:center">1028</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">mog</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1032</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">8.5</td>
<td style="text-align:center">1036</td>
<td style="text-align:center">double</td>
</tr>
<tr>
<td style="text-align:center">mogrify()</td>
<td style="text-align:center">4</td>
<td style="text-align:center">a</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1044</td>
<td style="text-align:center">convert to int</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">b</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1048</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">tmp</td>
<td style="text-align:center">?</td>
<td style="text-align:center">1052</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
  <center>表10</center><br>
</li>
<li>
<p><strong>mogrify()被执行后</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Line</th>
<th style="text-align:center">Var</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main()</td>
<td style="text-align:center">19</td>
<td style="text-align:center">a</td>
<td style="text-align:center">7</td>
<td style="text-align:center">1024</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">y</td>
<td style="text-align:center">17</td>
<td style="text-align:center">1028</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">mog</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1032</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">8.5</td>
<td style="text-align:center">1036</td>
<td style="text-align:center">double</td>
</tr>
<tr>
<td style="text-align:center">mogrify()</td>
<td style="text-align:center">5</td>
<td style="text-align:center">a</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1044</td>
<td style="text-align:center">convert to int</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">b</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1048</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">tmp</td>
<td style="text-align:center">25</td>
<td style="text-align:center">1052</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
  <center>表11</center><br>
</li>
<li>
<p><strong>mogrify()被执行后</strong>：
<code>mogrify()</code> 执行完成后将结果分配给 main 函数中的局部变量 a 并弹出栈帧。此时数据如表12所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Line</th>
<th style="text-align:center">Var</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Addr</th>
<th style="text-align:center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main()</td>
<td style="text-align:center">19</td>
<td style="text-align:center">a</td>
<td style="text-align:center">25</td>
<td style="text-align:center">1024</td>
<td style="text-align:center">a的值被覆盖</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">y</td>
<td style="text-align:center">17</td>
<td style="text-align:center">1028</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">mog</td>
<td style="text-align:center">23</td>
<td style="text-align:center">1032</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">8.5</td>
<td style="text-align:center">1036</td>
<td style="text-align:center">double</td>
</tr>
</tbody>
</table>
  <center>表12</center><br>
</li>
</ul>
<p>至此返回最开始的部分，一个函数的过程包含四个部分 (<em><strong>function call stack</strong></em>)</p>
<ul>
<li>函数调用栈</li>
<li>动态分配内存区域 (heap)</li>
<li>存储全局变量的区域</li>
<li>程序允许的实际代码(data text)</li>
</ul>
<p>栈帧(<em><strong>stack frame</strong></em>) 指的是：栈内存中单个函数调用（正在允许的函数）的一部分内存块，（参数和局部变量）。编译器在编译期间确定函数的栈帧大小。栈上的栈帧通常与尚未返回的函数一样多。</p>
<p>栈行为：</p>
<ul>
<li><strong>pushing</strong> ：当函数被调用时，新的帧被推到调用堆栈的 “顶部”。</li>
<li><strong>popping</strong>：当函数执行完成，会将控制权返回给调用它的函数。并将函数关联的帧从栈顶部弹出。</li>
</ul>
<p>溢出：如果在返回之前调用了太多函数（例如递归），程序可能会耗尽栈空间。</p>
<h3 id="关于栈的总结">关于栈的总结</h3>
<h4 id="c语言的执行模型">C语言的执行模型</h4>
<ul>
<li>C 语言是过程式编程，不支持在函数之外编写代码</li>
<li>C 语言的执行模型是指函数调用工作原理（函数调用栈行为分析的）及函数工作原理。</li>
<li>C 语言使用 ”栈“ 数据结构来实现函数与函数调用。</li>
</ul>
<h4 id="关于函数调用栈">关于函数调用栈</h4>
<ul>
<li>
<p>函数调用栈是动态数据结构，用于参数传递、局部变量分配、保存调用的返回地址、保存寄存器以供恢复。</p>
</li>
<li>
<p>栈向下增长，从较高的地址开始，向较低的地址。</p>
</li>
<li>
<p>Push 将栈帧添加到栈，Pop从栈中弹出</p>
</li>
<li>
<p>栈帧的增长在x86架构下是4字节：</p>
<ul>
<li>假设栈指位于1000，此时push一个函数，则该栈指指向996(1000 - 4)</li>
<li>假设此时弹出函数，那么会从996处从栈中弹出，并递增并指向地址1000</li>
</ul>
</li>
</ul>
<h3 id="调用惯例-supa-href66asup">调用惯例 <sup><a href="#6">[6]</a></sup></h3>
<p>调用惯例 (<em><strong>Calling Conventions</strong></em>) 是指函数调用的标准化方法，当在函数调用时例如，如何将参数传递给子程序？子程序可以覆盖寄存器中的值，还是调用者希望保留寄存器内容？子程序中的局部变量应该存储在哪里？函数应该如何返回结果？</p>
<p>C语言中调用惯例在很大程度上使用了基于硬件支持栈。对C中调用惯例的理解就需要对函数执行模型的理解（应确保完全理解 push、pop、call 和 ret 指令的行为）。在此调用约定中，子程序参数在stack上传递。寄存器保存在stack上，子程序使用的局部变量放在stack上的内存中。</p>
<ul>
<li>
<p>cdecl (<em><strong>c declaration</strong></em>)：C/C++默认调用约定，调用时按照从右向左的参数入</p>
<pre><code class="language-c">push arg3  ; rightmost argument
push arg2
push arg1  ; leftmost argument
call f
add esp, 12  ; 12 = 3 arguments each being 4 bytes
</code></pre>
</li>
<li>
<p>fastcall：通过寄存器传递值（从右到左）</p>
</li>
<li>
<p>thiscall：指针类型被存储在寄存器 <code>ecx</code> ，其他类型放置堆栈</p>
</li>
</ul>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="http://webcache.googleusercontent.com/search?q=cache:Nk6EgMoO494J:https://hackthedeveloper.com/memory-layout-c-program/&amp;hl=zh-CN&amp;strip=0&amp;vwsrc=0" target="_blank"
   rel="noopener nofollow noreferrer" >memory layout c program</a></p>
<p><sup id="2">[2]</sup> <a href="https://stackoverflow.com/questions/32418750/stack-and-heap-locations-in-ram" target="_blank"
   rel="noopener nofollow noreferrer" >stack and heap locations in ram</a></p>
<p><sup id="3">[3]</sup> <a href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap?page=1&amp;tab=scoredesc#tab-top" target="_blank"
   rel="noopener nofollow noreferrer" >what and where are the stack and heap</a></p>
<p><sup id="4">[4]</sup> <a href="https://www.go4expert.com/articles/understanding-stack-corruption-c-t27207/" target="_blank"
   rel="noopener nofollow noreferrer" >understanding stack corruption c</a></p>
<p><sup id="5">[5]</sup> <a href="https://cs.gmu.edu/~kauffman/cs222/stack-demo.html" target="_blank"
   rel="noopener nofollow noreferrer" >static</a></p>
<p><sup id="6">[6]</sup> <a href="https://renenyffenegger.ch/notes/development/languages/C-C-plus-plus/calling-convention" target="_blank"
   rel="noopener nofollow noreferrer" >calling convention</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch07 复合类型</title>
      <link>https://www.oomkill.com/2022/09/ch07-composite-type/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch07-composite-type/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>C语言中复合类型 (<em><strong>composite type</strong></em>) 是指用户自定义类型，通常由多种元素组成的类型，其元素被紧密存储在内存中。C语言常见的复合类型有：</p>
<ul>
<li>数组</li>
<li>字符串</li>
<li>结构体</li>
<li>联合类型</li>
</ul>
<h2 id="结构体-supa-href11asup">结构体 <sup><a href="#1">[1]</a></sup></h2>
<p>结构体 (<em><strong>structure</strong></em>) 是指用户定义的数据类型，允许将不同类型的多个元素组合在一起，来创建出更复杂的数据类型，类似于数组，但又区别于数组，数组只能保存同类型的元素，而结构体可以保存不同类型的元素。</p>
<h3 id="定义">定义</h3>
<p>声明结构体的语法如下</p>
<pre><code class="language-c"> struct structureName
 {
     dataType memberVariable1;
     datatype memberVariable2;
     ...
 } variable01, variable02...;
</code></pre>
<p>这里需要注意的一些地方：</p>
<ul>
<li>struct是关键字，structureName定义的新数据类型，variable{}是作为使用 <em><strong>structureName</strong></em> 声明的新变量名</li>
<li>每个成员方法结尾都是 “;&quot; 而不是逗号 ”,&quot;</li>
<li>结构体不能递归</li>
<li>变量可以有多个</li>
</ul>
<p>例如声明一个学生的结构体，而student是作为一个新的数据类型存在</p>
<pre><code class="language-c">struct student
{
    char name[20];
    int roll;
    char gender;
};
</code></pre>
<blockquote>
<p>Notes：在定义（创建）结构体变量前，结构体成员不会占用内存</p>
</blockquote>
<h3 id="声明">声明</h3>
<p>使用结构体声明变量</p>
<p>也可以一次性定义结构体和声明变量</p>
<pre><code class="language-c">struct student
{
    char name[20];
    int roll;
    char gender;
} stu1,stu2;
// 结构体名称可以省略
struct
{
    char name[20];
    int roll;
    char gender;
} stu1,stu2;
</code></pre>
<h3 id="赋值">赋值</h3>
<p>在声明结构体后，student结构体只是自定义数据结构，要使用还需要进行初始化，或者赋值</p>
<pre><code class="language-c">stu1 = {&quot;zhangsan&quot;, 20, 0};
</code></pre>
<p>或者</p>
<pre><code>stu1.name=&quot;zhangsan&quot;;
</code></pre>
<p>或者</p>
<pre><code class="language-c">struct Student
{
    char name[25];
    int age;
    char branch[10];
    char gender;
}stu1 = {&quot;zhangsan&quot;, 20, 0};
</code></pre>
<p>或者使用不同顺序进行初始化</p>
<pre><code class="language-c">stu1 = {.age=20, .gender=0, .name=&quot;zhangsan&quot;};
</code></pre>
<p>也可以仅初始化部分成员，未初始化的成员应该按顺序在后位</p>
<pre><code class="language-c">stu1 = {&quot;zhangsan&quot;};
</code></pre>
<h3 id="访问">访问</h3>
<p>访问结构体可以使用符号 ”.“ 来访问，成员名称==.==成员属性</p>
<pre><code class="language-c#include&lt;stdio.h&gt;">#include&lt;string.h&gt;

struct Student
{
    char name[25];
    int age;
    char branch[10];
    char gender;
};

int main()
{
    struct Student s1;

    s1.age = 18;
    strcpy(s1.name, &quot;Viraaj&quot;);
    printf(&quot;Name of Student 1: %s\n&quot;, s1.name);
    printf(&quot;Age of Student 1: %d\n&quot;, s1.age);
    return 0;
}
</code></pre>
<p>也可以使用scanf() 赋值</p>
<h3 id="结构体运算">结构体运算</h3>
<p>结构体不能够执行算术运算符 <em><strong>+, -, x, ÷</strong></em> ，关系运算符 <em><strong>&lt; &gt; &lt;= &gt;=</strong></em>, 等式运算符，但是可以在两个相同结构体变量的场景下进行赋值运算。</p>
<pre><code class="language-c"> /* 无效的操作 */
st1 + st2
st1 - st2
st1 == st2
st1 != st2 etc.

 /* 在相同类型下的结构体，操作是有效的 */
st1 = st2
</code></pre>
<p>因为C语言没有提供比较运算，所以没法进行结构体比较，需要自行比较结构体成员来比较结构体是否一样</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

 struct student
    {
        char name[20];
        double roll;
        char gender;
        int marks[5];
    }st1,st2;


void main()
{
    struct student st1= { &quot;Alex&quot;, 43, 'M', {76, 78, 56, 98, 92}};
    struct student st2 = { &quot;Max&quot;, 33, 'M', {87, 84, 82, 96, 78}};

    if( strcmp(st1.name,st2.name) == 0 &amp;&amp; st1.roll == st2.roll)
        printf(&quot;Both are the records of the same student.\n&quot;);
    else printf(&quot;Different records, different students.\n&quot;);

     /* Copiying the structure variable */
    st2 = st1;

    if( strcmp(st1.name,st2.name) == 0 &amp;&amp; st1.roll == st2.roll)
        printf(&quot;\nBoth are the records of the same student.\n&quot;);
    else printf(&quot;\nDifferent records, different students.\n&quot;);
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-c">Different records, different students.

Both are the records of the same student.
</code></pre>
<h3 id="结构体数组">结构体数组</h3>
<p>结构体数组是指数组元素是结构体，例如下面声明一个类型为student的数组</p>
<pre><code class="language-c">struct student
{
    char name[20];
    double roll;
    char gender;
    int marks[5];
};

struct student stu[4];
</code></pre>
<p>初始化和访问可以通过循环进行</p>
<pre><code class="language-c">for (int i = 0; i &lt; 4; i++)
{
    printf(&quot;Enter name:\n&quot;);
    scanf(&quot;%s&quot;,&amp;stu[i].name);
    printf(&quot;Enter roll:\n&quot;);
    scanf(&quot;%d&quot;,&amp;stu[i].roll);
    printf(&quot;Enter gender:\n&quot;);
    scanf(&quot; %c&quot;,&amp;stu[i].gender);

    for( int j = 0; j &lt; 5; j++)
    {
        printf(&quot;Enter marks of %dth subject:\n&quot;,j);
        scanf(&quot;%d&quot;,&amp;stu[i].marks[j]);
    }

    printf(&quot;\n-------------------\n\n&quot;);
}

/* Finding the average marks and printing it */

for(int i = 0; i &lt; 4; i++)
{
    float sum = 0;
    for( int j = 0; j &lt; 5; j++)
    {
        sum += stu[i].marks[j];
    }
    printf(&quot;Name: %s\nAverage Marks = %.2f\n\n&quot;, stu[i].name, sum / (sizeof(stu[i].marks) / sizeof(stu[i].marks[0])));
}
</code></pre>
<p>将代码整合为一起</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct student
{
    char name[20];
    double roll;
    char gender;
    int marks[5];
};

struct student stu[4];

void main()
{
    for (int i = 0; i &lt; 4; i++)
    {
        printf(&quot;Enter name:\n&quot;);
        scanf(&quot;%s&quot;,&amp;stu[i].name);
        printf(&quot;Enter roll:\n&quot;);
        scanf(&quot;%d&quot;,&amp;stu[i].roll);
        printf(&quot;Enter gender:\n&quot;);
        scanf(&quot; %c&quot;,&amp;stu[i].gender);

        for( int j = 0; j &lt; 5; j++)
        {
            printf(&quot;Enter marks of %dth subject:\n&quot;,j);
            scanf(&quot;%d&quot;,&amp;stu[i].marks[j]);
        }

        printf(&quot;\n-------------------\n\n&quot;);
    }

    /* Finding the average marks and printing it */

	for(int i = 0; i &lt; 4; i++)
    {
        float sum = 0;
        for( int j = 0; j &lt; 5; j++)
        {
            sum += stu[i].marks[j];
        }
        printf(&quot;Name: %s\nAverage Marks = %.2f\n\n&quot;, stu[i].name, sum / (sizeof(stu[i].marks) / sizeof(stu[i].marks[0])));
    }
}
</code></pre>
<h3 id="结构体嵌套结构体">结构体嵌套结构体</h3>
<p>嵌套结构体表示，结构体的成员是另外一个结构体</p>
<pre><code class="language-c">struct date
{
    int date;
    int month;
    int year;
};

struct student
{
    char name[20];
    int roll;
    char gender;
    int marks[5];
    struct date birthday;
};
</code></pre>
<p>其定义语法为：<code>struct &lt;other struct&gt; &lt;member_name&gt;;</code> 这里 <code>birthday</code> 是名为data类型结构体</p>
<blockquote>
<p>Notes：结构体内部不能嵌套自己</p>
</blockquote>
<p>访问嵌套结构体和正常结构体访问一样使用符号，成员名称==.==成员属性==.==成员属性</p>
<pre><code class="language-c">stu1.birthday.date
stu1.birthday.month
stu1.birthday.year
stu1.name
</code></pre>
<h3 id="结构体内存分配">结构体内存分配</h3>
<p>结构体声明后是不占用内存，只有被初始化后才占用内存，结构体内每个成员会被分配到连续的内存内，sizeof()的大小是每个元素所占用的大小。</p>
<p>示例代码为一个student的结构体，有四个成员，name为20 bytes的字符串，roll是4字节的int类型，gender是1字节的char，marks为5个元素的数组，那么这个结构体的总大小应该为 $20+4+1+5\times4$</p>
<pre><code class="language-c">struct student
{
    char name[20];
    int roll;
    char gender;
    int marks[5];
} stu1;
</code></pre>
<p>将上述代码整合为</p>
<pre><code class="language-c">void main()
{
    printf(&quot;Sum of the size of members = %I64d bytes\n&quot;, sizeof(stu1.name) + sizeof(stu1.roll) + sizeof(stu1.gender) + sizeof(stu1.marks));
    printf(&quot;Using sizeof() operator = %I64d bytes\n&quot;,sizeof(stu1));
}

// 输出结果为
Sum of the size of members = 45 bytes
Using sizeof() operator = 48 bytes
</code></pre>
<p>可以看到两个结果并不相等，可以看出实际被多分配了3个字节，需要知道为什么被多分配需要先打印他们的地址</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct student
{
    char name[20];
    int roll;
    char gender;
    int marks[5];
} stu1;

void main()
{
    printf(&quot;Address of member name = %d\n&quot;, &amp;stu1.name);
    printf(&quot;Address of member roll = %d\n&quot;, &amp;stu1.roll);
    printf(&quot;Address of member gender = %d\n&quot;, &amp;stu1.gender);
    printf(&quot;Address of member marks = %d\n&quot;, &amp;stu1.marks);
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-bash">Address of member name = 4225408
Address of member roll = 4225428
Address of member gender = 4225432
Address of member marks = 4225436
</code></pre>
<p>可以看到char类型占用一个字节，而接下来的成员 marks 却是从4225436开始的，而不是4225433。这就需要引入下面的概念数据对齐 (<em><strong>Data alignment</strong></em>)</p>
<h4 id="数据对齐">数据对齐</h4>
<p>数据对齐是指处理器在数据对齐时访问效率最高，这将代表了数据存储在内存中的大小的倍数。而现代计算机字长通常为4 字节（32 位操作胸痛）或 8 字节（64 位操作系统）的字长。</p>
<p>对于一个int类型的变量，占用的资产时4字节，此时符合处理器读取机制，因为符合计算机字长长度。而作为char类型，占用一个字节。如果不做数据对齐操作，就会出现如下图出现的问题，数据在存储时读取的字长永远是多一个步骤的。</p>
<p>下图是一个错位的数据，粉红代表char类型，蓝色代表short类型，绿色代表int类型，如果不进行对齐，再继续存储int时，在读取数据时一个字长位移都将不足以读取一个int类型，这就需要进行两次数据访问才能读取一个int类型，也就是花费了两倍的时间</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220930234237287.png" alt="image-20220930234237287" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：Misaligned memory</center>
<center><em>Source：</em>https://hps.vi4io.org/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf</center><br>
<p>出于上述原因才有了数据对齐的概念，下图所示的对齐模式被称为自然对齐 (<em><strong>naturally aligned</strong></em>)</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220930234625752.png" alt="image-20220930234625752" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：Properly aligned memory using padding</center>
<center><em>Source：</em>https://hps.vi4io.org/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf</center><br>
<h4 id="内容填充">内容填充</h4>
<p>在对齐时所插入的额外字节数的部分被称为填充 (<em><strong>padding</strong></em>)，在上图中，黑色部分为填充的部分，而在上述代码示例中所填充的部分为3字节，而4225433位的内存地址存储int类型（marks[0]的地址）不是4的倍数。</p>
<p>下表说明了需要对其的数据类型规则</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">占字节数大小</th>
<th style="text-align:left">地址倍数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1的倍数</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2的倍数</td>
</tr>
<tr>
<td style="text-align:left">int, float</td>
<td style="text-align:left">4</td>
<td style="text-align:left">4的倍数</td>
</tr>
<tr>
<td style="text-align:left">double, long, *(pointer)</td>
<td style="text-align:left">8</td>
<td style="text-align:left">8的倍数</td>
</tr>
<tr>
<td style="text-align:left">long double</td>
<td style="text-align:left">16</td>
<td style="text-align:left">16的倍数</td>
</tr>
</tbody>
</table>
<p>另外一个示例，应该是多少？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct student
{
    int i1;
    double d1;
    char c1;
} stu1;

void main()
{   
    // long long int a, b, c;
    // a = 1, b = 30000000000009, c = 5; 
    // %I64d是微软风格的%lld，为了避免大于4字节的类型被省略，而输出异常，兼容%d
    // printf(&quot;%I64d %I64d %I64d\n&quot;, a, b, c);
    // rintf(&quot;%d %d %d\n&quot;, a, b, c);
    printf(&quot;size = %I64d bytes\n&quot;,sizeof(stu1));
}
</code></pre>
<p>由于 <code>i1</code> 为int类型4字节，<code>d1</code> 为 double类型8字节，<code>c1</code> 为char类型1字节 ，那么 $4+8+1=13$ 被填充后应该是16字节，那么看下输出结果</p>
<pre><code>size = 24 bytes
</code></pre>
<p>实际上在C语言中结构体的数据类型对齐不是这么计算的，实际上结构体数据对齐条件是根据结构体内最大的元素进行调整 <sup><a href="#2">[2]</a></sup>，例如这里最大元素为8，那么对齐标准就是补足8字节  <code>i1</code> 需要补4，<code>c1</code> 需要补7</p>
<p>通过调整结构体顺序可以减少填充的大小，例如下列代码，其实际大小为1 byte + 8 bytes + 1 bytes = 10 bytes，而实际大小为24bytes，因为double将影响填充的大小</p>
<pre><code>struct Foo {
    char x; // 1 byte
    double y // 8 bytes
    char z; // 1 bytes
};
</code></pre>
<p>而通过按照类型的由小到大的顺序进行定义成员，可以减少填充的次数与大小，这样1+1+(6)+8=16</p>
<pre><code>struct Foo {
    char x; // 1 byte
    char z; // 1 bytes
    double y // 8 bytes
};
</code></pre>
<p>为此得出的结论为，对结构体成员重新排序可以提高内存效率</p>
<h4 id="数据打包">数据打包</h4>
<p>数据打包 (<em><strong>Packing</strong></em>) 是指强制编译器不进行数据填充，与数据填充是相反的作用</p>
<p>在windows上使用宏定义 <code>#pragma pack(1)</code> 来指定对齐方式，也可以使用 <code>__attribute__((packed)) </code> 指定一个结构体补进行填充。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
// #pragma pack(1)
struct student
{
    int i1;
    double d1;
    char c1;
} stu1;

struct Foo {
    char x; // 1 byte
    char z; // 1 bytes
    double y // 8 bytes
} __attribute__((packed)) f1;

void main()
{   
    printf(&quot;size = %I64d bytes\n&quot;,sizeof(stu1));
    printf(&quot;size = %I64d bytes\n&quot;,sizeof(f1));
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-bash">size = 24 bytes
size = 10 bytes
</code></pre>
<p>还可以指定特定的大小进行填充，例如</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
// #pragma pack(1)
struct student
{
    int i1;
    double d1;
    char c1;
} stu1;

struct Foo {
    char x; // 1 byte
    char z; // 1 bytes
    double y // 8 bytes
} __attribute__((packed, aligned(4))) f1;

void main()
{   
    printf(&quot;size = %I64d bytes\n&quot;,sizeof(stu1));
    printf(&quot;size = %I64d bytes\n&quot;,sizeof(f1));
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-c">size = 24 bytes
size = 12 bytes
</code></pre>
<h3 id="指针结构体">指针结构体</h3>
<p>这里包含指针作为结构体成员和指针指向结构体</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct student
{
    char *name;
    int *roll;
    char gender;
    int marks[5];
};

void main()
{  
    int alexRoll = 44;
    struct student stu1 = { &quot;Alex&quot;, &amp;alexRoll, 'M', { 76, 78, 56, 98, 92 }};
    struct student *stu2 = &amp;stu1;
    printf(&quot;stu1 Name is %s\n&quot;, stu1.name);
    
    // 无效的访问
    // printf(&quot;stu1 roll is %s\n&quot;, stu1.(*roll)); 
    
    // 错误的访问，输出的地址
    printf(&quot;stu1 roll is %d\n&quot;, stu1.roll);
    
    // 正确的访问方式
    printf(&quot;stu1 roll is %d\n&quot;, *(stu1.roll));
    
    // 访问指针结构体成员的方法
    printf(&quot;stu2 Name is %s\n&quot;, stu2-&gt;name);
    printf(&quot;stu2 Name is %s\n&quot;, (*stu2).name);

}
</code></pre>
<p>总结：</p>
<ul>
<li>
<p><code>.</code> 运算符优先于 <code>*</code> 运算符，需要加括号改变优先级</p>
</li>
<li>
<p>如果成员属性是指针类型，访问其内容应先解引用成员 <code>*(stu1.roll)</code></p>
</li>
<li>
<p>如果指针是结构体需要解引用结构体 <code>(*stu2).name</code></p>
</li>
<li>
<p>指针类型访问成员的特殊方法为 <code>-&gt;</code></p>
</li>
</ul>
<h3 id="结构体数组-1">结构体数组</h3>
<p>结构体也可以作为数组的形式，每个数组元素为一个结构体。作为数组结构体时，指针类型需要解引用或者使用 <code>-&gt;</code> 来访问。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct student
{
    char *name;
    int *roll;
    char gender;
    int marks[5];
};

void main()
{  
    int alexRoll = 44;
    struct student stu1 = { &quot;Alex&quot;, &amp;alexRoll, 'M', { 76, 78, 56, 98, 92 }};
    
    struct student stu[10];
    struct student *stuPtr = stu;
    struct student (*stuPtr)[10] = &amp;stu;
    
    printf(&quot;name %s\n&quot;, stuPtr[10]-&gt;name);
    printf(&quot;name %s\n&quot;, (*stuPtr)[10].name);
}   
</code></pre>
<h3 id="结构体函数">结构体函数</h3>
<p>在C语言中，函数不能作为结构体成员，但是函数指针可以，使用 <code>.</code> 可以调用指针函数成员</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct example
{
    int i;
    void (*ptrMessage)(int i);
};

void message(int);

void message(int i)
{
    printf(&quot;Hello, I'm a member of a structure. This structure also has an integer with value %d&quot;, i);
}

void main()
{
    struct example eg1 = {6, message};
    eg1.ptrMessage(eg1.i);
}
</code></pre>
<h3 id="结构体作为函数参数">结构体作为函数参数</h3>
<p>当函数参数过多时，传递大量参数效率很低，可以将结构体作为参数传递给函数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct student {
    char name[20];
    int roll;
    char gender;
    int marks[5];
};
void display(struct student a)
{
    printf(&quot;Name: %s\n&quot;, a.name);
    printf(&quot;Roll: %d\n&quot;, a.roll);
    printf(&quot;Gender: %c\n&quot;, a.gender);

    for(int i = 0; i &lt; 5; i++)
        printf(&quot;Marks in %dth subject: %d\n&quot;,i,a.marks[i]);
}
void main()
{
    struct student stu1 = {&quot;Alex&quot;, 43, 'M', {76, 98, 68, 87, 93}};
    display(stu1);
}
</code></pre>
<p>如果结构体比较复杂，传递副本参数效率不高，也可以传递指针结构体作为函数参数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct student {
    char name[20];
    int roll;
    char gender;
    int marks[5];
};
void display(struct student *a)
{
    printf(&quot;Name: %s\n&quot;, a-&gt;name);
    printf(&quot;Roll: %d\n&quot;, a-&gt;roll);
    printf(&quot;Gender: %c\n&quot;, a-&gt;gender);

    for(int i = 0; i &lt; 5; i++)
        printf(&quot;Marks in %dth subject: %d\n&quot;,i,a-&gt;marks[i]);
}
void main()
{
    struct student stu1 = {&quot;Alex&quot;, 43, 'M', {76, 98, 68, 87, 93}};
    struct student *stuPtr = &amp;stu1;
    display(stuPtr);
}
</code></pre>
<h3 id="结构体作为函数返回值">结构体作为函数返回值</h3>
<p>结构体可以作为函数的返回值</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
struct student {
    char name[20];
    int roll;
    char gender;
    int marks[5];
};

struct student increaseBy5(struct student p)
{
    for( int i =0; i &lt; 5; i++)
        if(p.marks[i] + 5 &lt;= 100)
        {
            p.marks[i]+=5;
        }
    return p;
}

void main()
{
    struct student stu1 = {&quot;Alex&quot;, 43, 'M', {76, 98, 68, 87, 93}};
    stu1 = increaseBy5(stu1);
    
    printf(&quot;Name: %s\n&quot;, stu1.name);
    printf(&quot;Roll: %d\n&quot;, stu1.roll);
    printf(&quot;Gender: %c\n&quot;, stu1.gender);

    for(int i = 0; i &lt; 5; i++)
        printf(&quot;Marks in %dth subject: %d\n&quot;,i,stu1.marks[i]);
}
</code></pre>
<p>当然如果结构体交复杂，也可以用结构体指针作为返回值</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct student {
    char name[20];
    int roll;
    char gender;
    int marks[5];
};

struct student* increaseBy5(struct student *p)
{   
    for( int i =0; i &lt; 5; i++)
        if(p-&gt;marks[i] + 5 &lt;= 100)
        {
            p-&gt;marks[i]+=5;
        }
    return p;
}

void main()
{	
    struct student stu1 = {&quot;Alex&quot;, 43, 'M', {76, 98, 68, 87, 93}};
    struct student *stuptr = (struct student *) malloc(sizeof(struct student));
    stuptr = &amp;stu1;
    stuptr = increaseBy5(stuptr);
    
    printf(&quot;Name: %s\n&quot;, stuptr-&gt;name);
    printf(&quot;Roll: %d\n&quot;, stuptr-&gt;roll);
    printf(&quot;Gender: %c\n&quot;, stuptr-&gt;gender);

    for(int i = 0; i &lt; 5; i++)
        printf(&quot;Marks in %dth subject: %d\n&quot;,i,stuptr-&gt;marks[i]);
}
</code></pre>
<h3 id="typedef">typedef</h3>
<p><em><strong>typedef</strong></em> 是C语言中的关键字，功能是为现有数据类型分配别名，例如为long类型声明一个别名</p>
<pre><code class="language-c">typedef long int64
</code></pre>
<p>也可以在结构体中使用</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct employee
{
    char *name;
    int salary;
} emp;

typedef struct employee1
{
    char *name;
    int salary;
}emp1;

void main()
{	
    // 不使用typedef定义的结构体,在使用时需要加关键字struct
    struct employee e1;
    e1.salary=10;
    e1.name=&quot;zhangsan&quot;;
	// 使用typedef定义结构体,在使用时，可以直接使用结构体名称
    emp1 e2;
    e2.salary=100;
    e2.name=&quot;lisi&quot;;
    printf(&quot;name1: %s\n&quot; ,e1.name);
    printf(&quot;salary1: %d\n&quot; ,e1.salary);
    printf(&quot;name2: %d\n&quot; ,*(e2.name));
    printf(&quot;salary2: %d\n&quot; ,e2.salary);
}
</code></pre>
<p>typedef主要功能：</p>
<ul>
<li>
<p>别名，简化结构体类型struct关键字</p>
</li>
<li>
<p>区分数据类型</p>
<ul>
<li>
<pre><code class="language-c">  char * p1,p2; // 声明两个变量 p1为char指针类型，p2为char类型
</code></pre>
</li>
<li>
<pre><code class="language-c">  typedef char* charPtr;
  charPtr p1,p2; // 声明两个变量为char*类型
</code></pre>
</li>
</ul>
</li>
<li>
<p>提高代码的可移植性</p>
<ul>
<li>
<pre><code class="language-c">  typedef long long int64; 
  typedef long long int32; // 在大量别名情况下无需每个替换
  int64 a=10;
  int64 b=20;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="union">union</h2>
<p>union是类似于结构体的一种用户自定义类型，与结构体最大的区别是，结构体是存储一系列元素的联合体，而union是多个成员，仅有一个元素能被存储。</p>
<h3 id="定义-1">定义</h3>
<p>定义union语法：</p>
<ul>
<li><strong>union</strong> &lt;<em>attr-spec-seq</em>(optional)&gt; &lt;<em>name</em>(optional)&gt; <strong>{</strong> <em>struct-declaration-list</em> <strong>}</strong> &lt;union var,&hellip;&gt;</li>
<li><strong>union</strong> &lt;<em>attr-spec-seq</em>(optional)&gt; <em>name</em></li>
</ul>
<pre><code class="language-c">union car
{
  char name[50];
  int price;
};
</code></pre>
<p>定义union不会被分配内存，如果要分配内存则需要创建变量使用它</p>
<h3 id="访问-1">访问</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
union Job {
   float salary;
   int workerNo;
} j;

int main() {
   j.salary = 12.3;

   // 当对j.workerNo成员分配了值
   // j.salary持有的12.3将不再拥有
   j.workerNo = 100;

   printf(&quot;Salary = %.1f\n&quot;, j.salary);
   printf(&quot;Number of workers = %d&quot;, j.workerNo);
   return 0;
}
</code></pre>
<p>总结</p>
<ul>
<li>union是用户自定义的数据类型</li>
<li>union中成员都是相同的内存地址</li>
<li>union保存的内容仅为最近一次赋值的元素的值（哪个元素被赋值，哪个元素被激活）</li>
<li>union大小为其占用空间最大的那个成员</li>
</ul>
<h2 id="enum">enum</h2>
<p>枚举(<em><strong>enumeration</strong></em>)是C语言中特殊的数据类型，通常是包含具有共同性数据的集合，例如性别，男，女</p>
<pre><code class="language-c">enum gender {
    MALE,
    FEMALE
};
</code></pre>
<h3 id="声明-1">声明</h3>
<p>常用的有两种方式来使用枚举类型</p>
<pre><code class="language-c">enum textEditor {
    BOLD,
    ITALIC,
    UNDERLINE
} feature;
</code></pre>
<p>与</p>
<pre><code class="language-c">enum textEditor {
    BOLD,
    ITALIC,
    UNDERLINE
};
int main() {
    enum textEditor feature;
    return 0;
}
</code></pre>
<h3 id="赋值-1">赋值</h3>
<pre><code class="language-c">enum textEditor {
    BOLD,
    ITALIC,
    UNDERLINE
} feature;

int main() {
    // Initializing enum variable
    enum textEditor feature = BOLD;
    printf(&quot;Selected feature is %d\n&quot;, feature);

    // Initializing enum with integer equivalent
    feature = 5;
    printf(&quot;Selected feature is %d\n&quot;, feature);

    return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>枚举是整数常量类型</li>
<li>枚举包含的元素即为对应变量可以拥有的值</li>
<li>因为是整数常量，可以转换为char，bool等</li>
<li>枚举的元素结尾是逗号，最后一个元素没有符号；结构体的元素结尾为分号</li>
</ul>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.freecodecamp.org/news/structured-data-types-in-c-explained" target="_blank"
   rel="noopener nofollow noreferrer" >structured data types in c explained</a></p>
<p><sup id="2">[2]</sup> <a href="https://hps.vi4io.org/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf" target="_blank"
   rel="noopener nofollow noreferrer" >Alignment in C</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch08 文件处理</title>
      <link>https://www.oomkill.com/2022/09/ch08-file-handling/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/09/ch08-file-handling/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="文件类型">文件类型</h2>
<p>文件是指以字节的形式存储的数据源，使用C语言将文件数据以输出输出的形式处理叫做文件处理。</p>
<p>文件在C语言中以两种形式存在：</p>
<ul>
<li>文本文件：文本文件是简单的文件类型，这些文件内容以 ASCII 字符格式存储信息。</li>
<li>二进制文件：二进制文件以 0 和 1 的二进制格式存储数据，不是人类可读的文件</li>
</ul>
<h2 id="文件指针">文件指针</h2>
<p>文件指针 (<code>FILE</code>) 是一种数据类型，是被定义在 <code>stdio.h</code> 中的一种结构体，包含了文件的一些信息</p>
<pre><code class="language-c">typedef struct
{
    // fill/empty level of buffer
    int    level;
    // File status flags
    unsigned flags;
    // File descripter
    char fd;
    // ungetc char if no buffer
    unsigned char hold;
    // buffer size
    int bsize;
    // data transfer buffer
    unsigned char *buffer;
    // Current active pointer
    unsigned char *curp;
    //Temporary file indicator
    unsigned istemp;
    //Used for validity checking
    short token;
} FILE; // This is FILE object    
</code></pre>
<p>文件指针通常被用于处理正在访问的文件，<code>fopen()</code> 是用于打开文件并返回文件的 FILE 指针，而后通过文件只恨进行I/O操作。<code>fopen()</code> 会发生下列事件：</p>
<ul>
<li>文件的内容被加载到缓冲区（操作系统层面）</li>
<li>在内存中创建 FILE 的数据结构体，并返回这个结构体指针</li>
</ul>
<h2 id="文件处理函数">文件处理函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>fopen()</td>
<td>打开现有文件或新文件</td>
</tr>
<tr>
<td>fprintf()</td>
<td>将数据写入打开的文件</td>
</tr>
<tr>
<td>fscanf()</td>
<td>读取文件中数据</td>
</tr>
<tr>
<td>fputc()</td>
<td>向文件写入一个字符</td>
</tr>
<tr>
<td>fgetc()</td>
<td>从文件中读取一个字符</td>
</tr>
<tr>
<td>fclose()</td>
<td>关闭打开的文件</td>
</tr>
<tr>
<td>fseek()</td>
<td>设置文件指针的位置</td>
</tr>
<tr>
<td>fputw()</td>
<td>将一个整数写入到文件</td>
</tr>
<tr>
<td>fgetw()</td>
<td>从文件中读取一个整数</td>
</tr>
<tr>
<td>ftell()</td>
<td>文件指针的当前位置</td>
</tr>
<tr>
<td>rewind()</td>
<td>设置文件指针位置为初始位置</td>
</tr>
<tr>
<td>fread()</td>
<td>读取文件内容（二进制与文本）</td>
</tr>
<tr>
<td>fwrite()</td>
<td>向文件写入内容（二进制与文本）</td>
</tr>
<tr>
<td>feof()</td>
<td>是否到达文件结尾<br>非0 True 到达文件结尾<br>0 False 没有到达文件结尾</td>
</tr>
</tbody>
</table>
<h3 id="fscanf-vs-fgets">fscanf VS fgets</h3>
<ul>
<li>fscanf读取的是字符，fgets读取的是字符串</li>
<li>fgets读取换行符结束，fscanf读取到空白就结束，不用换行符</li>
<li>fgets以行为单位，fscanf以字符为单位（参数2匹配的模式）</li>
<li>fscanf每次会判断是否匹配，如不匹配则提前退出读取</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{	
    FILE *fp;
    fp = fopen(&quot;./k8s restart.txt&quot;, &quot;r&quot;);
    if (fp == NULL) {
        printf(&quot;Error! opening file&quot;);
        exit(1);
    }
    char buf[1024];

    while( feof(fp) == 0 ){
        printf(&quot;i=%d\n&quot;, i);
        
        // fscanf(fp, &quot;%s&quot;, &amp;buf);
        fgets(buf, 1024, fp);
        printf(&quot;%s\n&quot;, buf);
    }
    fclose(fp);
}
</code></pre>
<h3 id="文件的打开模式">文件的打开模式</h3>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
<th>当文件不存在时处理方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>只读方式打开文件</td>
<td>当文件路径不存在时fopen()返回NULL</td>
</tr>
<tr>
<td>rb</td>
<td>以只读方式打开二进制文件</td>
<td>当文件路径不存在时fopen()返回NULL</td>
</tr>
<tr>
<td>w</td>
<td>写入方式</td>
<td>如果文件存在则覆盖，如果不存在则创建新文件</td>
</tr>
<tr>
<td>wb</td>
<td>写入方式（二进制模式）</td>
<td>如果文件存在则覆盖，如果不存在则创建新文件</td>
</tr>
<tr>
<td>a</td>
<td>打开文件并向结尾追加内容</td>
<td>如果文件路径不存在则创建新文件</td>
</tr>
<tr>
<td>ab</td>
<td>打开文件并向结尾追加内容（二进制模式）</td>
<td>如果文件路径不存在则创建新文件</td>
</tr>
<tr>
<td>r+</td>
<td>读写方式打开文件</td>
<td>当文件路径不存在时fopen()返回NULL</td>
</tr>
<tr>
<td>rb+</td>
<td>读写方式打开文件（二进制模式）</td>
<td>当文件路径不存在时fopen()返回NULL</td>
</tr>
<tr>
<td>w+</td>
<td>读写方式打开文件</td>
<td>如果文件存在则覆盖，如果不存在则创建新文件</td>
</tr>
<tr>
<td>wb+</td>
<td>读写方式打开文件（二进制模式）</td>
<td>如果文件存在则覆盖，如果不存在则创建新文件</td>
</tr>
<tr>
<td>a+</td>
<td>追加和读取</td>
<td>如果文件路径不存在则创建新文件</td>
</tr>
<tr>
<td>ab+</td>
<td>追加和读取（二进制模式）</td>
<td>如果文件路径不存在则创建新文件</td>
</tr>
</tbody>
</table>
<h2 id="文件操作的步骤">文件操作的步骤</h2>
<ol>
<li>
<p>打开文件 <code>fopen()</code> （ FILE *Pointer）</p>
</li>
<li>
<p>读写文件 <code>fputc</code> , <code>fgetc</code>, <code>fputs</code>, <code>fgets</code>, <code>fread</code>, <code>fwrite</code> &hellip;.</p>
</li>
<li>
<p>关闭文件 fclose()</p>
</li>
</ol>
<h3 id="打开文件">打开文件</h3>
<pre><code class="language-c">FILE * ptr
ptr = fopen(&quot;file dir&quot;,&quot;mode&quot;);
</code></pre>
<p>例如</p>
<pre><code class="language-c">fopen(&quot;/etc/hosts&quot;,&quot;rb&quot;);
</code></pre>
<h3 id="关闭文件">关闭文件</h3>
<pre><code class="language-c">fclose(fptr);
</code></pre>
<h3 id="读写文件">读/写文件</h3>
<p>向文本文件中写入数据</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
   int num;
   FILE *fptr; 
   fptr = fopen(&quot;~/1.txt&quot;,&quot;w&quot;);

   if(fptr == NULL)
   {
      printf(&quot;Error!&quot;);   
      exit(1);             
   }

   printf(&quot;Enter num: &quot;);
   scanf(&quot;%d&quot;,&amp;num);
   
   fputc(str[i], fptr); // fputc向文件写入数据
   fputs(&quot;fputs向文件写入数据\n&quot;, fptr);
   fprintf(fptr, &quot;fprintf向文件写入数据\n&quot;);
   fclose(fptr);

   return 0;
}
</code></pre>
<p>从文本文件中读取内容</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
   int num;
   FILE *fptr;

   if ((fptr = fopen(&quot;~/1.txt&quot;,&quot;r&quot;)) == NULL){
       printf(&quot;Error! opening file&quot;);
       exit(1);
   }

   fscanf(fptr,&quot;%d&quot;, &amp;num);
   printf(&quot;Value of n=%d&quot;, num);
   fclose(fptr); 
  
   return 0;
}
</code></pre>
<h3 id="写入二进制文件">写入二进制文件</h3>
<p>二进制文件的读取使用，<code>fwrite()</code>/<code>fread()</code>函数，通常情况下二进制文件读取没有意义，只是做类似文件拷贝的操作。</p>
<p><code>fwrite(addressData, sizeData, numbersData, pointerToFile);</code></p>
<ul>
<li>addressData：写入磁盘的数据的地址</li>
<li>sizeData：要写入磁盘的数据大小</li>
<li>numbersData：写出的数据个数</li>
<li>pointerToFile：FILE指针</li>
<li>return：
<ul>
<li>成功：参数3的大小</li>
<li>失败：0</li>
</ul>
</li>
</ul>
<blockquote>
<p>Notes：通常参数2为1，参数3为写入的总大小。 参2 * 参3 = 写入的总大小</p>
</blockquote>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct threeNum
{
   int n1, n2, n3;
};

int main()
{
   int n;
   struct threeNum num;
   FILE *fptr;

   if ((fptr = fopen(&quot;C:\\program.bin&quot;,&quot;wb&quot;)) == NULL){
       printf(&quot;Error! opening file&quot;);

       // Program exits if the file pointer returns NULL.
       exit(1);
   }

   for(n = 1; n &lt; 5; ++n)
   {
      num.n1 = n;
      num.n2 = 5*n;
      num.n3 = 5*n + 1;
      fwrite(&amp;num, sizeof(struct threeNum), 1, fptr); 
   }
   fclose(fptr); 
  
   return 0;
}
</code></pre>
<h3 id="从二进制文件读取数据">从二进制文件读取数据</h3>
<p><code>fread(addressData, sizeData, numbersData, pointerToFile);</code>：</p>
<ul>
<li>addressData：读取到的数据存储的位置</li>
<li>sizeData：一次读取的字节数</li>
<li>numbersData：读取次数</li>
<li>pointerToFile：文件指针</li>
<li>return：
<ul>
<li>成功：参数3的大小</li>
<li>失败：0</li>
<li>到达文件结尾：feof(fp)为真</li>
</ul>
</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct threeNum
{
   int n1, n2, n3;
};

int main()
{
   int n;
   struct threeNum num;
   FILE *fptr;

   if ((fptr = fopen(&quot;C:\\program.bin&quot;,&quot;rb&quot;)) == NULL){
       printf(&quot;Error! opening file&quot;);

       // Program exits if the file pointer returns NULL.
       exit(1);
   }

   for(n = 1; n &lt; 5; ++n)
   {
      fread(&amp;num, sizeof(struct threeNum), 1, fptr); 
      printf(&quot;n1: %d\tn2: %d\tn3: %d\n&quot;, num.n1, num.n2, num.n3);
   }
   fclose(fptr); 
  
   return 0;
}
</code></pre>
<h2 id="缓冲区">缓冲区</h2>
<p>缓冲区是操作系统的内存空间中的一部分。操作系统在内存空间中预留了一定的存储空间，在输入或输出达到一定量后进行I/O操作，这部分空间就叫做缓冲区。</p>
<p>程序在启动时，预定义了三种缓冲区，不需要显式开启：</p>
<ul>
<li>标准输入 (<em><strong>stdin</strong></em>)：</li>
<li>标准输出 (<em><strong>stdout</strong></em>)：</li>
<li>标准错误 (<em><strong>stderr</strong></em>)：标准错误是一个无缓冲</li>
</ul>
<p>stdio.h 库中提供了三种缓冲模式 <sup><a href="#1">[1]</a></sup>：</p>
<ul>
<li>无缓冲 (<em><strong>unbuffered</strong></em>)：写入到无缓冲的数据会立即被写入到文件</li>
<li>行缓冲 (<em><strong>line buffered</strong></em>)：当遇到换行符，此类缓冲区内容会被写入到文件</li>
<li>全缓冲 (<em><strong>fully buffered</strong></em>)：缓冲区满或以任意大小的块被写入到文件</li>
</ul>
<p>可以通过库函数<code>setvbuf()</code>, <code>setbuffer()</code>, <code>setbuf()</code> 三者之一设置 <code>stdio</code> 的缓冲模式，例如</p>
<pre><code class="language-c">#define BUF_SIZE 4096
static char buf[BUF_SIZE];
FILE *fp;

fp = fopen(&quot;test.txt&quot;, 'w');
if(setvbuf(fp, buf, _IOFBF, BUF_SIZE) !=0 )
    exit(EXIT_FAILURE);
</code></pre>
<p>可以使用库函数 <code>fflush()</code> 手动刷新缓冲区  <sup><a href="#2">[2]</a></sup>，例如</p>
<pre><code class="language-c">fp = fopen(&quot;test.txt&quot;, 'w');

fputs(&quot;fputs向文件写入数据\n&quot;, fptr);
fflush(fp);
fputs(&quot;fputs向文件写入数据\n&quot;, fptr);
fflush(fp);
</code></pre>
<p>如果，全缓冲模式下，缓冲区没满也没刷新，那么只有在文件关闭时， 缓冲区会被自动刷新（写入到文件）</p>
<blockquote>
<p>Tips：内存的隐式回收：关闭文件、刷新缓冲区、释放malloc</p>
</blockquote>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.litreily.top/2018/10/25/io-cache/" target="_blank"
   rel="noopener nofollow noreferrer" >IO cache</a></p>
<p><sup id="2">[2]</sup> <a href="https://www.gnu.org/software/libc/manual/html_node/Controlling-Buffering.html" target="_blank"
   rel="noopener nofollow noreferrer" >Controlling Buffering</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>C程序编译错误记录</title>
      <link>https://www.oomkill.com/2021/11/c-complie-record/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/11/c-complie-record/</guid>
      <description></description>
      <content:encoded><![CDATA[<blockquote>
<p><strong>Question1: Similar to pause command in linux</strong></p>
</blockquote>
<pre><code>read -n 1
</code></pre>
<blockquote>
<p><strong>Question2 read : Illegal option -n</strong></p>
</blockquote>
<p>原因为ubuntu 默认的是dash 不是 bash
<a href="https://blog.csdn.net/G_SANGSK/article/details/104388062" target="_blank"
   rel="noopener nofollow noreferrer" >Reference</a></p>
<blockquote>
<p><strong>Question3: How to Compile  C programing Language</strong></p>
</blockquote>
<pre><code>gcc hello.c -o hello
</code></pre>
<blockquote>
<p><strong>Question4: Segmentation fault (core dumped)</strong></p>
</blockquote>
<p>编译正常执行错误，在linux中使用 <code>strace</code> 查看具体报错。</p>
<p><a href="https://www.cnblogs.com/sddai/p/10375979.html" target="_blank"
   rel="noopener nofollow noreferrer" >Reference</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>python drf之viewset</title>
      <link>https://www.oomkill.com/2021/10/python-django-restframework-view-set/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/10/python-django-restframework-view-set/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="what-is-views">What is Views</h2>
<p>drf提供了两个基类，五个视图扩展类，9个视图集</p>
<p>drf提供了一个Django中view的子类<code>APIView </code>,主要变动大概为以下：</p>
<ul>
<li>重新封装了<code>Request</code> 与 <code>Response</code>实例。
<ul>
<li>使用了独有的Request与Response对象，并且提供了专有的解析器 <code>Parser</code> 可以根据HTTP <code>Content-Type</code> 指明的请求数据进行解析。</li>
</ul>
</li>
<li>增加了自有的鉴权/节流
<ul>
<li>在django中<code>dispatch()</code> 分发前，会对请求进行身份认证、权限检查、流量控制。</li>
</ul>
</li>
<li>异常捕获 <code>APIException</code>。</li>
</ul>
<p>APIView implement</p>
<pre><code class="language-python">@classmethod
def as_view(cls, **initkwargs):
    ....
	# 调用父类的方法，Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx
    view = super(APIView, cls).as_view(**initkwargs)
    view.cls = cls
	# 并且生成一个新的request
    view.initkwargs = initkwargs

    # Note: session based authentication is explicitly CSRF validated,
    # all other authentication is CSRF exempt.
    return csrf_exempt(view)

## 父类的view会执行dispatch分配为对应的handle memory，通过method获得对应的方法处理请求
    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
        return handler(request, *args, **kwargs)
</code></pre>
<h2 id="what-is-genericapiview">What is GenericAPIView</h2>
<p><code>GenericAPIView</code> 是继承与 <code>APIView</code>的子类，在 <code>APIView</code> 的基础上增加了对于视图的通用支持方法，用来简化用户代码的编写。主要增加了 <code>QuerySet</code> 与 <code>Serializers</code></p>
<p><strong>GenericAPIView implement</strong></p>
<pre><code class="language-python">class GenericAPIView(views.APIView):
  
    queryset = None
    serializer_class = None

    lookup_url_kwarg = None

 
    def get_queryset(self):
      ...
        assert self.queryset is not None, (
            &quot;'%s' should either include a `queryset` attribute, &quot;
            &quot;or override the `get_queryset()` method.&quot;
            % self.__class__.__name__
        )

        queryset = self.queryset
        if isinstance(queryset, QuerySet):
            # Ensure queryset is re-evaluated on each request.
            queryset = queryset.all()
        return queryset

</code></pre>
<h2 id="how-to-use">How to Use</h2>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://www.django-rest-framework.org/api-guide/views/" target="_blank"
   rel="noopener nofollow noreferrer" >APIView</a></p>
<p><a href="https://www.django-rest-framework.org/api-guide/generic-views/" target="_blank"
   rel="noopener nofollow noreferrer" >GenericAPIView</a></p>
</blockquote>
<p>使用<code>APIView</code>与使用<code>View</code>类似，像往常一样，请求会根据不同的方法被<code>dispatch</code>到对应的处理逻辑方法，例如<code>.get()</code>or <code>.post()</code></p>
<p>引入</p>
<pre><code class="language-python">from rest_framework.views import APIView
from rest_framework.response import Response
</code></pre>
<p>使用<code>GenericAPIView</code> 是 <code>APIView</code> 的子类，是实现了<code>APIView</code> 的常用行为的一个类。一般情况下会与引入</p>
<ul>
<li><code>queryset</code>：对象查询集，使用<code>GenericAPIView</code> 必须设置该属性，或者重写 <code>get_queryset()</code> 方法</li>
<li><code>serializer_class</code>: 序列化器类，必须设置该属性或重写<code>get_serializer_class()</code>方法。</li>
<li><code>lookup_field</code>: 查库时使用的条件字段，一般为传入的值，默认为pk</li>
<li><code>pagination_class</code> ：分页</li>
</ul>
<pre><code class="language-python">from rest_framework import generics
class BookViewSet(generics.GenericAPIView):
    queryset = Book.objects.all()
    serializer_class = BookModelSerializer

    def get(self, request):
        book_list = self.get_queryset()
        book_serializers = self.get_serializer(book_list, many=True)
        return Response(book_serializers.data)
    def delete(self, reques, pk):
        book = self.get_object().delete()
        return Response({&quot;message&quot;:&quot;success&quot;, &quot;status&quot;:100})
</code></pre>
<h3 id="五个视图扩展">五个视图扩展</h3>
<p>Mixin类：DRF提供的通用的增删改查行为，Mixin一般与<code>generics.GenericAPI</code> 混用，可以组成灵活的视图。</p>
<ul>
<li><code>CreateModelMixin</code>: 保存新对象实例
<ul>
<li>创建成功返回201与序列化后的列表，失败则返回400与错误的详细信息</li>
</ul>
</li>
<li><code>UpdateModelMixin</code> ：对现有对象实例进行更新
<ul>
<li>与创建相同，成功返回200，失败返回400</li>
</ul>
</li>
<li><code>DestroyModelMixin</code>：删除对象实例
<ul>
<li>成功删除返回204 错误将返回一个404</li>
</ul>
</li>
<li><code>ListModelMixin</code>：列出实例列表
<ul>
<li>查询成功返回200，需要设置queryset，相应数据可以设置分页</li>
</ul>
</li>
<li><code>RetrieveModelMixin</code>: 只读操作单个对象</li>
</ul>
<h3 id="九个视图集">九个视图集</h3>
<blockquote>
<p>在路由确定用于请求的控制器之后，您的控制器负责理解请求并产生适当的输出。</p>
<p>— <a href="https://guides.rubyonrails.org/action_controller_overview.html" target="_blank"
   rel="noopener nofollow noreferrer" >Ruby on Rails 文档</a>Django REST 框架允许您将一组相关视图的逻辑组</p>
</blockquote>
<p>视图集 <code>ViewSet</code> 是DRF基于view使用视图集ViewSet，可以将一系列逻辑相关的动作放到一个类中，如<code>.get()</code>或<code>.post()</code>则不在提供了，换为<code>.list()</code>和<code>.create()</code>的具体逻辑动作。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>python drf之Serializer</title>
      <link>https://www.oomkill.com/2021/10/python-django-restframework-serializers/</link>
      <pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/10/python-django-restframework-serializers/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="what-is-serializers">What is serializers？</h2>
<p>serializers主要作用是将原生的Python数据类型（如 <code>model</code> <code>querysets </code>）转换为web中通用的<code>JSON</code>，<code>XML</code>或其他内容类型。</p>
<p><code>DRF</code> 提供了一个<code>Serializer</code>类，它为您提供了种强大的通用方法来控制响应的输出，以及一个<code>ModelSerializer </code>类，它为创建处理 <code>model instance</code> 和 <code>serializers</code> 提供了一个序列化的快捷方式。</p>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://www.django-rest-framework.org/api-guide/serializers/" target="_blank"
   rel="noopener nofollow noreferrer" >drf serializers manual</a></p>
</blockquote>
<h2 id="how-to-declaring-serializers">How to Declaring Serializers?</h2>
<p>序列化一个django model</p>
<pre><code class="language-python">class Comment:
    def __init__(self, email, content, created=None):
        self.email = email
        self.content = content
        self.created = created or datetime.now()

comment = Comment(email='leila@example.com', content='foo bar')
</code></pre>
<p>声明Serializers，可以用来序列化与反序列化对象 <code>Comment</code>的属性及值。</p>
<pre><code class="language-python">from rest_framework import serializers

class CommentSerializer(serializers.Serializer):
    email = serializers.EmailField() # 属性名称与类Comment名校相同
    content = serializers.CharField(max_length=200)
    created = serializers.DateTimeField()
</code></pre>
<h2 id="序列化及反序列化">序列化及反序列化</h2>
<h2 id="序列化">序列化</h2>
<pre><code class="language-python">from rest_framework import serializers

class CommentSerializer(serializers.Serializer):
    email = serializers.EmailField()
    content = serializers.CharField(max_length=200)
    created = serializers.DateTimeField()
    
# 上面类似于如下python中的操作
from rest_framework.renderers import JSONRenderer

json = JSONRenderer().render(serializer.data)
json
# b'{&quot;email&quot;:&quot;leila@example.com&quot;,&quot;content&quot;:&quot;foo bar&quot;,&quot;created&quot;:&quot;2016-01-27T15:17:10.375877&quot;}'
</code></pre>
<h3 id="反序列化">反序列化</h3>
<p>反序列化是将json数据流解析为python的数据类型，后映射至对象</p>
<pre><code class="language-python">import io
from rest_framework.parsers import JSONParser

stream = io.BytesIO(json)
data = JSONParser().parse(stream)

serializer = CommentSerializer(data=data)
serializer.is_valid()
# True
serializer.validated_data
# {'content': 'foo bar', 'email': 'leila@example.com', 'created': datetime.datetime(2012, 08, 22, 16, 20, 09, 822243)}
</code></pre>
<h2 id="数据的落地">数据的落地</h2>
<p>如果需要对经过认证的数据进行保存入库，需要实现对应 serializer的 <code>create()</code> 和 <code>update()</code> 方法</p>
<pre><code class="language-python">class CommentSerializer(serializers.Serializer):
    email = serializers.EmailField()
    content = serializers.CharField(max_length=200)
    created = serializers.DateTimeField()

    def create(self, validated_data): # validate_data 实际与 Comment一致，打散后为
        return Comment(**validated_data)

    def update(self, instance, validated_data): # drf serializer实现了对应的实例，instance是该serializer，vilidated是对应的属性
        instance.email = validated_data.get('email', instance.email)
        instance.content = validated_data.get('content', instance.content)
        instance.created = validated_data.get('created', instance.created)
        return instance
</code></pre>
<pre><code>serializer = CommentSerializer(data={'email': 'foobar', 'content': 'baz'})
serializer.is_valid()
# False
serializer.errors
# {'email': ['Enter a valid e-mail address.'], 'created': ['This field is required.']}
</code></pre>
<h3 id="save">save()</h3>
<p><code>save()</code> 可以创建或更新一个实例（实例是值库中的行）。</p>
<pre><code class="language-python"># .save() will create a new instance.
serializer = CommentSerializer(data=data)

# .save() will update the existing `comment` instance.
serializer = CommentSerializer(comment, data=data)
</code></pre>
<h2 id="how-to-use-validate">How to Use validate?</h2>
<p>validate是值在反序列化数据时，需要对数据进行验证（如，长度，值，类型），即在数据落地前，对其制定的规则进行验证。</p>
<pre><code class="language-python">serializer = CommentSerializer(data={'email': 'foobar', 'content': 'baz'})
serializer.is_valid()
# False
serializer.errors
# {'email': ['Enter a valid e-mail address.'], 'created': ['This field is required.']}
</code></pre>
<p><code>.is_valid()</code> 是对数据的验证。<code>raise_exception</code> 是一个可选参数，如果 <code>serializers.ValidationError</code>如果存在验证错误，将引发异常。异常由 REST framework 提供的默认异常处理程序自动处理，并<code>HTTP 400 Bad Request</code>默认返回响应。</p>
<pre><code class="language-python"># Return a 400 response if the data was invalid.
serializer.is_valid(raise_exception=True)
</code></pre>
<h3 id="字段的验证">字段的验证</h3>
<h4 id="自定义验证">自定义验证</h4>
<p><strong>单字段验证</strong></p>
<p>通过子类 <code>.validate_&lt;field_name&gt;</code> 方法进行自定义验证方式，该方法需要返回验证的值或触发<code>serializers.ValidationError</code>. 例如：</p>
<pre><code class="language-python">from rest_framework import serializers

class BlogPostSerializer(serializers.Serializer):
    title = serializers.CharField(max_length=100)
    content = serializers.CharField()

    def validate_title(self, value):
        &quot;&quot;&quot;
        Check that the blog post is about Django.
        &quot;&quot;&quot;
        if 'django' not in value.lower():
            raise serializers.ValidationError(&quot;Blog post is not about Django&quot;)
        return value
</code></pre>
<p><strong>类级别验证</strong></p>
<p>如果需要对多个字段进行验证验证，需要在类中实现<code>validate()</code> 方法。该方法仅单个参数 <code>data</code>, 为验证的字段的字典。例如</p>
<pre><code class="language-python">from rest_framework import serializers

class EventSerializer(serializers.Serializer):
    description = serializers.CharField(max_length=100)
    start = serializers.DateTimeField()
    finish = serializers.DateTimeField()

    def validate(self, data):
        &quot;&quot;&quot;
        Check that start is before finish.
        &quot;&quot;&quot;
        if data['start'] &gt; data['finish']:
            raise serializers.ValidationError(&quot;finish must occur after start&quot;)
        return data
</code></pre>
<h4 id="忽略验证">忽略验证</h4>
<p><strong>注意</strong>：如在Serializer 的<code>&lt;field_name&gt;</code> 声明了参数<code>required=False</code> 则该字段不会进行验证。</p>
<h4 id="指定验证器">指定验证器</h4>
<p>Serializer 的<code>&lt;field_name&gt;</code> 还可以声明 validator，例如，</p>
<pre><code class="language-python">def multiple_of_ten(value):
    if value % 10 != 0:
        raise serializers.ValidationError('Not a multiple of ten')

class GameRecord(serializers.Serializer):
    score = IntegerField(validators=[multiple_of_ten])
    ...
</code></pre>
<blockquote>
<p>validator Reference</p>
<p><a href="https://www.django-rest-framework.org/api-guide/validators/" target="_blank"
   rel="noopener nofollow noreferrer" >validator</a></p>
</blockquote>
<h2 id="modelserializer">ModelSerializer</h2>
<p><code>ModelSerializer</code>，是drf为了方便实现好的可以直接用的Serializer。实现为：</p>
<ul>
<li>将根据模型自动为您生成一组字段。</li>
<li>将自动为Serializer程序生成validator，例如 unique_together 验证器。</li>
<li>包括简单的实现默认的<code>.create()</code>和<code>.update()</code>。</li>
</ul>
<h3 id="modelserializer的声明">ModelSerializer的声明</h3>
<pre><code class="language-python">class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        fields = ['id', 'account_name', 'users', 'created']
</code></pre>
<h4 id="meta的说明">Meta的说明</h4>
<p><code>Meta</code> 类，如名称可知，这是设置Serializer的一些元数据。包含<code>Model</code>,<code>Filed</code>, <code>Validator</code>等信息，例如声明一个Meta类。</p>
<pre><code class="language-python">class EventSerializer(serializers.Serializer):
    name = serializers.CharField()
    room_number = serializers.IntegerField(choices=[101, 102, 103, 201])
    date = serializers.DateField()

    class Meta:
        # 通过在内部Meta类中声明validators来包含，如下所示：
        validators = [
            UniqueTogetherValidator(
                queryset=Event.objects.all(),
                fields=['room_number', 'date']
            )
        ]
        # 通过在内部Meta类中声明model来包含对应使用model，如下所示：
        model = User
        # fields 可以指定要序列化的字段，'__all__'为model中的所有字段
        fields = ['username', 'email', 'profile']
        exclude=['username'] # exclude是要排除的字段
</code></pre>
<blockquote>
<p>注：从 3.3.0 版开始，<strong>必须</strong>提供以下属性之一<code>fields</code>或<code>exclude</code>.</p>
</blockquote>
<p>Serializer会在Meta中拿取自己对应的属性进行使用，例如</p>
<pre><code class="language-python">meta = getattr(self, 'Meta', None)
validators = getattr(meta, 'validators', None)

# assert &lt;condition&gt;,(..error message)
# 可以看到Meta和Meta.model必须要设置
assert hasattr(self, 'Meta'), (
    'Class {serializer_class} missing &quot;Meta&quot; attribute'.format(
        serializer_class=self.__class__.__name__
    )
)
assert hasattr(self.Meta, 'model'), (
    'Class {serializer_class} missing &quot;Meta.model&quot; attribute'.format(
        serializer_class=self.__class__.__name__
    )
)
if model_meta.is_abstract_model(self.Meta.model):
    raise ValueError(
        'Cannot use ModelSerializer with Abstract Models.'
    )
</code></pre>
<h3 id="其他用法">其他用法</h3>
<p>设置只读字段：字段属性中添加 <code>read_only=True</code>, 或者在Meta类中添加属性 中指定字段 <code>read_only_fields</code> 为列表。</p>
<p><a href="https://www.django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields" target="_blank"
   rel="noopener nofollow noreferrer" >readonly-field</a></p>
<h2 id="serializer的字段与字段属性属性">Serializer的字段与字段属性属性</h2>
<blockquote>
<p>Reference</p>
<p><a href="https://www.django-rest-framework.org/api-guide/fields" target="_blank"
   rel="noopener nofollow noreferrer" >fields</a></p>
</blockquote>
<h3 id="字段属性">字段属性</h3>
<ul>
<li><code>read_only</code> 在创建或更新时改属性True字段都被忽略</li>
<li><code>write_only</code> 仅为创建或更新时使用，序列化时不操作该字段</li>
<li><code>required</code> 默认情况下，在反序列化时未提供字段会引发错误，如果不需要可以设置为<code>False</code></li>
<li><code>source</code>：
<ul>
<li>用于序列化时，填充替代对应字段名称的作用 <code>URLField(source='get_absolute_url')</code></li>
<li>可以跨表</li>
<li>可以执行对象内方法。</li>
</ul>
</li>
<li><code>Many</code>: 可以返回多个对象，而非一个，在objects.all时使用</li>
</ul>
<h3 id="字段类型">字段类型</h3>
<ul>
<li><code>BooleanField()</code></li>
<li><code>CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)</code> 文本字段</li>
<li><code>EmailField(max_length=None, min_length=None, allow_blank=False)</code> email字段</li>
<li><code>RegexField(regex, max_length=None, min_length=None, allow_blank=False)</code> 正则表达式</li>
<li><code>IPAddressField(protocol='both', unpack_ipv4=False, **options)</code> IP地址</li>
<li><code>SerializerMethodField(method_name=None)</code> 通过方法序列化，只读字段
<ul>
<li><code>method_name</code> 序列化时通过方法的名称。默认为<code>get_&lt;field_name&gt;</code>.</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>python django使用</title>
      <link>https://www.oomkill.com/2021/10/python-django/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/10/python-django/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="路由匹配">路由匹配</h2>
<h3 id="django中默认匹配页">django中默认匹配页</h3>
<pre><code>url(r'^$', views.login),
</code></pre>
<h3 id="django中404匹配">django中404匹配</h3>
<pre><code>url(r'^$', views.login), # 需要放置最后，不过一般不推荐，都是通过异常捕获处理
</code></pre>
<h3 id="named-group-名称组">named group 名称组</h3>
<p><a href="https://docs.djangoproject.com/en/1.11/topics/http/urls/#named-groups" target="_blank"
   rel="noopener nofollow noreferrer" >https://docs.djangoproject.com/en/1.11/topics/http/urls/#named-groups</a></p>
<pre><code>url(r'^test[0-9]{4}',views.login) 
</code></pre>
<h2 id="反向解析">反向解析</h2>
<blockquote>
<p>别名不能出现冲突</p>
</blockquote>
<pre><code>from django.shortcuts import reverse
reverse(xxx)
</code></pre>
<h3 id="名称组反向解析">名称组反向解析</h3>
<p>无名分组</p>
<pre><code class="language-python"># 路由部分
url(r'^index/(\d+)/', views.home, name='xxx') 
# 前端
 &lt;a href=&quot;{% url 'id' obj.id %}&quot; class=&quot;btn btn-primary btn-xs&quot;&gt;remove&lt;/a&gt;s
# 后端
print reverse('id', args=(id,))
</code></pre>
<p>有名称分组</p>
<pre><code class="language-python"># 路由部分
  url(r&quot;^userdel/(?P&lt;id&gt;\d+)/&quot;,views.UserDelete, name='id'),
# 前端
  &lt;a href=&quot;{% url 'id' obj.id %}&quot; class=&quot;btn btn-primary btn-xs&quot;&gt;remove&lt;/a&gt;
# or
  &lt;a href=&quot;{% url 'id' id=obj.id %}&quot; class=&quot;btn btn-primary btn-xs&quot;&gt;remove&lt;/a&gt;s
# 后端
  print reverse('id', kwargs={&quot;id&quot;:id})
</code></pre>
<h2 id="路由分发">路由分发</h2>
<p>路由分发中，并不能识别出，名称分组并不能准确识别出对应的分组，这里需要增加namespace概念</p>
<pre><code class="language-python">from django.conf.urls import url, include
from django.contrib import admin
from memberserver import urls as member_urls

urlpatterns = [
    url(r'member', include(member_urls)),
]
</code></pre>
<p>路由分发中，并不能识别出，名称分组并不能准确识别出对应的分组，这里需要增加namespace概念</p>
<pre><code class="language-python">from django.conf.urls import url, include
from django.contrib import admin
from memberserver import urls as member_urls

urlpatterns = [
    url(r'member', include(member_urls, namespace=&quot;member&quot;)),
]
# 在后端映射可以使用
reverse(&quot;member:id&quot;) ## 来获得对应的路由

# 在前端可以使用 来获得对应的路由
{% url 'id' id=obj.id %}
</code></pre>
<p>伪静态</p>
<p>虚拟环境</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>django ORM</title>
      <link>https://www.oomkill.com/2021/10/django-orm/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/10/django-orm/</guid>
      <description></description>
      <content:encoded><![CDATA[<p><a href="https://www.cnblogs.com/Dominic-Ji/p/11516152.html" target="_blank"
   rel="noopener nofollow noreferrer" >https://www.cnblogs.com/Dominic-Ji/p/11516152.html</a></p>
<p>对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。</p>
<p>简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。</p>
<p>ORM在业务逻辑层和数据库层之间充当了桥梁的作用。</p>
<h2 id="django中仅测试orm">django中仅测试ORM</h2>
<p>导入model，然后直接使用对应对象进行ORM操作。</p>
<pre><code>import os
if __name__ == &quot;__main__&quot;:
    os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;app.settings&quot;)
    import django
    django.setup()
    from xxx import models
    models.User.objects.all()
</code></pre>
<h2 id="连接数据库">连接数据库</h2>
<p>django配置数据库</p>
<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'root',
        'PASSWORD': '111',
        'HOST':'127.0.0.1',
        'NAME': 'book',
        'CHARSET': 'utf8'
    }
}
</code></pre>
<p><strong>可选</strong>：<code>pymysql</code> 使用模块连接MySQL数据库:：在项目中<code>__init__.py</code> 文件中添加配置：</p>
<pre><code class="language-python">import pymysql
pymysql.install_as_MySQLdb()
</code></pre>
<h2 id="创建表对象">创建（表）对象</h2>
<p>ORM中，<code>O</code> (Object)  代表&quot;对象&quot;，而<code>R</code>(Relational) 则代表&quot;关系&quot;。所以创建表即创建一个类，字段则是类的属性。类的每个实例则对应表中的一条记录。</p>
<p>在Django中model就是你数据来源。通常，一个model映射到一个数据库表，一般情况下基本满足：</p>
<ul>
<li>
<p>每个model（表）都是一个Python类，它是<code>django.db.models.Model</code>的子类即继承<code>models.Model</code>。</p>
</li>
<li>
<p>类的每个属性都代表一个字段（字段）。</p>
</li>
<li>
<p>实例化出的对象，代表表中的记录。</p>
</li>
</ul>
<p>例如</p>
<pre><code class="language-python">class User(models.Model):
name = models.CharField(max_length=32)
age = models.IntegerField()
registration_time = models.DateField()
</code></pre>
<h3 id="字段类型">字段类型</h3>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields/#field-types" target="_blank"
   rel="noopener nofollow noreferrer" >字段类型说明</a></p>
<p><a href="https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields/#field-options" target="_blank"
   rel="noopener nofollow noreferrer" >字段选项说明</a></p>
</blockquote>
<blockquote>
<p><strong>必需掌握字段类型说明</strong>：</p>
</blockquote>
<ul>
<li>
<p><code>BigIntegerField</code> or <code>BigAutoField</code>: <code>1~9223372036854775807</code> 的64位自增int</p>
</li>
<li>
<p><code>CharField</code>: 用于存储字符串，对应MySQL中varchar</p>
</li>
<li>
<p><code>DateField</code>:  python中的<code>datetime.date.today()</code> 即 <code>Y-m-d</code></p>
</li>
<li>
<p><code>DateTimeField</code>：<code>timezone.now</code> - <code>django.utils.timezone.now()</code>为<code>YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]</code>，相当于Python中的<code>datetime.datetime()</code></p>
</li>
<li>
<p><code>DecimalField</code>：小数，使用：<code>models.DecimalField(..., max_digits=5, decimal_places=2)</code></p>
</li>
<li>
<p><code>BooleanField</code>: 代表一个true/false的布尔值。</p>
</li>
<li>
<p><code>AutoField</code>: int类型的自增列，必须填入参数<code>primary_key=True</code> 。当model中如果没有自增列，则自动会创建一个列名为id的列。</p>
</li>
</ul>
<h3 id="字段参数">字段参数</h3>
<blockquote>
<p><strong>Reference</strong></p>
<p><a href="https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields/#field-options" target="_blank"
   rel="noopener nofollow noreferrer" >字段选项说明</a></p>
</blockquote>
<p><strong>必须掌握的字段选项</strong>：</p>
<ul>
<li><code>null</code>：表示该字段是否允许空值，如果为true，django将在数据库中将空值存储为null。默认为false。使用：<code>models.CharField(null=True)</code></li>
<li><code>db_index</code>：是否对字段创建索引，如果为true，将为此字段创建数据库索引。</li>
<li><code>default</code>：字段的默认值。这可以是值或可调用的对象。如果可调用它将每次创建新对象时调用它。</li>
<li><code>primary_key</code>：<code>primary_key=True</code>，该字段为主键。</li>
</ul>
<p>时间字段特殊参数：</p>
<ul>
<li><code>auto_now_add</code>:  <code>auto_now_add=True</code>，仅在创建对象时将当前时间插入到数据库中。如果不设置</li>
<li><code>auto_now</code>: <code>auto_now=True</code>，每次更新数据记录的时候会更新该字段。</li>
</ul>
<h2 id="增">增</h2>
<h3 id="save">save()</h3>
<p>Python对象中表示数据库表数据，模型类表示数据库表，该类的实例表示数据库表中的记录。</p>
<p>要创建一个对象，然后调用<code>save()</code>将其保存到数据库中。</p>
<p><code>save()</code> 直到调用时，才操作数据库，并且没有返回值。</p>
<p><code>save()</code> 必须实例化后调用</p>
<pre><code class="language-python">b = models.User(name=&quot;zhangsan&quot;,age=18)
b.save()
</code></pre>
<h3 id="create">create()</h3>
<p>创建对象并且保存</p>
<pre><code class="language-python">models.User.objects.create(name=&quot;lisi&quot;, age=19)
</code></pre>
<h2 id="删">删</h2>
<h3 id="delete">delete()</h3>
<p><code>delete()</code> 在查询集中的所有行上执行SQL DELETE，并返回删除的对象数量和每个对象类型的删除次数的字典。</p>
<p>delete()无法对<code>QuerySet</code> 上调用<code>delete()</code></p>
<pre><code class="language-python">models.User.objects.filter(pk=1).delete()
</code></pre>
<h2 id="查">查</h2>
<h3 id="查询必会的方法">查询必会的方法</h3>
<p><strong>返回值为QuerySet对象的方法有</strong></p>
<p><code>all()</code> 查询所有数据
<code>filter()</code> 带有过滤条件的查询
<code>exclude()</code> 排除数据，<code>exclude('xxx=xxx')</code>
<code>order_by()</code> 排序 降序 <code>models.User.objects.order_by('-age')</code>
<code>reverse()</code> 反转，反转的数据必须是 <code>order_by()</code>后的数据
<code>distinct()</code> 去重，主键是唯一值，需要过滤主键</p>
<p><strong>返回值为特殊的QuerySet</strong></p>
<p><code>values()</code>    返回一个可迭代的字典序列。（列表套字典）
<code>values_list()</code> 返回一个可迭代的元祖序列。（列表套<code>QuerySet</code>）</p>
<p><strong>返回值为具体对象</strong></p>
<p><code>get()</code>
<code>first()</code>
<code>last()</code></p>
<p><strong>返回值布尔值</strong>：</p>
<p><code>exists()</code></p>
<p><strong>返回值为数字</strong></p>
<p><code>count()</code> 统计当前数据个数</p>
<h4 id="django-查看原生sql的方法">django 查看原生SQL的方法</h4>
<ul>
<li>
<p>``QuerySet<code> 可以使用</code>models.User.objects.values_list().query`</p>
</li>
<li>
<p>终端打印，在<code>setting.py</code>中配置下列</p>
<pre><code class="language-python">LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console':{
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'propagate': True,
            'level':'DEBUG',
        },
    }
}
</code></pre>
<h3 id="条件查询">条件查询</h3>
<h4 id="基于双下划线的查询">基于双下划线的查询</h4>
<p>查询大于的18的用户 <code>models.User.objects.filter(age__gt=12)</code></p>
<p>查询年龄为18,19,20岁的用户 <code>models.User.objects.filter(age__in=[18,19,20])</code></p>
<p>查询90后用户 <code>models.User.objects.filter(age__range=[22,31])</code></p>
<p>模糊查询：查询名字包含<code>l</code> 的用户：<code>models.User.objects.filter(name__contains='li')</code></p>
<p>模糊查询：忽略大小写查询：<code>models.User.objects.filter(name__icontains='li') </code></p>
<p>查询注册时间为 2020 7月份数据：<code>models.User.objects.filter(registration_time__month=7)</code></p>
</li>
</ul>
<h2 id="多表操作">多表操作</h2>
<p>在django中外键的存在使得<code>ORM</code>框架在处理表关系的时候异常的强大。在Django中，外键类定义为：<code>class ForeignKey(to,on_delete,**options)</code> 。可以看到外键的参数大致分为：</p>
<ul>
<li>to：引用那个model（表）。</li>
<li>on_delete：当使用了外键引用model（表）的数据被删除后的操作。</li>
</ul>
<p><strong>定义一个外键</strong>：</p>
<p>在关系数据库中外键的作用是在于将表彼此关联起来。Django提供了定义三种最常见的数据库关系类型的方法：多对一、多对多和一对一。</p>
<p>而关系型字段分为：</p>
<table>
<thead>
<tr>
<th>关系型字段</th>
<th>对应关系</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.djangoproject.com/zh-hans/2.0/topics/db/models/#many-to-one-relationships" target="_blank"
   rel="noopener nofollow noreferrer" >ForeignKey</a></td>
<td>多对一</td>
</tr>
<tr>
<td><a href="https://docs.djangoproject.com/zh-hans/2.0/topics/db/models/#many-to-many-relationships" target="_blank"
   rel="noopener nofollow noreferrer" >ManyToManyField</a></td>
<td>多对多</td>
</tr>
<tr>
<td><a href="https://docs.djangoproject.com/zh-hans/2.0/topics/db/models/#one-to-one-relationships" target="_blank"
   rel="noopener nofollow noreferrer" >OneToOneField</a></td>
<td>一对一</td>
</tr>
</tbody>
</table>
<p>如下：</p>
<ul>
<li>一个作者可以写多本书，但一本书只能由一个出版社出版，使用 <code>ForeignKey</code> 可以直接使用Book实例中通过 <code>Press</code> 属性来操作对应的<code>Press</code>模型。</li>
<li>一本书 可以由多个 <code>Author</code> 编写，也可以由一个作者  <code>Author</code> 编写，但一个作者( <code>Author</code>)也可以编写多本书 <code>Book</code>。</li>
<li>一般情况下，出版社仅记录<code>Author</code>的一个联系方式，也就是 <code>Author</code> 与 <code>AuthorDetail</code> 为一对一关系。</li>
</ul>
<pre><code class="language-python">class Book(models.Model):
    title = models.CharField(max_length=32)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    publishData = models.DateField(auto_now_add=True)

    press = models.ForeignKey(to=&quot;Press&quot;)
    author = models.ManyToManyField(to=&quot;Author&quot;)
    
class Press(models.Model):
    name = models.CharField(max_length=32,null=True)
    address = models.CharField(max_length=32)
    email = models.EmailField()

class Author(models.Model):
    name = models.CharField(max_length=32,null=True)
    age = models.IntegerField()
    authorDetail = models.OneToOneField(to=&quot;AuthorDetail&quot;)

class AuthorDetail(models.Model):
    phoneNumber = models.BigIntegerField()
    address = models.CharField(max_length=32)
</code></pre>
<h3 id="外键的基本操作">外键的基本操作</h3>
<p>添加外键关系：</p>
<pre><code class="language-python">bookobj = models.Book.objects.filter(pk=1).first()
bookobj.author.add(1) # 给主键为1的书籍绑定一个主键1的作者
bookobj.author.add([1,2,3]) # 给主键为1的书籍绑定多个作者
</code></pre>
<p>移除关系：<code>bookobj.author.remove(1)</code></p>
<p>修改关系：<code>bookobj.author.set(2)</code></p>
<p>清空该关系：<code>bookobj.author.clear() # 清除所有这个作者的书</code></p>
<h3 id="正反向概念">正反向概念</h3>
<p>正向查询：在子表中，查询父表（外键所在表）的信息
反向查询：通过父表，查询子表的信息</p>
<h3 id="多表查询">多表查询</h3>
<p>查询口诀：正向查询按外键字段，反向查询按表名（model）</p>
<p><code>all()</code> 当结果为多个时，需要使用<code>.all()</code> 如多对多，一对多</p>
<p><strong>查询书籍1的出版社</strong> 正向查询</p>
<pre><code>book = models.Book.objects.filter(pk=1).first()
print book.press.name
</code></pre>
<p><strong>查询书籍1的作者</strong> 正向查询</p>
<pre><code>book = models.Book.objects.filter(pk=1).first()
print book.author.all()
</code></pre>
<p><strong>查询作者1的电话</strong></p>
<pre><code>auther = models.Author.objects.filter(pk=1).first()
print auther.authorDetail.phoneNumber
</code></pre>
<p><strong>查询出版社拥有的书</strong> 反向查询</p>
<pre><code class="language-python">press = models.Press.objects.filter(pk=1).first()
books = press.book_set.all()
</code></pre>
<p><strong>查询作者Phoenix写的书</strong></p>
<pre><code class="language-python">auther = models.Author.objects.filter(name=&quot;Phoenix&quot;).first()
print auther.book_set.all()
</code></pre>
<p><strong>根据手机号查询作者</strong></p>
<pre><code class="language-python">phone = models.AuthorDetail.objects.filter(phoneNumber=1511111111).first()
print phone.author.name
</code></pre>
<h3 id="基于下划线的查询">基于下划线的查询</h3>
<p><strong>根据名称查询手机号</strong></p>
<pre><code class="language-python">models.Author.objects.filter(name=&quot;Phoenix&quot;).values(&quot;authorDetail__phoneNumber&quot;)
# 获取两个表中的字段
models.Author.objects.filter(name=&quot;Phoenix&quot;).values(&quot;authorDetail__phoneNumber&quot;,&quot;name&quot;)
</code></pre>
<p><strong>查询书籍1的作者名称</strong></p>
<pre><code class="language-python"># 正向
models.Book.objects.filter(pk=1).values(&quot;author__name&quot;)
# 反向
models.AuthorDetail.objects.filter(author__name=&quot;Phoenix&quot;).values(&quot;phoneNumber&quot;,&quot;author__name&quot;)
</code></pre>
<p>查询书籍1的作者手机号</p>
<pre><code>models.Book.objects.filter(pk=1).values(&quot;author__authorDetail__phoneNumber&quot;)
</code></pre>
<h2 id="聚合查询-aggregate">聚合查询 (aggregate)</h2>
<p><code>aggregate()</code> 是 <code>QuerySet</code> 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。</p>
<p>使用聚合查询需要引入具体的类 <code>from django.db.models import Avg,Max,Min,Count,Sum</code></p>
<p>获取书的总数 <code>Book.objects.count()</code></p>
<p>对数据进行聚合查询：<code>aggregate(别名 = 聚合函数名[avg,max..](&quot;属性名称&quot;))</code></p>
<h2 id="分组查询annotate">分组查询（annotate）</h2>
<p>分组查询一般会与聚合函数一起使用，使用前也许引入具体类：<code>from django.db.models import Avg,Max,Min,Count,Sum</code></p>
<p>返回值：</p>
<ul>
<li>分组后，用 values 取值，则返回值是 QuerySet 数据类型里面为一个个字典；</li>
<li>分组后，用 values_list 取值，则返回值是 QuerySet 数据类型里面为一个个元组。</li>
</ul>
<p>分组位置 <code>annotate</code>：</p>
<ul>
<li><strong>values  or values_list 在 annotate 前</strong>：values 或者 values_list 是声明以什么字段分组，annotate 执行分组。</li>
<li><strong>values or values_list 在annotate后</strong>： annotate 表示直接以当前表的pk执行分组，values 或者 values_list 表示查询哪些字段， 并且要将 annotate 里的聚合函数起别名，在 values 或者 values_list 里写其别名。</li>
</ul>
<p><strong>统计每本书的作者有几个</strong></p>
<pre><code class="language-python">models.Book.objects.annotate(autherNum=Count('author__id')).values('autherNum','title')
</code></pre>
<p><strong>统计出版社最便宜书的价格</strong></p>
<pre><code class="language-python"> models.Press.objects.annotate(minPrice=Min('book__price')).values(&quot;name&quot;, &quot;minPrice&quot;)
</code></pre>
<p><strong>统计不止一个作者的书</strong></p>
<pre><code class="language-python">models.Book.objects.annotate(autherCount=Count(&quot;author__id&quot;)).filter(autherCount__gt=1).values(&quot;title&quot;,&quot;autherCount&quot;)
</code></pre>
<p><strong>统计作者出书的总价</strong></p>
<pre><code class="language-python">models.Author.objects.annotate(bookPrice=Sum(&quot;book__price&quot;)).values(&quot;name&quot;,&quot;bookPrice&quot;)
</code></pre>
<p><strong>根据指定字段分组</strong></p>
<h2 id="fq查询">F&amp;Q查询</h2>
<h3 id="f查询">F查询</h3>
<p>F 可以在对Model字段值的转换时，无需从数据库中将值加载到内存中，进行操作后再<code>save()</code>。</p>
<p>例如。通常情况下，在更新数据时需先从数据库里将原数据加载到内存里，编辑后最后提交。</p>
<pre><code class="language-python">order = Order.objects.get(orderid='1')
order.amount += 1
order.save()
</code></pre>
<p>而F 可以直接对值进行运行而不必将数据从库中拉到内存中。例如</p>
<p><strong>卖出大于库存的书籍</strong></p>
<pre><code class="language-python">models.Book.objects.filter(sell__gt=F('stock'))
</code></pre>
<p><strong>对所有书籍价格增加100</strong></p>
<pre><code class="language-python">models.Book.objects.update(price=F('price')+100)
</code></pre>
<h3 id="q查询">Q查询</h3>
<p>ORM filter() 等方法中的关键字参数查询都是一起进行 <code>AND</code>  的。 如需要执行更复杂的查询（例如OR语句），你可以使用Q对象。</p>
<p>Q是对查询条件进行字符串拼接，故可以组合 <code>&amp;</code>  和<code>|</code>  等操作符以及使用括号进行分组来编写任意复杂的Q对象。同时，Q 对象可以使用<code>~</code> 操作符取反。</p>
<p>Q 对象允许组合正常的查询和取反(<code>NOT</code>) 查询。</p>
<p>如**：查询作者是的Radamandis和Phoenix**</p>
<pre><code class="language-python">models.Book.objects.filter(Q(authors__name=&quot;Phoenix&quot;)|Q(authors__name=&quot;Radamandis&quot;))
</code></pre>
<p><strong>查询作者不是Phoenix的书</strong></p>
<pre><code class="language-python">models.Book.objects.filter(~Q(author__name=&quot;Phoenix&quot;))
</code></pre>
<p><strong>也可以进行组合查询</strong>: 查询作者不是Phoenix 并且价格大于700</p>
<pre><code>models.Book.objects.filter(~Q(author__name=&quot;Phoenix&quot;) &amp; Q(publishData__gt=&quot;2021-08-04&quot;))
</code></pre>
<p>Q的第二种使用方法</p>
<pre><code class="language-python">query = Q()
query.connector = 'OR' #默认为and
query.children.append(('id', 1))
query.children.append(('id', 2))
query.children.append(('id', 3))

models.Book.objects.filter(query)
</code></pre>
<h2 id="事务">事务</h2>
<blockquote>
<p>Reference</p>
<p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/transactions/" target="_blank"
   rel="noopener nofollow noreferrer" >transactions</a></p>
</blockquote>
<p>在操作多表，或多次变更数据时，这些数据的修改应该是一个整体事务，即要么一起成功，要么一起失败。Django 默认的事务行为是自动提交，即每执行一次则会自动提交到数据库。</p>
<p>在django中事务的使用是通过<code>django.db.transaction</code>模块提供的<code>atomic</code>来定义事务。所以使用事务需要先引入<code>from django.db import transaction</code></p>
<p>事务的使用可以通过<code>装饰器</code> 或 <code>with</code>语句。</p>
<p>通过装饰器方式（全局事务），在整个函数内为一个事务，要么一起成功，要么一起失败。</p>
<pre><code class="language-python">@transaction.atomic
def test():
    models.Press.objects.create(name=&quot;Yasgot&quot;,address=&quot;Nordische Botschaften&quot;, email=&quot;yasgot.com@gamil.com&quot;)
    print &quot;insert ok.&quot;
    time.sleep(10)
    models.Press.objects.create(name=&quot;Yasgot&quot;,address=&quot;Nordische Botschaften&quot;, email=&quot;yasgot.com@gamil.com&quot;)
    book = models.Press.objects.all()
    print book
</code></pre>
<p>通过with方式（局部事务），在函数中，使用 <code>with transaction.atomic():</code> 代码块内的为一个事务。</p>
<pre><code class="language-python">def viewfunc(request):
	with transaction.atomic():
	# 这部分代码会在事务中执行
</code></pre>
<h3 id="事务的异常处理">事务的异常处理</h3>
<h4 id="保存点">保存点</h4>
<p>保存点（<code>savepoint</code>），在事务中可以做到部分回滚，而不是整个事务。</p>
<p><code>atomic()</code> 为开启一个事务，而回滚是通过，<code>transaction.rollback()</code> 执行的完全回滚。而django也推荐仅使用<code>atomic()</code>。</p>
<ul>
<li>
<p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/transactions/#django.db.transaction.savepoint" target="_blank"
   rel="noopener nofollow noreferrer" ><code>savepoint(*using=None*)</code></a>：创建新的保存点，返回保存点ID (<code>sid</code>) 。</p>
</li>
<li>
<p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/transactions/#django.db.transaction.savepoint_commit" target="_blank"
   rel="noopener nofollow noreferrer" ><code>savepoint_commit(*sid*, *using=None*)</code></a>：释放保存点 <code>sid</code> 。如回滚等将不在保证之前的保存点的数据而是整个事务。</p>
</li>
<li>
<p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/transactions/#django.db.transaction.savepoint_rollback" target="_blank"
   rel="noopener nofollow noreferrer" ><code>savepoint_rollback(*sid*, *using=None*)</code></a>:回滚事务 <code>sid</code> 。</p>
</li>
</ul>
<p>下面是官方的一个例子：<a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/transactions/#django.db.transaction.clean_savepoints" target="_blank"
   rel="noopener nofollow noreferrer" >example-to-savepoint</a></p>
<pre><code class="language-python">from django.db import transaction

# open a transaction
@transaction.atomic
def viewfunc(request):

    a.save()
    # transaction now contains a.save()

    sid = transaction.savepoint()

    b.save()
    # transaction now contains a.save() and b.save()

    if want_to_keep_b:
        transaction.savepoint_commit(sid)
        # open transaction still contains a.save() and b.save()
    else:
        transaction.savepoint_rollback(sid)
        # open transaction now contains only a.save()
</code></pre>
<h2 id="执行原生sql">执行原生SQL</h2>
<h2 id="reference-1">Reference</h2>
<blockquote>
<p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/sql/" target="_blank"
   rel="noopener nofollow noreferrer" >raw-sql</a></p>
</blockquote>
<p><strong><code>raw()</code></strong> :执行原生语句 <code>django.db.models.query.RawQuerySet</code></p>
<p><strong><code> django.db.connection()</code></strong>：；连接多个库 <code>from django.db import connection</code></p>
<h2 id="自定义字段类">自定义字段类</h2>
<h2 id="reference-2">Reference</h2>
<blockquote>
<p><a href="https://docs.djangoproject.com/zh-hans/3.2/howto/custom-model-fields/" target="_blank"
   rel="noopener nofollow noreferrer" >custom-filed</a></p>
</blockquote>
<pre><code>class FixedCharField(models.Field):
    &quot;&quot;&quot;
    自定义的 char 类型的字段类
    &quot;&quot;&quot;
    def __init__(self, max_length, *args, **kwargs):
        self.max_length = max_length
        super(FixedCharField, self).__init__(max_length=max_length, *args, **kwargs)

    def db_type(self, connection):
        &quot;&quot;&quot;
        限定生成数据库表的字段类型为 char，长度为 max_length 指定的值
        &quot;&quot;&quot;
        return 'char(%s)' % self.max_length
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>python使用虚拟环境venv</title>
      <link>https://www.oomkill.com/2021/06/python-venv/</link>
      <pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/06/python-venv/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>venv模块支持使用自己的站点目录创建轻量级“虚拟环境”，可选择与系统站点目录隔离。每个虚拟环境都有自己的Python二进制文件（与用于创建此环境的二进制文件的版本相匹配），并且可以在其站点目录中拥有自己独立的已安装 Python 软件包集。</p>
<p>3.6 版后已移除: pyvenv 是 Python 3.3 和 3.4 中创建虚拟环境的推荐工具，不过 在 Python 3.6 中已弃用。</p>
<p>在 3.5 版更改: 现在推荐使用 venv 来创建虚拟环境。</p>
<h3 id="创建venv虚拟环境">创建venv虚拟环境</h3>
<p>如果使用python2，则需要安装virtualenv模块</p>
<pre><code>pip install virtualenv 
python -m virtualenv {name}
</code></pre>
<p>python3内置了 <code>venv</code> 模块，可以直接使用</p>
<pre><code>python3 -m venv {name}
</code></pre>
<p>进入虚拟环境</p>
<p>linux</p>
<pre><code>venv\Scripts\activate
</code></pre>
<p>windows</p>
<pre><code>venv\Scripts\activate.bat
</code></pre>
<p>退出环境</p>
<pre><code>venv\Scripts\deactivate.bat
venv\Scripts\deactivate
</code></pre>
<h3 id="使用venv环境安装软件报错">使用venv环境安装软件报错</h3>
<blockquote>
<p>Could not fetch URL <a href="https://pypi.org/simple/pip/" target="_blank"
   rel="noopener nofollow noreferrer" >https://pypi.org/simple/pip/</a>: There was a problem confirming the ssl certificate: HTTPSConnectionPool(host=&lsquo;pypi.org&rsquo;, port=443): Max retries exceeded with url: /simple/pip/ (Caused by SSLError(SSLEOFError(8, u&rsquo;EOF occurred in violation of protocol (_ssl.c:727)&rsquo;),)) - skipping</p>
</blockquote>
<p>查询很多都无法解决，最后发现有文章提到这是因为开启了climb wall软件导致的，关闭后恢复正常</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>python中的signal</title>
      <link>https://www.oomkill.com/2021/06/python-signal-handle/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/06/python-signal-handle/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="什么是信号">什么是信号</h2>
<p>信号（signal）&ndash; 进程间通讯的一种方式，也可作为一种软件中断的方法。一个进程一旦接收到信号就会打断原来的程序执行来按照信号进行处理。</p>
<p>简化术语，信号是一个事件，用于中断运行功能的执行。信号始终在主Python线程中执行。对于信号，这里不做详细介绍。</p>
<p>Python封装了操作系统的信号功能的库 <code>singal</code> 的库。<code>singal</code>  库可以使我们在python程序中中实现信号机制。</p>
<p><a href="https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7" target="_blank"
   rel="noopener nofollow noreferrer" >https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7</a>)</p>
<h2 id="python的信号处理">Python的信号处理</h2>
<p>首先需要了解Python为什么要提供 <code>signal Library</code>。信号库使我们能够使用信号处理程序，以便当接收信号时都可以执行自定义任务。</p>
<blockquote>
<p>Mission：当接收到信号时执行信号处理方法</p>
</blockquote>
<p>可以通过使用 <code>signal.singal()</code> 函数来实现此功能</p>
<h3 id="python对信号的处理">Python对信号的处理</h3>
<p>通常情况下Python 信号处理程序总是会在主 Python 主解析器的主线程中执行，即使信号是在另一个线程中接收的。 这意味着信号不能被用作线程间通信的手段。 你可以改用 <a href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" target="_blank"
   rel="noopener nofollow noreferrer" ><code>threading</code></a> 模块中的同步原语。</p>
<p>Python信号处理流程，需要对信号处理程序（signal handling ）简要说明。<code>signal handling </code> 是一个任务或程序，当检测到特定信号时，处理函数需要两个参数，即信号id <code>signal number</code> （Linux 中 1-64），与堆栈帧 <code>frame</code>。通过相应信号启动对应 <code>signal handling</code> ，<code>signal.signal()</code> 将为信号分配 处理函数。</p>
<p>如：当运行一个脚本时，取消，此时是捕获到一个信号，可以通过捕获信号方式对程序进行异步的优雅处理。通过将信号处理程序注册到应用程序中：</p>
<pre><code class="language-py">import signal  
import time  

def handler(a, b):  # 定义一个signal handling
    print(&quot;Signal Number:&quot;, a, &quot; Frame: &quot;, b)  
  
signal.signal(signal.SIGINT, handler)  # 将handle分配给对应信号
  
while True:  
    print(&quot;Press ctrl + c&quot;)
    time.sleep(10) 
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/python-signal-processing.png" alt="python signal processing, python SIGINT handler" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>如果不对对应信号进行捕获处理时，python将会抛出异常。</p>
<pre><code>$ python signal.py
^CTraceback (most recent call last):
  File &quot;signal.py&quot;, line 3, in &lt;module&gt;
    while True:
KeyboardInterrupt
</code></pre>
<h2 id="信号枚举">信号枚举</h2>
<p>信号的表现为一个int，Python的信号库有对应的信号枚举成员</p>
<p>其中常用的一般有，</p>
<p>SIGINT  control+c</p>
<p>SIGTERM  终止进程 软件终止信号</p>
<p>SIGKILL  终止进程 杀死进程</p>
<p>SIGALRM 超时</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SIG_DFL</strong></td>
<td></td>
</tr>
<tr>
<td><strong>SIG_IGN</strong></td>
<td>标准信号处理程序，它将简单地忽略给定的信号</td>
</tr>
<tr>
<td><strong>SIGABRT</strong> <br><strong>SIGIOT</strong></td>
<td>来自 abort 的中止信号。<br>abort 导致异常进程终止。通常由检测内部错误或严重破坏约束的库函数调用。例如，如果堆的内部结构被堆溢出损坏，<code>malloc()</code>将调用<code>abort()</code></td>
</tr>
<tr>
<td><strong>SIGALRM</strong><br/><strong>SIGVTALRM</strong> <strong><br></strong> <strong>SIGPROF</strong></td>
<td>如果你用 setitimer 这一类的报警设置函数设置了一个时限，到达时限时进程会接收到 SIGALRM, SIGVTALRM 或者 SIGPROF。但是这三个信号量的含义各有不同，SIGALRM 计时的是真实时间，SIGVTALRM计时的是进程使用了多少CPU时间，而 SIGPROF 计时的是进程和代表该进程的内核用了多少时间。</td>
</tr>
<tr>
<td><strong>SIGBUS</strong></td>
<td>总线发生错误时，进程接收到一个SIGBUS信号。举例来说，存储器访问对齐或者或不存在对应的物理地址都会产生SIGBUS信号。</td>
</tr>
<tr>
<td><strong>SIGCHLD</strong></td>
<td>当子进程终止、被中断或被中断后恢复时，SIGCHLD信号被发送到进程。该信号的一个常见用法是指示操作系统在子进程终止后清理其使用的资源，而不显式调用等待系统调用。</td>
</tr>
<tr>
<td><strong>SIGILL</strong></td>
<td>非法指令。当进程试图执行非法、格式错误、未知或特权指令时，SIGILL信号被发送到该进程。</td>
</tr>
<tr>
<td><strong>SIGKILL</strong></td>
<td>发送SIGKILL信号到一个进程可以使其立即终止(KILL)。与SIGTERM和SIGINT相不同的是，这个信号不能被捕获或忽略，接收过程在接收到这个信号时不能执行任何清理。 以下例外情况适用:</td>
</tr>
<tr>
<td><strong>SIGINT</strong></td>
<td>来自键盘的中断 (CTRL + C)。<code>KeyboardInterrupt</code></td>
</tr>
<tr>
<td><strong>SIGPIPE</strong></td>
<td>当一个进程试图写入一个没有连接到另一端进程的管道时，SIGPIPE信号会被发送到该进程。</td>
</tr>
<tr>
<td>**SIGTERM **</td>
<td>终结信号。 KILL -15 |KILL</td>
</tr>
<tr>
<td><strong>SIGUSR1</strong><br><strong>SIGUSR2</strong></td>
<td>用户自定义信号</td>
</tr>
<tr>
<td><strong>SIGWINCH</strong></td>
<td>终端窗口大小已变化</td>
</tr>
<tr>
<td><strong>SIGHUP</strong></td>
<td>在控制终端上检测到挂起或控制进程的终止。</td>
</tr>
</tbody>
</table>
<p>Reference：[signal-wikipedia](</p>
<h2 id="信号函数">信号函数</h2>
<p>Python的信号库中也有很多常用的函数</p>
<h3 id="signalalarmtime">signal.alarm(time)</h3>
<p>创建一个 <code>SIGALRM</code> 类型的信号，time为预定的时间，设置为0时取消先前设置的定时器</p>
<h3 id="signalpause"><strong>signal.pause()</strong></h3>
<p>可以使代码逻辑处理过程睡眠，直到收到信号，然后调用对应的handler。</p>
<pre><code class="language-python">import signal
import os
import time

def do_exit(sig, stack):
    raise SystemExit('Exiting')

signal.signal(signal.SIGINT, signal.SIG_IGN)
signal.signal(signal.SIGUSR1, do_exit)

print('My PID:', os.getpid())

signal.pause()
</code></pre>
<p>在执行时，忽略了ctrl + c的信号，对USR1做退出操作</p>
<h3 id="signalsetitimerwhich-seconds-interval"><strong>signal.setitimer(which, seconds, interval)</strong></h3>
<p>which： <code>signal.ITIMER_REAL，</code><a href="https://docs.python.org/2/library/signal.html?highlight=signal#signal.ITIMER_VIRTUAL" target="_blank"
   rel="noopener nofollow noreferrer" ><code>signal.ITIMER_VIRTUAL</code></a> 或 <code>signal.ITIMER_PROF</code></p>
<p>seconds：多少秒后触发which。seconds设置为0可以清除which的计时器。</p>
<p>interval：每隔interval秒后触发一次</p>
<h3 id="osgetpid">os.getpid()</h3>
<p>获得当前执行程序的pid</p>
<h2 id="windows下信号的使用">Windows下信号的使用</h2>
<p>在Linux中，可以通过任何可接受的信号枚举值作为信号函数的参数。在Windows中，<code>SIGABRT</code>, <code>SIGFPE</code>, <code>SIGINT</code>, <code>SIGILL</code>, <code>SIGSEGV</code>, <code>SIGTERM</code>, <code>SIGBREAK</code>。</p>
<h2 id="当signal-handling需要参数怎么办">当signal handling需要参数怎么办</h2>
<p>在一些时候，signal handling的操作需要对应主进程传递进来一些函数，而在整个项目中执行过程中的变量与 signal handling不处于一个作用域中，而<code>signal.signal()</code> 不能传递其他的参数，这个时候可以使用 <code>partial</code> 创建一个闭包来解决这个问题。</p>
<p>例如：</p>
<pre><code class="language-python">import signal
import os
import sys
import time

from functools import partial

&quot;&quot;&quot;
这里signal frame默认参数需要放到最后
&quot;&quot;&quot;
def signal_handler(test_parameter1, test_parameter2, signal_num, frame):
    print &quot;signal {} exit. {} {}&quot;.format(signal_num, test_parameter1, test_parameter2)
    sys.exit(1)


a=1
b=2
signal.signal(signal.SIGINT, partial(signal_handler, a, b) )
print('My PID:', os.getpid())

signal.pause()
</code></pre>
<h2 id="忽略信号">忽略信号</h2>
<p>signal定义了忽略接收信号的方法。为了实现信号的处理，需要使用<code>signal.signal()</code> 将默认的信号与<code>signal.SIG_IGN</code> 注册，即可忽略对应的信号中断，<code>kill -9</code> 不可忽略 。</p>
<pre><code class="language-python">import signal
import os
import time

def receiveSignal(signalNumber, frame):
    print('Received:', signalNumber)
    raise SystemExit('Exiting')
    return

if __name__ == '__main__':
    # register the signal to be caught
    signal.signal(signal.SIGUSR1, receiveSignal)

    # register the signal to be ignored
    signal.signal(signal.SIGINT, signal.SIG_IGN)

    # output current process id
    print('My PID is:', os.getpid())

    signal.pause()
</code></pre>
<h2 id="常用的信号">常用的信号</h2>
<pre><code class="language-python">import signal
import os
import time
import sys

def readConfiguration(signalNumber, frame):
    print ('(SIGHUP) reading configuration')
    return

def terminateProcess(signalNumber, frame):
    print ('(SIGTERM) terminating the process')
    sys.exit()

def receiveSignal(signalNumber, frame):
    print('Received:', signalNumber)
    return
	
	signal.signal(signal.SIGHUP, readConfiguration)
    signal.signal(signal.SIGINT, receiveSignal)
    signal.signal(signal.SIGQUIT, receiveSignal)
    signal.signal(signal.SIGILL, receiveSignal)
    signal.signal(signal.SIGTRAP, receiveSignal)
    signal.signal(signal.SIGABRT, receiveSignal)
    signal.signal(signal.SIGBUS, receiveSignal)
    signal.signal(signal.SIGFPE, receiveSignal)
    #signal.signal(signal.SIGKILL, receiveSignal)
    signal.signal(signal.SIGUSR1, receiveSignal)
    signal.signal(signal.SIGSEGV, receiveSignal)
    signal.signal(signal.SIGUSR2, receiveSignal)
    signal.signal(signal.SIGPIPE, receiveSignal)
    signal.signal(signal.SIGALRM, receiveSignal)
    signal.signal(signal.SIGTERM, terminateProcess)
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>macos python安装mysqlapi集合</title>
      <link>https://www.oomkill.com/2021/04/mac-mysqlapi/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/04/mac-mysqlapi/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>记录一下，接了一个python2 django1.x的项目，很老了导致很多扩展无法安装</p>
<p>os version：macos catalina
python version: 2.7.18</p>
<p>而django后端使用sqllite以外需要对应客户端引擎，而安装时编译依赖C客户端即实际mysql组件。</p>
<blockquote>
<p>使用的数据库后端。 内建的数据库后端有：</p>
<p>&lsquo;django.db.backends.postgresql&rsquo;
&lsquo;django.db.backends.mysql&rsquo;
&lsquo;django.db.backends.sqlite3&rsquo;
&lsquo;django.db.backends.oracle&rsquo;</p>
</blockquote>
<p>并且修改配置实例</p>
<pre><code>DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'mydatabaseuser',
        'NAME': 'mydatabase',
        'TEST': {
            'NAME': 'mytestdatabase',
        },
    },
}
</code></pre>
<p>brew unlink mysql</p>
<h3 id="error-command-gcc-failed-with-exit-status-1">error: command &lsquo;gcc&rsquo; failed with exit status 1</h3>
<pre><code>  creating build/temp.macosx-10.9-x86_64-2.7
  gcc -fno-strict-aliasing -fno-common -dynamic -arch x86_64 -g -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -Dversion_info=(1,2,5,'final',1) -D__version__=1.2.5 -I/usr/local/Cellar/mysql@5.7/5.7.32/include/mysql -I/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -c _mysql.c -o build/temp.macosx-10.9-x86_64-2.7/_mysql.o
  gcc -bundle -undefined dynamic_lookup -arch x86_64 -g build/temp.macosx-10.9-x86_64-2.7/_mysql.o -L/usr/local/Cellar/mysql@5.7/5.7.32/lib -lmysqlclient -lssl -lcrypto -o build/lib.macosx-10.9-x86_64-2.7/_mysql.so
  ld: library not found for -lssl
  clang: error: linker command failed with exit code 1 (use -v to see invocation)
  error: command 'gcc' failed with exit status 1
</code></pre>
<p>解决方法：</p>
<pre><code># Required for mysqlclient, see brew info openssl
echo 'export PATH=&quot;/usr/local/opt/openssl/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile
export LDFLAGS=&quot;-L/usr/local/opt/openssl/lib&quot;
export CPPFLAGS=&quot;-I/usr/local/opt/openssl/include&quot;

pip install MySQL-python
</code></pre>
<p>Reference：<a href="https://stackoverflow.com/questions/49025594/osx-ld-library-not-found-for-lssl" target="_blank"
   rel="noopener nofollow noreferrer" >not-found-for-lssl</a></p>
<p>windows安装</p>
<pre><code>pip install mysqlclient-1.3.12-cp36-cp36m-win_amd64.whl
</code></pre>
<p>Reference <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank"
   rel="noopener nofollow noreferrer" >https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>
<p>ubuntu安装</p>
<pre><code>apt-get install libmysqld-dev
pip install MySQL-python
</code></pre>
<h3 id="my_configh-file-not-found">my_config.h file not found</h3>
<pre><code>creating build/temp.macosx-10.9-x86_64-2.7
    gcc -fno-strict-aliasing -fno-common -dynamic -arch x86_64 -g -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -Dversion_info=(1,2,5,'final',1) -D__version__=1.2.5 -I/usr/local/Cellar/mysql/8.0.23_1/include/mysql -I/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -c _mysql.c -o build/temp.macosx-10.9-x86_64-2.7/_mysql.o
    _mysql.c:44:10: fatal error: 'my_config.h' file not found
    #include &quot;my_config.h&quot;
             ^~~~~~~~~~~~~
    1 error generated.
    error: command 'gcc' failed with exit status 1
</code></pre>
<p>解决：网上找了很多版本均无法解决，最后发现实际上与linux处理思路是一样的。</p>
<pre><code>brew install mysql # 可以加版本 如 brew install mysq@5.7
brew unlink mysql
brew install mysql-connector-c  # 这个是客户端
ln -snvf /usr/local/Cellar/mysql\@5.7/5.7.32/bin/mysql_config  /usr/local/bin/ # 做个软连接，位置可能不一致
sed -i -e 's/libs=&quot;$libs -l &quot;/libs=&quot;$libs -lmysqlclient -lssl -lcrypto&quot;/g' /usr/local/bin/mysql_config

pip install MySQL-python
</code></pre>
<h3 id="sh-mysql_config-command-not-found">sh: mysql_config: command not found</h3>
<p><code>sh: mysql_config: command not found</code> 这个与上面类似，可以看到也是在PATH中找mysql_config</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua cjson使用</title>
      <link>https://www.oomkill.com/2019/10/lua-cjson/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/lua-cjson/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>cjson下载</p>
<p><a href="https://github.com/mpx/lua-cjson.git" target="_blank"
   rel="noopener nofollow noreferrer" >https://github.com/mpx/lua-cjson.git</a></p>
<p>下载解压后，编译需要根据自己的lua环境以及操作系统修改Makefile的一些配置，不然容易出错。
以下是Makefile中的一些配置。</p>
<pre><code class="language-c">LUA_VERSION =       5.2
TARGET =            cjson.so
PREFIX =            /usr/local
CJSON_LDFLAGS =     -shared
LUA_INCLUDE_DIR =   $(PREFIX)/include
LUA_CMODULE_DIR =   $(PREFIX)/lib/lua/$(LUA_VERSION)
LUA_MODULE_DIR =    $(PREFIX)/share/lua/$(LUA_VERSION)
LUA_BIN_DIR =       $(PREFIX)/bin
</code></pre>
<p><a href="https://blog.gezhiqiang.com/2017/08/24/lua-cjson/" target="_blank"
   rel="noopener nofollow noreferrer" >https://blog.gezhiqiang.com/2017/08/24/lua-cjson/</a></p>
<pre><code class="language-lua">local cjson = require(&quot;cjson&quot;)

local obj = {
    id = 1,
    name = &quot;zhangsan&quot;,
    age = nil,
    is_male = false,
    hobby = {&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;}
}

local str = cjson.encode(obj)

ngx.say(str)
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua nginx api</title>
      <link>https://www.oomkill.com/2019/10/lua-nginx-api/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/lua-nginx-api/</guid>
      <description></description>
      <content:encoded><![CDATA[<pre><code class="language-lua">location = /reqq {
	default_type text/plain;
	content_by_lua_block {
		ngx.req.read_body()
		local data = ngx.req.get_body_data()
                local args, err = ngx.req.get_uri_args()
		if not args then
			ngx.say('post fail')
			return
		end
		
        for key,v in pairs(args) do
			ngx.say(key,&quot;::&quot;,v,&quot;--&quot;)
		end
		ngx.say(data)
	}
}
</code></pre>
<h3 id="ngxexec-内部重定向">ngx.exec 内部重定向</h3>
<pre><code class="language-lua">location = /bb {
    default_type text/plain;
    content_by_lua_block{
        ngx.exec('/reqq?m=DaoShengPay3&amp;c=Pay&amp;orderNo=PH201910111')
    }
}

location = /reqq {
    default_type text/plain;
    content_by_lua_block {
       ngx.req.read_body()
       local data = ngx.req.get_body_data()
       local args, err = ngx.req.get_uri_args()
       if not args then
               ngx.say('post fail')
               return
       end
       for key,v in pairs(args) do
               ngx.say(key,&quot;::&quot;,v,&quot;--&quot;)
       end
       ngx.say(data)
    }
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1570889980396.png" alt="1570889980396" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="ngxlog">ngx.log</h3>
<pre><code class="language-lua">location = /testlog {
    default_type text/plain;
    content_by_lua_block{
        ngx.say('hello lua log')
        ngx.log(ngx.ERR, 'print hello lua log')
    }
}
</code></pre>
<pre><code class="language-log">2019/10/12 22:25:31 [error] 468#0: *248 [lua] content_by_lua(nginx.conf:44):3: print hello lua log, client: 203.90.247.72, server: test111.hou2008.com, request: &quot;GET /testlog HTTP/1.1&quot;, host: &quot;test111.hou2008.com:8181&quot;, referrer: &quot;http://test111.hou2008.com/testlog&quot;
</code></pre>
<h1 id="nginx-api-for-lua">Nginx API for Lua</h1>
<p><a href="https://github.com/openresty/lua-nginx-module" target="_blank"
   rel="noopener nofollow noreferrer" >https://github.com/openresty/lua-nginx-module</a></p>
<p><a href="https://www.zifangsky.cn/1024.html" target="_blank"
   rel="noopener nofollow noreferrer" >https://www.zifangsky.cn/1024.html</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua nginx module</title>
      <link>https://www.oomkill.com/2019/10/lua-nginx-module/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/lua-nginx-module/</guid>
      <description></description>
      <content:encoded><![CDATA[<pre><code class="language-lua">package1 = {}

package1.const = &quot;测试常量&quot;


function package1.func1()
    io.write(&quot;this is public func\n&quot;)
end

return package1
</code></pre>
<p>req.lua</p>
<pre><code class="language-lua">require &quot;package1&quot;
package1.func1()
print(package1)
</code></pre>
<pre><code>lc@lc-virtual-machine:~/lua$ lua pack1.lua 
this is public func
table: 0x5575766224a0
</code></pre>
<p>注意事项：</p>
<ul>
<li>
<p>测试文件是和封装好的模块在同一个目录，否则引用时需要设置路径。</p>
<pre><code class="language-lua">package.path = '/home/lc/lua/1/package1.lua;';

require &quot;package1&quot;

package1.func1()

print(package1)
</code></pre>
</li>
<li>
<p>模块名称和文件名称必须相同</p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用go语言颁发CA证书</title>
      <link>https://www.oomkill.com/2019/10/goskill-x509-in-go/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/goskill-x509-in-go/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>本篇文章中，将描述如何使用go创建CA，并使用CA签署证书。在使用openssl创建证书时，遵循的步骤是 创建秘钥 &gt; 创建CA &gt; 生成要颁发证书的秘钥 &gt; 使用CA签发证书。这种步骤，那么我们现在就来尝试下。</p>
<h3 id="创建证书的颁发机构">创建证书的颁发机构</h3>
<p>首先，会从将从创建 <em>CA</em> 开始。<em>CA</em> 会被用来签署其他证书</p>
<pre><code class="language-go">// 对证书进行签名
ca := &amp;x509.Certificate{
	SerialNumber: big.NewInt(2019),
	Subject: pkix.Name{
        CommonName:    &quot;domain name&quot;,
		Organization:  []string{&quot;Company, INC.&quot;},
		Country:       []string{&quot;US&quot;},
		Province:      []string{&quot;&quot;},
		Locality:      []string{&quot;San Francisco&quot;},
		StreetAddress: []string{&quot;Golden Gate Bridge&quot;},
		PostalCode:    []string{&quot;94016&quot;},
	},
	NotBefore:             time.Now(),  // 生效时间
	NotAfter:              time.Now().AddDate(10, 0, 0), // 过期时间 年月日
	IsCA:                  true, // 表示用于CA
    // openssl 中的 extendedKeyUsage = clientAuth, serverAuth 字段
	ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
    // openssl 中的 keyUsage 字段
	KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
	BasicConstraintsValid: true,
}
</code></pre>
<p>接下来需要对证书生成公钥和私钥</p>
<pre><code class="language-go">caPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
if err != nil {
	return err
}
</code></pre>
<p>然后生成证书：</p>
<pre><code class="language-go">caBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &amp;caPrivKey.PublicKey, caPrivKey)
if err != nil {
	return err
}
</code></pre>
<p>我们看到的证书内容是PEM编码后的，现在<code>caBytes</code>我们有了生成的证书，我们将其进行 PEM 编码以供以后使用：</p>
<pre><code class="language-go">caPEM := new(bytes.Buffer)
pem.Encode(caPEM, &amp;pem.Block{
	Type:  &quot;CERTIFICATE&quot;,
	Bytes: caBytes,
})

caPrivKeyPEM := new(bytes.Buffer)
pem.Encode(caPrivKeyPEM, &amp;pem.Block{
	Type:  &quot;RSA PRIVATE KEY&quot;,
	Bytes: x509.MarshalPKCS1PrivateKey(caPrivKey),
})
</code></pre>
<h3 id="创建证书">创建证书</h3>
<p>证书的 <code>x509.Certificate</code> 与CA的 <code>x509.Certificate</code> 属性有稍微不同，需要进行一些修改</p>
<pre><code class="language-go">cert := &amp;x509.Certificate{
	SerialNumber: big.NewInt(1658),
	Subject: pkix.Name{
        CommonName:    &quot;domain name&quot;,
		Organization:  []string{&quot;Company, INC.&quot;},
		Country:       []string{&quot;US&quot;},
		Province:      []string{&quot;&quot;},
		Locality:      []string{&quot;San Francisco&quot;},
		StreetAddress: []string{&quot;Golden Gate Bridge&quot;},
		PostalCode:    []string{&quot;94016&quot;},
	},
    IPAddresses:  []net.IP{}, // 这里就是openssl配置文件中 subjectAltName 里的 IP:/IP=
    DNSNames:     []string{}, // 这里就是openssl配置文件中 subjectAltName 里的 DNS:/DNS=
	NotBefore:    time.Now(),
	NotAfter:     time.Now().AddDate(10, 0, 0),
	SubjectKeyId: []byte{1, 2, 3, 4, 6},
    // 这里就是openssl中的extendedKeyUsage 
	ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
	KeyUsage:     x509.KeyUsageDigitalSignature,
}
</code></pre>
<blockquote>
<p>注：这里会在证书中特别添加了 <code>DNS</code> 和 <code>IP</code> （这个不是必须的），这个选项的增加代表的我们的证书可以支持多域名</p>
</blockquote>
<p>为该证书创建私钥和公钥：</p>
<pre><code class="language-go">certPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
if err != nil {
	return err
}
</code></pre>
<h3 id="使用ca签署证书">使用CA签署证书</h3>
<p>有了上述的内容后，可以创建证书并用CA进行签名</p>
<pre><code class="language-go">certBytes, err := x509.CreateCertificate(rand.Reader, cert, ca, &amp;certPrivKey.PublicKey, caPrivKey)
if err != nil {
	return err
}
</code></pre>
<p>要保存成证书格式需要做PEM编码</p>
<pre><code class="language-go">certPEM := new(bytes.Buffer)
pem.Encode(certPEM, &amp;pem.Block{
	Type:  &quot;CERTIFICATE&quot;,
	Bytes: certBytes,
})

certPrivKeyPEM := new(bytes.Buffer)
pem.Encode(certPrivKeyPEM, &amp;pem.Block{
	Type:  &quot;RSA PRIVATE KEY&quot;,
	Bytes: x509.MarshalPKCS1PrivateKey(certPrivKey),
})
</code></pre>
<h3 id="把上面内容融合为一起">把上面内容融合为一起</h3>
<p>创建一个 <code>ca.go</code> 里面是创建ca和颁发证书的逻辑</p>
<pre><code class="language-go">package main

import (
	&quot;bytes&quot;
	cr &quot;crypto/rand&quot;
	&quot;crypto/rsa&quot;
	&quot;crypto/x509&quot;
	&quot;crypto/x509/pkix&quot;
	&quot;encoding/pem&quot;
	&quot;math/big&quot;
	&quot;math/rand&quot;
	&quot;net&quot;
	&quot;os&quot;
	&quot;time&quot;
)

type CERT struct {
	CERT       []byte
	CERTKEY    *rsa.PrivateKey
	CERTPEM    *bytes.Buffer
	CERTKEYPEM *bytes.Buffer
	CSR        *x509.Certificate
}

func CreateCA(sub *pkix.Name, expire int) (*CERT, error) {
	var (
		ca  = new(CERT)
		err error
	)

	if expire &lt; 1 {
		expire = 1
	}
	// 为ca生成私钥
	ca.CERTKEY, err = rsa.GenerateKey(cr.Reader, 4096)
	if err != nil {
		return nil, err
	}

	// 对证书进行签名
	ca.CSR = &amp;x509.Certificate{
		SerialNumber: big.NewInt(rand.Int63n(2000)),
		Subject:      *sub,
		NotBefore:    time.Now(),                       // 生效时间
		NotAfter:     time.Now().AddDate(expire, 0, 0), // 过期时间
		IsCA:         true,                             // 表示用于CA
		// openssl 中的 extendedKeyUsage = clientAuth, serverAuth 字段
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		// openssl 中的 keyUsage 字段
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
		BasicConstraintsValid: true,
	}
	// 创建证书
	// caBytes 就是生成的证书
	ca.CERT, err = x509.CreateCertificate(cr.Reader, ca.CSR, ca.CSR, &amp;ca.CERTKEY.PublicKey, ca.CERTKEY)
	if err != nil {
		return nil, err
	}
	ca.CERTPEM = new(bytes.Buffer)
	pem.Encode(ca.CERTPEM, &amp;pem.Block{
		Type:  &quot;CERTIFICATE&quot;,
		Bytes: ca.CERT,
	})
	ca.CERTKEYPEM = new(bytes.Buffer)
	pem.Encode(ca.CERTKEYPEM, &amp;pem.Block{
		Type:  &quot;RSA PRIVATE KEY&quot;,
		Bytes: x509.MarshalPKCS1PrivateKey(ca.CERTKEY),
	})

	// 进行PEM编码，编码就是直接cat证书里面内容显示的东西
	return ca, nil
}

func Req(ca *x509.Certificate, sub *pkix.Name, expire int, dns []string, ip []net.IP) (*CERT, error) {
	var (
		cert = &amp;CERT{}
		err  error
	)
	cert.CERTKEY, err = rsa.GenerateKey(cr.Reader, 4096)
	if err != nil {
		return nil, err
	}
	if expire &lt; 1 {
		expire = 1
	}
	cert.CSR = &amp;x509.Certificate{
		SerialNumber: big.NewInt(rand.Int63n(2000)),
		Subject:      *sub,
		IPAddresses:  ip,
		DNSNames:     dns,
		NotBefore:    time.Now(),
		NotAfter:     time.Now().AddDate(expire, 0, 0),
		SubjectKeyId: []byte{1, 2, 3, 4, 6},
		ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		KeyUsage:     x509.KeyUsageDigitalSignature,
	}

	cert.CERT, err = x509.CreateCertificate(cr.Reader, cert.CSR, ca, &amp;cert.CERTKEY.PublicKey, cert.CERTKEY)
	if err != nil {
		return nil, err
	}

	cert.CERTPEM = new(bytes.Buffer)
	pem.Encode(cert.CERTPEM, &amp;pem.Block{
		Type:  &quot;CERTIFICATE&quot;,
		Bytes: cert.CERT,
	})
	cert.CERTKEYPEM = new(bytes.Buffer)
	pem.Encode(cert.CERTKEYPEM, &amp;pem.Block{
		Type:  &quot;RSA PRIVATE KEY&quot;,
		Bytes: x509.MarshalPKCS1PrivateKey(cert.CERTKEY),
	})
	return cert, nil
}

func Write(cert *CERT, file string) error {
	keyFileName := file + &quot;.key&quot;
	certFIleName := file + &quot;.crt&quot;
	kf, err := os.Create(keyFileName)
	if err != nil {
		return err
	}
	defer kf.Close()

	if _, err := kf.Write(cert.CERTKEYPEM.Bytes()); err != nil {
		return err
	}

	cf, err := os.Create(certFIleName)
	if err != nil {
		return err
	}
	if _, err := cf.Write(cert.CERTPEM.Bytes()); err != nil {
		return err
	}
	return nil
}
</code></pre>
<p>如果需要使用的话，可以引用这些函数</p>
<pre><code class="language-go">package main

import (
	&quot;crypto/x509/pkix&quot;
	&quot;log&quot;
	&quot;net&quot;
)

func main() {
	subj := &amp;pkix.Name{
		CommonName:    &quot;chinamobile.com&quot;,
		Organization:  []string{&quot;Company, INC.&quot;},
		Country:       []string{&quot;US&quot;},
		Province:      []string{&quot;&quot;},
		Locality:      []string{&quot;San Francisco&quot;},
		StreetAddress: []string{&quot;Golden Gate Bridge&quot;},
		PostalCode:    []string{&quot;94016&quot;},
	}
	ca, err := CreateCA(subj, 10)
	if err != nil {
		log.Panic(err)
	}

	Write(ca, &quot;./ca&quot;)

	crt, err := Req(ca.CSR, subj, 10, []string{&quot;test.default.svc&quot;, &quot;test&quot;}, []net.IP{})

	if err != nil {
		log.Panic(err)
	}

	Write(crt, &quot;./tls&quot;)
}
</code></pre>
<h3 id="遇到的问题">遇到的问题</h3>
<p><strong>panic: x509: unsupported public key type: rsa.PublicKey</strong></p>
<p>这里是因为 <code>x509.CreateCertificate</code> 的参数 <code>privatekey</code> 需要传入引用变量，而传入的是一个普通变量</p>
<blockquote>
<p><strong>注</strong>：x509: only RSA and ECDSA public keys supported</p>
</blockquote>
<h3 id="一些参数的意思">一些参数的意思</h3>
<p><code>extendedKeyUsage</code> ：增强型密钥用法(参见&quot;new_oids&quot;字段)：服务器身份验证、客户端身份验证、时间戳。</p>
<pre><code class="language-cnf">extendedKeyUsage = critical,serverAuth, clientAuth, timeStamping
</code></pre>
<p><code>keyUsage </code>： 密钥用法，防否认(nonRepudiation)、数字签名(digitalSignature)、密钥加密(keyEncipherment)。</p>
<pre><code class="language-conf">keyUsage = nonRepudiation, digitalSignature, keyEncipherment
</code></pre>
<blockquote>
<p>Reference</p>
<p><a href="https://shaneutt.com/blog/golang-ca-and-signed-cert-go/" target="_blank"
   rel="noopener nofollow noreferrer" >golang ca and signed cert go</a></p>
<p><a href="https://golang.google.cn/pkg/crypto/x509/" target="_blank"
   rel="noopener nofollow noreferrer" >package x509</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>通过Go语言中阐述TCP Handshake</title>
      <link>https://www.oomkill.com/2019/10/go-tcp-hadshake/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-tcp-hadshake/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="tcp的三次握手">TCP的三次握手</h2>
<p>所谓三次握手 <code>Three-Way Handshake</code> 是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。好比两个人在打电话：</p>
<p><strong>当连接被建立或被终止，交换的报文段只包含TCP头部，而没有数据。</strong></p>
<h3 id="tcp报文头部结构">tcp报文头部结构</h3>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015181428149-1959216565.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<ul>
<li>序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，<strong>发起方发送数据时对此进行标记。</strong></li>
<li>确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，确认方ack=发起方seq+1，两端配对。</li>
<li>标志位
<ul>
<li>ACK：确认序号有效。</li>
<li>FIN：释放一个连接。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>URG：紧急指针（urgent pointer）有效。</li>
</ul>
</li>
</ul>
<p>    第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</p>
<p>    第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</p>
<p>    第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015202229030-277503076.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="四次挥手">四次挥手</h3>
<p>    比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<p>    第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</p>
<p>    第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</p>
<p>    第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</p>
<p>    第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>正则表达式在go中使用</title>
      <link>https://www.oomkill.com/2019/10/go-regular-expression/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-regular-expression/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活。按照它的语法规则，随需构造出的匹配模式就能够从原始文本中筛选出几乎任何你想要得到的字符组合。</p>
<p>Go语言通过regexp（regular expression）标准包为正则表达式提供了官方支持，包名采用<code>regular expression</code>的每个单词的前三个首字母组成。</p>
<p>Go语言的正则表达式实现的是RE2标准，Go语言的正则表达式与其他编程语言之间也有一些小的差异。</p>
<h2 id="正则表达式规则">正则表达式规则</h2>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022164330719-1170561795.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="go语言中regexp包使用">go语言中regexp包使用</h2>
<p>简单来说，Go语言中使用正则表达式只需要两步即可：</p>
<ul>
<li>解析、编译正则表达式 <code>regexp.MustCompile()</code> 返回一个regexp结构体</li>
<li>根据解析好的规则（结构体形式），从指定字符串中提取需要的信息。如 <code>MatchString()</code> <code>FindAllSubmatch()</code>等</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;regexp&quot;
)

func main() {
	rege := regexp.MustCompile(`(\d{1,3}\.){3}\d{1,3}`)
	str := rege.FindAllString(&quot;SLAJDLKAJ192.168.0.1DASDASA1231&quot;, -1)
	fmt.Println(str)

}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022165701430-1274324162.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>deepin下安装goland中文字体显示全是方块</title>
      <link>https://www.oomkill.com/2019/04/deepin-goland/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/04/deepin-goland/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>下载中文字体</p>
<pre><code class="language-bash">apt-get install ttf-arphic-uming xfonts-intl-chinese
</code></pre>
<p>替换goland的汉化包，两个jar包。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
