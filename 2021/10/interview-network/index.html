<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>网络基础面试题收集 | Cylon&#39;s Collection</title>
<meta name="keywords" content="network">
<meta name="description" content="网络基础面试题收集 - Cylon&#39;s Collection">
<meta name="author" content="cylon">
<link rel="canonical" href="https://www.oomkill.com/2021/10/interview-network/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.41a8706089174fae1769fc26da4d1d354fa88083db604a95688ff58852dd9006.css" integrity="sha256-QahwYIkXT64Xafwm2k0dNU&#43;ogIPbYEqVaI/1iFLdkAY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.oomkill.com/favicon.ico">
<link rel="apple-touch-icon" href="https://www.oomkill.com/apple-touch-icon.png">

<meta name="twitter:title" content="网络基础面试题收集 | Cylon&#39;s Collection" />
<meta name="twitter:description" content="" />
<meta property="og:title" content="网络基础面试题收集 | Cylon&#39;s Collection" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.oomkill.com/2021/10/interview-network/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2021-10-01T00:00:00&#43;00:00" />
  <meta property="article:modified_time" content="2023-03-30T23:00:36&#43;08:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://www.oomkill.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "网络基础面试题收集",
      "item": "https://www.oomkill.com/2021/10/interview-network/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "网络基础面试题收集 | Cylon's Collection",
  "name": "网络基础面试题收集",
  "description": "",
  "keywords": [
    "network"
  ],
  "wordCount" : "12500",
  "inLanguage": "zh",
  "datePublished": "2021-10-01T00:00:00Z",
  "dateModified": "2023-03-30T23:00:36+08:00",
  "author":{
    "@type": "Person",
    "name": "cylon"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.oomkill.com/2021/10/interview-network/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cylon's Collection",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.oomkill.com/favicon.ico"
    }
  }
}
</script><script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary-bg: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list-page {
                background: var(--theme);
            }

            .list-page:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list-page:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

</head>

<body class=" type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'auto';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.oomkill.com" accesskey="h" title="Cylon&#39;s Collection (Alt + H)">Cylon&#39;s Collection</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.oomkill.com/archives/" title="归档"
                >归档
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/tags/" title="标签"
                >标签
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/search/" title="搜索 (Alt &#43; /)"data-no-instant accesskey=/
                >搜索
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/about/" title="关于"
                >关于
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header"><h1 class="post-title">网络基础面试题收集</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>2021-10-01</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>Edited on 2023-03-30</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://www.oomkill.com/tags/interview/">Interview</a></span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><circle cx="12" cy="12" r="9"></circle><polyline points="12 7 12 12 15 15"></polyline></svg>
  <span>25 分钟</span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%9f%9f%e5%90%8d%e7%9b%b8%e5%85%b3" aria-label="域名相关">域名相关</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afdns%e5%8a%ab%e6%8c%81" aria-label="什么是DNS劫持">什么是DNS劫持</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afdns%e6%b1%a1%e6%9f%93" aria-label="什么是DNS污染">什么是DNS污染</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%9f%9f%e5%90%8d%e8%a2%ab%e5%a2%99" aria-label="什么是域名被墙">什么是域名被墙</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afdns%e6%b8%85%e6%b4%97" aria-label="什么是DNS清洗？">什么是DNS清洗？</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e6%94%bb%e5%87%bb%e7%9b%b8%e5%85%b3" aria-label="网络攻击相关">网络攻击相关</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%aftcp%e7%9a%84syn%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e9%a2%84%e9%98%b2" aria-label="什么是TCP的SYN攻击？如何预防？">什么是TCP的SYN攻击？如何预防？</a></li>
                <li>
                    <a href="#ddos%e6%94%bb%e5%87%bb%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="ddos攻击的类型">ddos攻击的类型</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8d%e5%b0%84%e5%bc%8f%e6%94%bb%e5%87%bb" aria-label="什么是反射式攻击">什么是反射式攻击</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afcc%e6%94%bb%e5%87%bb" aria-label="什么是CC攻击">什么是CC攻击</a></li>
                <li>
                    <a href="#cc%e6%94%bb%e5%87%bb%e5%92%8cddos%e6%94%bb%e5%87%bb%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="cc攻击和ddos攻击有什么区别">cc攻击和ddos攻击有什么区别</a></li>
                <li>
                    <a href="#dbus%e6%94%bb%e5%87%bb" aria-label="DBus攻击">DBus攻击</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e7%9b%b8%e5%85%b3" aria-label="网络相关">网络相关</a><ul>
                        
                <li>
                    <a href="#osi%e6%a8%a1%e5%9e%8b%e5%92%8ctcpip%e6%a8%a1%e5%9e%8b%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="OSI模型和TCP/IP模型有什么区别？">OSI模型和TCP/IP模型有什么区别？</a></li>
                <li>
                    <a href="#%e7%ae%80%e8%bf%b0tcp%e9%87%8d%e4%bc%a0%e6%97%b6%e7%9a%84ack%e6%9c%ba%e5%88%b6" aria-label="简述TCP重传时的ACK机制？">简述TCP重传时的ACK机制？</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%9a%84tcp%e8%bf%9e%e6%8e%a5%e6%8a%a5%e9%94%99%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="常见的TCP连接报错有哪些?">常见的TCP连接报错有哪些?</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%aftcp-resetrst" aria-label="什么是TCP Reset（RST）">什么是TCP Reset（RST）</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81tcp%e7%9a%84%e8%bf%9e%e6%8e%a5%e7%8a%b6%e6%80%81%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="常见TCP的连接状态有哪些？">常见TCP的连接状态有哪些？</a></li>
                <li>
                    <a href="#close_wait%e7%8a%b6%e6%80%81%e7%9a%84%e4%ba%a7%e7%94%9f%e5%8d%b1%e5%ae%b3%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" aria-label="CLOSE_WAIT状态的产生、危害、如何避免？">CLOSE_WAIT状态的产生、危害、如何避免？</a></li>
                <li>
                    <a href="#tcp%e7%9a%84%e5%85%b3%e9%97%ad" aria-label="TCP的关闭">TCP的关闭</a></li>
                <li>
                    <a href="#time_wait-%e7%8a%b6%e6%80%81%e7%9a%84%e4%ba%a7%e7%94%9f%e5%8d%b1%e5%ae%b3%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" aria-label="TIME_WAIT 状态的产生、危害、如何避免？">TIME_WAIT 状态的产生、危害、如何避免？</a></li>
                <li>
                    <a href="#time_wait-%e5%92%8c-close_wait%e5%8c%ba%e5%88%ab" aria-label="TIME_WAIT 和 CLOSE_WAIT区别">TIME_WAIT 和 CLOSE_WAIT区别</a></li>
                <li>
                    <a href="#2msl%e7%9a%84%e5%80%bc%e6%98%af%e5%a4%9a%e5%b0%91" aria-label="2MSL的值是多少？">2MSL的值是多少？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ae%a2%e6%88%b7%e7%ab%af%e8%a6%81%e7%ad%892msl" aria-label="为什么客户端要等2MSL">为什么客户端要等2MSL</a></li>
                <li>
                    <a href="#rto%e5%92%8cmsl" aria-label="RTO和MSL">RTO和MSL</a></li>
                <li>
                    <a href="#tcp-%e5%92%8c-udp-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="TCP 和 UDP 的区别？">TCP 和 UDP 的区别？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-tcp-%e5%8f%ab%e6%95%b0%e6%8d%ae%e6%b5%81%e6%a8%a1%e5%bc%8f-udp-%e5%8f%ab%e6%95%b0%e6%8d%ae%e6%8a%a5%e6%a8%a1%e5%bc%8f" aria-label="为什么 TCP 叫数据流模式？ UDP 叫数据报模式？">为什么 TCP 叫数据流模式？ UDP 叫数据报模式？</a></li>
                <li>
                    <a href="#tcp%e5%bb%ba%e8%bf%9e%e6%8e%a5%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e4%b8%89%e6%ac%a1%e6%96%ad%e5%bc%80%e8%bf%9e%e6%8e%a5%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%9b%9b%e6%ac%a1" aria-label="TCP建⽴连接为什么需要三次？断开连接⼜为什么需要四次？">TCP建⽴连接为什么需要三次？断开连接⼜为什么需要四次？</a></li>
                <li>
                    <a href="#tcp%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e6%8f%90%e4%be%9b%e5%8f%af%e9%9d%a0%e6%80%a7%e7%9a%84" aria-label="TCP协议如何提供可靠性的？">TCP协议如何提供可靠性的？</a></li>
                <li>
                    <a href="#tcp-flags" aria-label="TCP Flags">TCP Flags</a></li>
                <li>
                    <a href="#dns%e4%bd%bf%e4%bb%80%e4%b9%88%e5%8d%8f%e8%ae%ae" aria-label="DNS使⽤什么协议？">DNS使⽤什么协议？</a></li>
                <li>
                    <a href="#tcp%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e6%9c%ba%e5%88%b6%e6%98%af%e4%bb%80%e4%b9%88%e8%af%b7%e7%ae%80%e5%8d%95%e8%af%b4%e8%af%b4" aria-label="TCP的拥塞控制机制是什么？请简单说说。">TCP的拥塞控制机制是什么？请简单说说。</a></li>
                <li>
                    <a href="#ip%e6%8a%a5%e6%96%87%e4%b8%adttl%e5%ad%97%e6%ae%b5%e4%bd%9c%e7%94%a8" aria-label="IP报文中TTL字段作用">IP报文中TTL字段作用</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%aftcp-rto" aria-label="什么是TCP RTO？">什么是TCP RTO？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e8%b0%83%e6%95%b4tcp-rto" aria-label="如何调整TCP RTO？">如何调整TCP RTO？</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content">
    





<div class="copyrightTopBlock">
    <p>本文发布于<a href="https://www.oomkill.com/about" target="_blank">Cylon的收藏册</a>，转载请著名原文链接~</p>
    <div class="articleSuffix-bg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 147.78 155.96"> <path d="M10.5,99.81a1.9,1.9,0,0,0-.53-.09,1.66,1.66,0,0,0-1.64,1.65A1.64,1.64,0,0,0,10,103a1.57,1.57,0,0,0,.87-.25l26.76,26.82.45-1.08L11.52,101.91A1.65,1.65,0,0,0,10.5,99.81Zm-.13,2a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.58.58,0,0,1,.57-.57h0a.57.57,0,0,1,.56.58A.55.55,0,0,1,10.37,101.77Z" style="fill:#c5c9e0"></path><path d="M56.15,117.58H39.06l0-.09a1.65,1.65,0,0,0-1.36-1H37.5a1.65,1.65,0,1,0,1.56,2.19H55.7L92.92,156h41.44v-1.08h-41Zm-18.25.94a.56.56,0,0,1-.79,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h0a.58.58,0,0,1,.57.58A.54.54,0,0,1,37.9,118.52Z" style="fill:#c5c9e0"></path><path d="M23.52,50.32a1.65,1.65,0,0,0,1.55-1.11H55.28l48-48.13h31.06V0H102.85l-48,48.13H25.07a1.64,1.64,0,0,0-2.09-1,1.64,1.64,0,0,0,.54,3.2Zm0-2.21a.57.57,0,0,1,0,1.13.57.57,0,1,1,0-1.13Z" style="fill:#c5c9e0"></path><polygon points="102.86 0 102.86 0 102.86 0 102.86 0" style="fill:#c5c9e0"></polygon><path d="M107.72,12.14h26.64V11.07H107.27L57.4,61H3.09a1.66,1.66,0,0,0-1.45-.86H1.52A1.65,1.65,0,1,0,2.81,63a1.59,1.59,0,0,0,.45-.87H57.85ZM2.05,62.23a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h.09a.57.57,0,0,1,.32,1Z" style="fill:#c5c9e0"></path><path d="M134.36,43.22V42.14h-22.3l-9.62,9.63a1.64,1.64,0,0,0-2.19.77,1.61,1.61,0,0,0-.17.71,1.65,1.65,0,1,0,3.29,0,1.61,1.61,0,0,0-.16-.72l9.3-9.32Zm-32.64,10.6a.57.57,0,0,1,0-1.13.57.57,0,0,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M147,52.3l-9,9H111.48a1.64,1.64,0,0,0-1.61-1.33h-.14a1.65,1.65,0,1,0,1.6,2.41h27.19l9.26-9.29L147,52.3Zm-37.15,9.85a.56.56,0,0,1-.56-.57h0a.56.56,0,0,1,.56-.56h0a.57.57,0,1,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M66.79,75.35l11,11.06h56.53V85.33H78.27l-11-11.06H49.49L37.12,86.67a1.64,1.64,0,0,0-2.09,1,1.61,1.61,0,0,0-.09.54,1.65,1.65,0,0,0,3.29,0,1.68,1.68,0,0,0-.26-.89l12-12ZM36.58,88.79a.57.57,0,1,1,.57-.56A.57.57,0,0,1,36.58,88.79Z" style="fill:#c5c9e0"></path><path d="M110.61,95.55,92.8,113.4a1.62,1.62,0,1,0,.77.76l17.49-17.53h23.31V95.55ZM92.49,115.28a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.57-.57h0a.58.58,0,0,1,.56.58A.55.55,0,0,1,92.49,115.28Z" style="fill:#c5c9e0"></path><path d="M97.89,122.3H76.62L64.2,109.85a1.65,1.65,0,0,0-.77-2.2,1.77,1.77,0,0,0-.72-.17h-.14a1.65,1.65,0,0,0,.15,3.29,1.58,1.58,0,0,0,.71-.17l12.74,12.77H98.34l17.48-17.52h18.54v-1.08h-19ZM63.12,109.53a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,1.14,0A.54.54,0,0,1,63.12,109.53Z" style="fill:#c5c9e0"></path> </svg> </div>
</div>
<br><h2 id="域名相关">域名相关<a hidden class="anchor" aria-hidden="true" href="#域名相关">¶</a></h2>
<h3 id="什么是dns劫持">什么是DNS劫持<a hidden class="anchor" aria-hidden="true" href="#什么是dns劫持">¶</a></h3>
<p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p>
<p>通俗来讲：DNS劫持就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例，网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站，这就是DNS劫持。</p>
<p>DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p>
<p><strong>解决</strong>：对于DNS劫持，可以采用使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）。</p>
<h3 id="什么是dns污染">什么是DNS污染<a hidden class="anchor" aria-hidden="true" href="#什么是dns污染">¶</a></h3>
<p>DNS污染是指在DNS服务器中修改DNS解析结果的过程，以便将用户重定向到恶意网站或欺骗性网站，而不是所期望的目标网站。</p>
<p>攻击者可以通过多种方式进行DNS污染攻击。最常见的手段是在用户的网络中添加一个恶意DNS服务器，或者在受感染的计算机上运行一个恶意DNS服务器。当用户试图连接到互联网上的某个网站时，计算机将查询DNS服务器以查找目标网站的IP地址。如果攻击者控制的恶意DNS服务器已将相应的IP地址修改为攻击者的网站，则用户将被重定向到恶意网站或欺骗性网站。</p>
<p>DNS污染发生在用户请求的第一步上，直接从协议上对用户的DNS请求进行干扰。
DNS污染症状：目前一些被禁止访问的网站很多就是通过DNS污染来实现的，例如YouTube、Facebook等网站。</p>
<p><strong>解决</strong>：</p>
<ul>
<li>可靠的DNS服务器，但这种方式效果不佳</li>
<li>手动修改Hosts文件</li>
<li>使用VPN或域名远程解析
<ul>
<li>加密通信：VPN可以加密整个通信过程，这意味着攻击者无法窃取UDP数据包中的任何信息，包括DNS查询请求和响应。这样可以避免DNS查询被篡改的风险。</li>
<li>虚拟IP地址：VPN会给每个用户分配其所连接的虚拟IP地址，使用户的真实IP地址不会暴露在公共互联网中。这样，DNS服务器只能看到VPN服务器的IP地址，而无法识别用户的IP地址。这意味着攻击者无法跟踪用户的访问历史，从而减少遭受DNS污染攻击的风险。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：</p>
<p>DNS污染，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问Youtube、Facebook之类网站等出现的状况。</p>
<h3 id="什么是域名被墙">什么是域名被墙<a hidden class="anchor" aria-hidden="true" href="#什么是域名被墙">¶</a></h3>
<p>这种情况一般出现在解析为国外地址的域名上，假如域名下的网站非法信息多，敏感，又不整改，会直接被G.F.W墙掉，就是通常所说的被封锁、被屏蔽、被和谐，结果就是访问域名是打不开的，但是解析是正常的。此时域名在国内是无法使用的，国外可以访问和使用。</p>
<p>主要有以下几种情况：</p>
<ul>
<li>ip 被墙</li>
<li>解决：换 ip 。</li>
<li>域名被 url 重置（访问时出现ERR_CONNECTION_RESET 或 “连接重置”
<ul>
<li>换域名</li>
<li>做301跳转，(有专门服务商)，域名通过解析到国内301服务商，重定向到真是国外IP，以减少流量和权重的丢失。</li>
<li>上 https或域名备案，智能解析分国内，国外 。
<ul>
<li>可以使用HTTPS；一般来讲解析到国外的IP的域名，有敏感词会被重置，GFW可以进行敏感词检测（http为明文），使用https加密GFW无法检测数据包内容 ，（客户端与服务端默认会有公钥私钥，而GFW没有）。</li>
</ul>
</li>
</ul>
</li>
<li>域名被国家出口 dns 污染，解决：用国内 dns ，备案回国。</li>
<li>域名被省级 dns 污染，解决：能做到这个这里可能为内部或对应运营商被黑（只能进行dns清洗，一般大流量域名了）</li>
</ul>
<h3 id="什么是dns清洗">什么是DNS清洗？<a hidden class="anchor" aria-hidden="true" href="#什么是dns清洗">¶</a></h3>
<p>DNS清洗是一项旨在阻止访问特定网站和域名的措施，在该措施中，Internet服务提供商（ISP）通过其服务器筛选特定网站的DNS查询，并将查询重定向到一个错误的IP地址（通常是一个不存在的地址），从而防止用户访问该网站。这种措施通常是由政府、公司或组织实施，旨在防止用户接触到不适当、危险或非法的内容。</p>
<h2 id="网络攻击相关">网络攻击相关<a hidden class="anchor" aria-hidden="true" href="#网络攻击相关">¶</a></h2>
<h3 id="什么是tcp的syn攻击如何预防">什么是TCP的SYN攻击？如何预防？<a hidden class="anchor" aria-hidden="true" href="#什么是tcp的syn攻击如何预防">¶</a></h3>
<p>TCP SYN攻击是一种利用TCP协议三次握手机制的攻击。攻击者发送大量伪造的TCP SYN请求（数据包），然后在TCP三次握手建立连接的第二步时停止（使服务器不断地向攻击者发送SYN-ACK确认，但攻击者不回复ACK确认），从而导致服务器等待客户端的确认信号很长时间，最终占用服务器的资源而无法处理新的请求。</p>
<p>为了预防TCP SYN攻击，可以采取以下措施：</p>
<ol>
<li>服务器操作系统的设置：可以设置TCP的连接数和时间等参数，限制每个IP地址的连接数，设置连接超时时间。</li>
<li>防火墙设置：可以设置防火墙规则，根据IP地址、端口等信息对连接进行过滤，控制IP地址的访问等。</li>
<li>加强网络监测：使用入侵检测系统（IDS）对流量进行实时监控，并对异常流量进行报警处理。</li>
<li>使用SYN Cookies：SYN cookies是一种可以防止SYN攻击的技术，它通过特殊的算法对TCP连接进行加密，并保存在服务器端，当客户端发送响应时，服务器端可以对连接进行识别和验证，从而防止SYN攻击。</li>
<li>增加硬件设备：可以增加具有流量分析和过滤功能的硬件设备来协助防御SYN攻击，这种设备可以通过分析流量实现精细化的流量分析和识别。</li>
</ol>
<h3 id="ddos攻击的类型">ddos攻击的类型<a hidden class="anchor" aria-hidden="true" href="#ddos攻击的类型">¶</a></h3>
<p>DDoS攻击（Distributed Denial of Service）是一种利用许多计算机和网络设备构成的“僵尸网络”对一个或多个目标服务器发起攻击，从而占用大量的网络资源，耗尽系统资源，导致服务拒绝的攻击方式。DDoS攻击的类型可以分为以下几种：</p>
<ol>
<li>带宽攻击（Bandwidth-based Attack）：利用大量的数据流或报文，通过消耗目标系统的网络带宽使其服务不能正常传输。</li>
<li>应用层攻击（Application-Layer Attack）：利用正常流量模拟合法用户的请求，通过消耗服务器CPU和内存资源使其无法处理合法请求。</li>
<li>反射式攻击（Reflection Attack）：使用伪造的IP地址向网络中的一个或多个服务器发起请求，这些服务器会响应请求，但响应信息将被发回目标服务器，从而形成了一次反射式攻击。</li>
<li>慢速攻击（Slowloris Attack）：利用HTTP协议的设计漏洞，向目标服务器发送大量不完整请求，从而占用目标服务器处理请求的线程资源。</li>
<li>IoT攻击（IoT Attack）：通过侵入大量的物联网设备，如路由器、摄像头、智能家居等，利用这些设备来发起攻击，构建大规模的“僵尸网络”。</li>
<li>DNS Amplification攻击：攻击者向域名服务器发送请求，利用伪造的IP地址和请求报文，让服务器向目标主机发送大量的DNS解析响应数据包，从而使目标系统在短时间内遭受网络拥塞。</li>
<li>NTP Amplification攻击：攻击者伪造IP地址，向其余互联网上安装有网络时间服务器（Network Time Protocol，NTP）软件的服务器发送请求，从而获取大量NTP响应包，最终将其转发到目标IP地址，从而占用目标系统的网络带宽。</li>
<li>SYN Flood攻击：攻击者向目标服务器发送大量的TCP SYN请求，但却不发送客户端的应答确认，造成服务器长时间处于等待状态，无法接受正常的TCP连接请求。</li>
<li>HTTP Flood攻击：攻击者利用HTTP叠加攻击、HTTP POST攻击等手段，向目标系统发送大量HTTP请求和数据包，造成目标系统资源的耗尽，从而导致服务不可用。</li>
<li>ICMP Flood攻击：攻击者向目标系统发送大量的ICMP数据包，造成目标系统CPU和内存资源的消耗，从而导致系统缓慢或崩溃。</li>
</ol>
<h3 id="什么是反射式攻击">什么是反射式攻击<a hidden class="anchor" aria-hidden="true" href="#什么是反射式攻击">¶</a></h3>
<p>反射式攻击（Reflection  Attack）是一种利用网络协议的设计缺陷进行攻击的方式。攻击者通常会利用一些可以进行源地址欺骗或反射的协议，例如Domain Name  System（DNS），Simple Network Management Protocol（SNMP），和Network Time  Protocol（NTP）等。攻击者利用这些协议在网络中进行广播，构造一些请求消息，伪造源IP地址为目标IP地址，将请求消息发送给网络上的服务器，要求其向目标IP地址回送响应。这样攻击者就可以通过伪造的IP地址对目标系统进行攻击，占用它的网络带宽和资源，极大地降低了目标系统的可用性。</p>
<p>反射式攻击的原理：</p>
<ol>
<li>攻击者使用一个随机IP地址，向一个有可能反射请求的服务器发送一个请求包。</li>
<li>攻击者伪造请求包的源IP地址为目标IP地址。</li>
<li>服务器收到请求包后，会根据请求包中的信息回复一个响应包到目标IP地址。</li>
<li>攻击者的随机IP地址会收到一个错误的响应包，而目标IP地址会收到大量的响应包，引起服务器的网络拥塞和系统负载过高。</li>
<li>反射式攻击的特点是可以发动大规模的攻击，难以追踪攻击者的真实身份。</li>
</ol>
<p>为了避免反射式攻击带来的影响，应加强对网络设备的安全性监管，限制端口映射或在系统中配置反射式攻击防御机制等。</p>
<h3 id="什么是cc攻击">什么是CC攻击<a hidden class="anchor" aria-hidden="true" href="#什么是cc攻击">¶</a></h3>
<p>CC攻击是一种网络攻击，也称为HTTP CC攻击。</p>
<p>CC是英文“Challenge Collapsar”的缩写，意思是“挑战式崩溃”。这种攻击通常是攻击者使用大量的机器在同一时间，对目标网站发送数以万计的HTTP请求，耗费网站的带宽和Web服务器资源，从而使得目标网站难以提供正常的服务。</p>
<p>CC 攻击的原理：</p>
<ol>
<li>攻击者使用大量的机器，在短时间内对目标网站发送大量的请求，即HTTP GET和HTTP POST请求。</li>
<li>攻击者使用IP地址欺骗进行伪造，以避免被目标网站发现。</li>
<li>目标网站在处理大量请求的同时，网络带宽和服务器资源被消耗，导致无法正常处理合法用户的请求。</li>
<li>这种攻击方式是一种专门针对Web应用的攻击，能够对目标网站造成极大的破坏。</li>
</ol>
<p>CC攻击具有隐蔽性强、攻击目标精准、攻击规模大的特点，对于商业网站和金融机构等重要场所，尤其危害性较高。为了防范CC攻击，应采用一系列的安全措施，包括但不限于：IP限制、用户访问控制、流量清洗系统、高级请求监控和识别等。</p>
<h3 id="cc攻击和ddos攻击有什么区别">cc攻击和ddos攻击有什么区别<a hidden class="anchor" aria-hidden="true" href="#cc攻击和ddos攻击有什么区别">¶</a></h3>
<p>CC攻击和DDoS攻击都是一种网络攻击方式，但它们具有不同的特点和目的，可以通过以下几个维度进行区分：</p>
<ol>
<li>发起机制：DDoS攻击通常使用由许多受感染的计算机组成的僵尸网络向目标服务器发起攻击；而CC攻击则利用大量的请求浪费目标网站的资源，其通常由单个或少量主机发起。</li>
<li>对服务器的影响：DDoS攻击通常通过占用服务器的网络带宽和处理能力消耗服务器资源，从而使服务器无法处理合法的请求。而CC攻击通常会利用大量的HTTP请求消耗目标服务器的网络带宽和Web服务器资源，从而使目标网站无法提供正常的服务。</li>
<li>目的不同：DDoS攻击的目的通常是摧毁或瘫痪目标网站，其目的往往是为了实现利润或危害竞争对手。而CC攻击通常用于使目标网站的网络带宽和服务器资源不可用，以达到一定的干扰或损坏目的。</li>
<li>防御方式：DDoS攻击通常需要综合多种防护手段，包括入侵检测系统、防火墙、流量清洗系统等；而CC攻击通常可以通过增加带宽、配置IP限制、使用反垃圾过滤系统等简单的措施进行防御。</li>
</ol>
<p>总的来说，CC攻击主要针对Web应用程序和网站，其攻击手段比DDoS攻击更加简单和直接，而DDoS攻击则涉及到更多的计算机协调，其对目标服务器造成的影响也更为广泛和严重。</p>
<h3 id="dbus攻击">DBus攻击<a hidden class="anchor" aria-hidden="true" href="#dbus攻击">¶</a></h3>
<p>DBus（Desktop Bus）是用于在Linux系统中应用程序之间进行通信的一种机制。DBus通信协议是所有Linux桌面环境（如GNOME和KDE）的核心组件。DBus协议本身并没有安全问题，但是由于应用程序在通信时可能会使用明文传输敏感信息（例如登录密码），因此DBus协议仍然存在被黑客攻击的风险。</p>
<p>DBus攻击主要有以下几种方式</p>
<ol>
<li>端口监听攻击：DBus默认使用unix-socket，如果未被正确配置只能在特定用户之间使用。如果DBus暴露在公网上，并启用了TCP/IP支持，则可能会受到端口监听攻击。</li>
<li>消息劫持攻击：假冒攻击者可以伪造DBus通信的结构头和消息体，并将其发送到目标程序。这样可以使目标程序对不良消息进行响应并以不合适的方式执行命令或泄漏敏感信息。</li>
<li>执行命令攻击：攻击者可以通过发送DBus消息来请求目标程序执行特定的操作。如果目标程序没有执行严格的访问控制，那么攻击者可能会成功执行恶意操作。</li>
</ol>
<p>为了防止DBus攻击，可以采取以下预防措施：</p>
<ol>
<li>使用策略控制：通过在DBus配置文件中设置安全策略，在文件中定义一系列规则，以控制哪些应用程序可以访问DBus总线，以及哪些应用程序可以以哪种方式访问DBus总线。</li>
<li>使用加密通信：可以使用SSL或TLS等安全协议对DBus通信进行加密，以确保DBus通信传输的数据不会被窃取或篡改。</li>
<li>调用API实现过滤和审核：可以通过DBus接口的API调用来检查和验证DBus消息中的请求和响应是否合法，如果失败，则拒绝执行DBus请求命令。</li>
<li>更新操作系统和软件：可以定期更新Linux操作系统和DBus相关软件的版本，以修复可能出现的安全漏洞，从而提高DBus协议的安全性。</li>
</ol>
<p>综上所述，DBus协议是任何Linux桌面环境中的核心组件，因此必须采取一系列的安全预防措施防止攻击者利用漏洞对DBus协议进行攻击。</p>
<h2 id="网络相关">网络相关<a hidden class="anchor" aria-hidden="true" href="#网络相关">¶</a></h2>
<h3 id="osi模型和tcpip模型有什么区别">OSI模型和TCP/IP模型有什么区别？<a hidden class="anchor" aria-hidden="true" href="#osi模型和tcpip模型有什么区别">¶</a></h3>
<p>OSI模型和TCP/IP模型都是网络通信时使用的通信协议模型</p>
<ul>
<li>
<p>OSI模型通常表示一个网络请求的完整路径，而TCP/IP模型通常表示Linux 内核网络栈中的模型</p>
</li>
<li>
<p>OSI模型包括7个层次：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
</li>
<li>
<p>TCP/IP模型则是由4个层次组成：网络接口层、网络层、传输层和应用层</p>
</li>
</ul>
<h3 id="简述tcp重传时的ack机制">简述TCP重传时的ACK机制？<a hidden class="anchor" aria-hidden="true" href="#简述tcp重传时的ack机制">¶</a></h3>
<p>TCP协议中的重传机制是保证数据传输可靠性的关键，它使用一个称为确认（ACK）的机制来标记接收到的数据段。TCP准确地检测丢失或重复数据包，并要求发送方重发丢失的数据包，直到接收方确认收到该数据包。</p>
<p>当TCP发送方发现某个数据包未收到确认时，会启动重传机制。它会重发此数据包并设置一个计时器，在计时器超时前等待接收方的确认，并在接收方回复确认后将计时器停止。如果在计时器超时之前，没有收到确认，则认为此数据包丢失，就会重发相同的数据包，并随之设置新的计时器。</p>
<p>每次成功发送数据包后，TCP发送方将等待接收方发回一个相应的确认，以确认数据包已经被正确接收。接收方会在ACK中包含一个确认号（ACK number），该数值表示收到的最后一个正确的数据包的编号，这表明它准备接收下一数据包并告诉发送端可以继续发送数据。</p>
<p>总之，TCP重传时的ACK机制，是通过发送数据包、等待接收方确认、超时时间检测等多步操作来检查数据包传输是否能够成功到达，同时保证数据的可靠传输。</p>
<h3 id="常见的tcp连接报错有哪些">常见的TCP连接报错有哪些?<a hidden class="anchor" aria-hidden="true" href="#常见的tcp连接报错有哪些">¶</a></h3>
<ul>
<li>
<p><strong>Connection reset by peer</strong>：通常是由于远程端重置连接造成的，发送的是 <code>RST</code> 强制中断连接</p>
<ul>
<li>
<p>这类问题主要发生在连接关闭的情况下，在tcp连接中，双方是对等连接 <code>peer</code>，当数据包从连接的一端发送，但另一端无法识别到连接时，会返回设置了<code>RST</code>位的数据包，用来强制关闭连接。</p>
</li>
<li>
<p>通常情况下，会立即中断连接，并且绕过了正常关闭的2MSL时间。例如：</p>
<ul>
<li>客户端关闭了连接，而服务器还在给客户端发送数据。</li>
<li>服务器超载，服务端强制关闭掉一些连接。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Connection timeout</strong>：般为建立连接在最大超时时间后没有收到来自服务端的相应，此时客户端将收到错误信息。</p>
</li>
<li>
<p><strong>Connection refused</strong>：通常出现在连接某一服务的端口时发生（拒绝机制是 TCP <code>RST</code> 标志），通常情况下包含一下情况：</p>
<ul>
<li>目标主机端口未开放</li>
<li>端口开放了，但处理其连接堆积或已满。</li>
<li>客户端与服务端防火墙阻碍其连接。（客户端和服务端防火墙均会发生）</li>
</ul>
</li>
<li>
<p><strong>Port Unavailable</strong>：通常由于TCP连接的目标端口已经被占用, 或是网络路由器的设置引起的。</p>
</li>
<li>
<p><strong>Host Unreachable</strong>：主机不可达错误通常由于网络路由故障引起的，它表示目标主机无法被连接，有可能是由于网络故障或是DNS解析错误引起的。</p>
</li>
</ul>
<h3 id="什么是tcp-resetrst">什么是TCP Reset（RST）<a hidden class="anchor" aria-hidden="true" href="#什么是tcp-resetrst">¶</a></h3>
<p>当收到意外数据包（非正常3次握手进行的连接）到达主机时，此时会重置连接，重置的数据包是设置了<code>RST位</code>的数据包。</p>
<p>常见的有以下情况：</p>
<ul>
<li>一个初始数据包 (初始数据包<code>SYN</code>) 尝试向一个没有任何进程的监听地址发起连接时，会出现次状态（如：<code>curl localhost $non-listen-port</code>）</li>
<li>在之前建立的连接，并且本地已经关闭socket或退出。</li>
<li>防火墙的拦截</li>
</ul>
<p>数据包到达先前建立的TCP连接，但本地应用程序已关闭其套接字或退出，并且操作系统已关闭该套接字。</p>
<h3 id="常见tcp的连接状态有哪些">常见TCP的连接状态有哪些？<a hidden class="anchor" aria-hidden="true" href="#常见tcp的连接状态有哪些">¶</a></h3>
<p><strong>三次握手期间</strong>：</p>
<ul>
<li>
<p>CLOSED：初始状态。</p>
</li>
<li>
<p>LISTEN：服务器处于监听状态。</p>
</li>
<li>
<p>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</p>
</li>
<li>
<p>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</p>
</li>
<li>
<p>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后 进入此状态。</p>
</li>
</ul>
<p><strong>四次挥手期间</strong>：</p>
<ul>
<li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li>
<li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之  后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN  包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li>
<li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器 的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li>
<li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li>
<li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，为此之后的2MSL时间 客户端为TIME_WAIT状态。</li>
</ul>
<h3 id="close_wait状态的产生危害如何避免">CLOSE_WAIT状态的产生、危害、如何避免？<a hidden class="anchor" aria-hidden="true" href="#close_wait状态的产生危害如何避免">¶</a></h3>
<p>客户端TCP状态迁移：</p>
<pre><code>CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED
</code></pre>
<p>服务器TCP状态迁移：</p>
<pre><code>CLOSED-&gt;LISTEN-&gt;SYN_RECV-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSED
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20220408183308968-1567213936.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>【答】：</p>
<p><strong>产生</strong>: TCP连接的两端都可以发起关闭连接的请求，若对端发起了关闭连接，但本地没有进行后续的关闭连接操作，那么该链接就会处于<code>CLOSE_WAIT</code>状态。</p>
<ul>
<li>在某种情况下应用关闭了socket连接,但是服务端忙于读或者写，没有关闭连接。</li>
<li>在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。通常来讲，CLOSE_WAIT状态的持续时间应该很短，正如SYN_RCVD状态。但是在一些特殊情况下，就会出现连接长时间处于CLOSE_WAIT状态的情况。</li>
</ul>
<p><strong>危害</strong>：<code>CLOSE_WAIT</code> 会使连接处于假死状态，连接本身占用的资源不会被释放。网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。</p>
<p><strong>如何避免</strong>：</p>
<p>更详细分析可以看：https://www.cnblogs.com/shengs/p/4495998.html</p>
<h3 id="tcp的关闭">TCP的关闭<a hidden class="anchor" aria-hidden="true" href="#tcp的关闭">¶</a></h3>
<p>TCP 支持两种类型的连接释放：</p>
<ul>
<li>
<p>优雅关闭：正常的四次挥手</p>
</li>
<li>
<p>突然关闭：发送RST段，即TCP Reset</p>
<ul>
<li>当为不存在的 TCP 连接接收到非 SYN 段时</li>
<li>在已打开的连接中，某些 TCP 实现会在收到具有无效标头的段时会发送 RST 段。  这将通过关闭相应的连接来防止攻击。</li>
<li>当某些实现需要关闭现有的 TCP 连接时，它们会发送一个 RST 段。  将立即关闭现有的 TCP 连接：
<ul>
<li>缺乏支持连接的资源</li>
<li>远程主机现在无法访问并且已停止响应</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="time_wait-状态的产生危害如何避免">TIME_WAIT 状态的产生、危害、如何避免？<a hidden class="anchor" aria-hidden="true" href="#time_wait-状态的产生危害如何避免">¶</a></h3>
<p>【答】：</p>
<p><strong>产生</strong>：TCP在关闭连接的四次挥手中，为了应对最后一个ACK 丢失的情况，Client(主动关闭的一方)需要维持TIME_WAIT状态，并停留2MSL的时间。</p>
<p><strong>危害</strong>：</p>
<ul>
<li>浪费系统资源：大量的TIME_WAIT状态会占用系统资源（用户的文件句柄 如端口）</li>
<li>降低系统性能：</li>
</ul>
<p><strong>如何避免</strong>：在 <code>/etc/sysctl.conf</code>文件中开启 <code>net.ipv4.tcp_tw_reuse</code>重用，和<code>net_ipv4.tcp.tw_recycle</code> 快速回收。</p>
<h3 id="time_wait-和-close_wait区别">TIME_WAIT 和 CLOSE_WAIT区别<a hidden class="anchor" aria-hidden="true" href="#time_wait-和-close_wait区别">¶</a></h3>
<ul>
<li>主动关闭的一端是 <code>TIME_WAIT</code>；即客户端主动关闭<code>TIME_WAIT</code>出现在客户端，服务端主动关闭 <code>TIME_WAIT</code>出现在服务端</li>
<li>被动关闭的一端是 <code>CLOSE_WAIT</code>；通常情况下，服务端会维护大量的<code>CLOSE_WAIT</code></li>
<li>服务端出现 <code>CLOSE_WAIT</code>则客户端永远不会出现 <code>TIME_WAIT</code>
<ul>
<li><code>CLOSE_WAIT</code> 一般发生在服务在接收到关闭信号后没有正确关闭连接</li>
<li><code>TIME_WAIT</code> 会随着2MSL的时长而积压</li>
<li>服务端 在 发送 两次 ACK 与 FIN后，即收到<code>FIN</code>后客户端（主动断开端）才会转变为 <code>TIME_WAIT</code></li>
<li>结束CLOSE_WAIT状态，对应的应用程序必须显式关闭打开套接字（或退出）</li>
</ul>
</li>
</ul>
<blockquote>
<p>ss命令可以强制关闭套接字
ss &ndash;tcp state CLOSE-WAIT &ndash;kill 关闭对应状态的连接
ss &ndash;tcp state CLOSE-WAIT &lsquo;( dport = 22 or dst 1.1.1.1 )&rsquo; &ndash;kill 过滤操作</p>
</blockquote>
<h3 id="2msl的值是多少">2MSL的值是多少？<a hidden class="anchor" aria-hidden="true" href="#2msl的值是多少">¶</a></h3>
<p>2MSL (<em><strong>Maximum Segment Lifetime</strong></em>) 作为TCP 连接的“关闭”过程的一部分，是在 <a href="https://datatracker.ietf.org/doc/html/rfc793" target="_blank"
   rel="noopener nofollow noreferrer" >RFC 793(TCP)</a>，Linux内核的默认MSL设置为 60 秒，2MSL为120s，可以通过<code>cat /proc/sys/net/ipv4/tcp_fin_timeout</code>查看。</p>
<p>在 Check Point VPN网关中，R80.20 及更高版本中，默认的 TCP 超时5秒。</p>
<blockquote>
<p>Reference</p>
<p><a href="https://supportcenter.checkpoint.com/supportcenter/portal?eventSubmit_doGoviewsolutiondetails=&amp;solutionid=sk121673" target="_blank"
   rel="noopener nofollow noreferrer" >2MSL</a></p>
</blockquote>
<h3 id="为什么客户端要等2msl">为什么客户端要等2MSL<a hidden class="anchor" aria-hidden="true" href="#为什么客户端要等2msl">¶</a></h3>
<p>TCP / IP协议中使用2MSL来等待连接中的可能尚未到达的遗留数据包。当一个TCP连接关闭时，每个端口必须等待2MSL时间，以确保对方端口正确接收了所有数据段。以下是对不同情况下等待时间的解释：</p>
<ul>
<li>如果等待时间小于1MSL，可能会有数据包丢失，从而导致通信不完整。</li>
<li>如果等待时间等于1MSL，TCP连接完成后，存在某些可能尚未到达的数据包，这些数据包在此时间段内将没有机会重传，因此可能会导致通信不完整。</li>
<li>如果等待时间大于2MSL，虽然可以确保数据包被完全接收并处理，但是长时间的等待可能会影响网络效率并占用网络资源。</li>
</ul>
<p>因此，2MSL时间是一个标准和安全的等待时间，可确保TCP连接关闭时没有未接收的数据包。</p>
<p>《UNIX网络编程(卷1)》提到，TIME_WAIT的作用大概是下述两部分：</p>
<ul>
<li>实现可靠地TCP连接终止
<ul>
<li>为了可靠的终止TCP的全双工连接，当客户端发送的最后一个ACK丢失，服务端会重传FIN，为了接收超时并重传FIN，客户端就需要一个TIME_WAIT，如果RTO（<code>Retransmission Timeout</code>）小于MSL，那么TIME_WAIT的大小为MSL就足够了，如果RTO大于2MSL，则TIME_WAIT大小为2MSL已经不够了，所以只有TIME_WAIT状态介于 MSL与2MSL之间，才实现可靠地TCP连接终止。通常情况下RTO要比MSL小很多，但是考虑到最糟糕的情况，RTO是2MSL</li>
</ul>
</li>
<li>允许旧的重复段在网络中过期
<ul>
<li>为了保证在这个连接期间产生的所有数据包都从网络中消失，即保证在建立新的TCP连接时，来自该连接的旧的重复数据包已经在网络中消失了；</li>
<li>此时存在一个问题：当客户端回复最后一个ACK后，用一个MSL时间就可以断开双方的连接（所有的数据包都消失）。为什么需要2MSL才可以？
<ul>
<li>这是因为假设在客户端发送ACK刚刚过了一个MSL时间，而服务端在收到这个ACK之前一瞬间刚好启动超时重传FIN，所以要等这个FIN也消失，就是2MSL了。文中所指的另一个方向的应答应该就是这个超时重传的FIN。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Reference</p>
<p><a href="https://stackoverflow.com/questions/25338862/why-time-wait-state-need-to-be-2msl-long" target="_blank"
   rel="noopener nofollow noreferrer" >why time wait state need to be 2msl long</a></p>
<p><a href="https://www.ques10.com/p/21499/in-the-tcp-state-transition-diagram-why-do-we-have/" target="_blank"
   rel="noopener nofollow noreferrer" >in the tcp state transition diagram why do we have</a></p>
</blockquote>
<h3 id="rto和msl">RTO和MSL<a hidden class="anchor" aria-hidden="true" href="#rto和msl">¶</a></h3>
<p>RTO和MSL是两个完全独立的定义，它们之间没有特定的依赖关系。RTO是一个时间间隔，在未收到对方确认的情况下触发重传，并根据网络连接的延迟和拥塞情况进行调整。而MSL则是一个固定的时间，在TCP连接关闭后，用于保持最后的ACK数据包保持活动状态的时间。</p>
<p>尽管RTO和MSL没有直接关联，但是RTO和MSL都涉及到TCP数据包的传输和处理。RTO值需要在某些情况下限制其最小值，以避免过度等待，例如在快速重传和快速恢复等TCP机制中。而MSL在TCP数据包传输网络中扮演着非常重要的角色，以确保在TCP连接关闭后遗留的数据包都能达到其目的地，同时避免后续的混淆与冲突。</p>
<p>RTO和MSL是TCP / IP协议中的两个超时机制，这些机制都与传输控制协议（TCP）的数据包传输相关。以下是它们之间的区别：</p>
<ul>
<li>RTO (Retransmission Time Out)：是指在TCP / IP网络中，当一个数据包发送后，期望在多长时间内收到对方回应的时间。如果在该时间内没有收到回应，则认为该数据包已丢失，发起重传。RTO时间间隔通常根据TCP窗口大小调整，一般都比MSL的时间间隔短。</li>
<li>MSL (Maximum Segment Lifetime)：是指在TCP网络中，一个数据包在网络中传输的最长时间。当超过这个时间后，该数据包将被认为已经过期并被丢弃。通常，MSL是30秒，是一个相对不变的时间阈值，不会随着网络的突发变化而发生变化。</li>
</ul>
<p>总的来说，RTO和MSL都是与TCP传输相关的超时机制，但它们的目的和应用场景略有区别：RTO用于控制未收到响应时的重传时间间隔，而MSL用于控制关闭连接后等待可能未到达的数据包的最长时间。</p>
<h3 id="tcp-和-udp-的区别">TCP 和 UDP 的区别？<a hidden class="anchor" aria-hidden="true" href="#tcp-和-udp-的区别">¶</a></h3>
<p>TCP是稳定、可靠、⾯向连接的传输层协议，它在传递数据前要三次握⼿建⽴连接，在数据传递时，有确认机制、重传机制、流量控制、拥塞控制等，可以保证数据的正确性和有序性。
UDP是⽆连接的数据传输协议，端与端之间不需要建⽴连接，且没有类似TCP的那些机制，会发⽣丢包、乱序等情况。</p>
<p><em><strong>TCP是数据流模式，⽽UDP是数据报模式。</strong></em></p>
<h3 id="为什么-tcp-叫数据流模式-udp-叫数据报模式">为什么 TCP 叫数据流模式？ UDP 叫数据报模式？<a hidden class="anchor" aria-hidden="true" href="#为什么-tcp-叫数据流模式-udp-叫数据报模式">¶</a></h3>
<p>【答】：<strong>最大的一个区别就是，TCP包头允许数据的分段，会携带每段的编号，而UDP只携带数据长度及校验码</strong></p>
<p>所谓的“流模式”，是指TCP发送端发送⼏次数据和接收端接收⼏次数据是没有必然联系的，⽐如你通过 TCP 连接给另⼀端发送数据，你只调⽤了⼀次 write，发送了100个字节，但是对⽅可以分10次收完，每次10个字节；你也可以调⽤10次 write，每次10个字节，但是对⽅可以⼀次就收完。</p>
<p>原因：这是因为TCP是⾯向连接的，⼀个 socket 中收到的数据都是由同⼀台主机发出，且有序地到达，所以每次读取多少数据都可以。</p>
<p>所谓的“数据报模式”，是指UDP发送端调⽤了⼏次 write，接收端必须⽤相同次数的 read 读完。UDP 是基于报⽂的，在接收的时候，每次最多只能读取⼀个报⽂，报⽂和报⽂是不会合并的，如果缓冲区⼩于报⽂⻓度，则多出的部分会被丢弃。</p>
<p>原因：这是因为UDP是⽆连接的，只要知道接收端的 IP 和端⼝，任何主机都可以向接收端发送数据。 这时候， 如果⼀次能读取超过⼀个报⽂的数据， 则会乱套</p>
<h3 id="tcp建连接为什么需要三次断开连接为什么需要四次">TCP建⽴连接为什么需要三次？断开连接⼜为什么需要四次？<a hidden class="anchor" aria-hidden="true" href="#tcp建连接为什么需要三次断开连接为什么需要四次">¶</a></h3>
<p>【答】：</p>
<p><strong>“三次握⼿”的主要⽬的是为了防⽌已失效的连接请求报⽂段突然⼜传送到了服务端，因⽽产⽣错误。</strong></p>
<p>例如：client发出的第⼀个连接请求报⽂段并没有丢失，⽽是在某个⽹络结点⻓时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是⼀个早已失效的报⽂段。但server收到此失效的连接请求报⽂段后，就误认为是client再次发出的⼀个新的连接请求。于是就向client发出确认报⽂段，同意建⽴连接。假设不采⽤“三次握⼿”，那么只要server发出确认，新的连接就建⽴了。由于现在client并没有发出建⽴连接的请求，因此不会理睬server的确认，也不会向server发送ack包。</p>
<p><strong>“四次挥⼿”主要是为了确保数据能够完成传输。</strong></p>
<p>因为TCP连接是全双⼯的(即数据可在两个⽅向上同时传递)，关闭连接时，当收到对⽅的FIN报⽂通知时，它仅仅表示对⽅没有数据发送给你了；但未必你所有的数据都全部发送给对⽅了，所以你可以未必会⻢上会关闭SOCKET,也即你可能还需要发送⼀些数据给对⽅之后，再发送FIN报⽂给对⽅来表示你同意现在可以关闭连接了，所以它这⾥的ACK报⽂和FIN报⽂多数情况下都是分开发送的。</p>
<h3 id="tcp协议如何提供可靠性的">TCP协议如何提供可靠性的？<a hidden class="anchor" aria-hidden="true" href="#tcp协议如何提供可靠性的">¶</a></h3>
<p>TCP的可靠，因为它使用校验和进行错误检测，尝试通过重新传输、确认策略和计时器来恢复丢失或损坏的数据包。它使用字节数和序列号以及确认号等特性来确保可靠性。</p>
<h3 id="tcp-flags">TCP Flags<a hidden class="anchor" aria-hidden="true" href="#tcp-flags">¶</a></h3>
<p>TCP有6个Flag</p>
<ul>
<li>SYN <strong>(synchronize)</strong>，初始化一个连接的标识</li>
<li>ACK <strong>(acknowledgment)</strong>；用于确认数据包已收到，用于确认建立连接和关闭连接的</li>
<li>RST <strong>(reset)</strong>；表示连接已关闭，或者服务可能不接受请求</li>
<li>FIN <strong>(finish)</strong>；表示正在断开连接。发送方和接收方都发送 FIN 数据包以优雅地终止连接</li>
<li>PSH <strong>(push)</strong>；表示传入的数据应该直接传递给应用程序，而不是被缓冲</li>
<li>URG <strong>(urgent)</strong>；表示数据包所携带的数据应立即由 TCP 堆栈处理</li>
</ul>
<h3 id="dns使什么协议">DNS使⽤什么协议？<a hidden class="anchor" aria-hidden="true" href="#dns使什么协议">¶</a></h3>
<p>DNS服务器间进⾏域传输的时候使⽤ TCP 53；</p>
<p>客户端查询DNS服务器时使⽤ UDP 53，但当DNS查询超过512字节，TC标志出现时，使⽤TCP发送。</p>
<p>这是因为以太⽹(Ethernet)数据帧的⻓度必须在46-1500字节之间，这是由以太⽹的物理特性决定的。这个数据帧⻓度被称为链路层的MTU（最⼤传输单元）—— 实际Internet上的标准MTU值为576字节，也就是说链路层的数据区（不包括链路层的头部和尾部）被限制在576字节，所以这也就是⽹络层IP数据报的⻓度限制。</p>
<p>因为IP数据报的⾸部为20字节，所以IP数据报的数据区⻓度最⼤为556字节。⽽这个556字节就是⽤来放TCP报⽂段或UDP数据报的。我们知道UDP数据报的⾸部8字节，所以UDP数据报的数据区最⼤⻓度为548字节。—— 如果UDP数据报的数据区⼤于这个⻓度，那么总的IP数据包就会⼤于MTU，这个时候发送⽅IP层就需要分⽚(fragmentation)，把数据报分成若⼲⽚，使每⼀⽚都⼩于MTU，⽽接收⽅IP层则需要进⾏数据报的重组。由于UDP的特性，当某⼀⽚数据传送中丢失时，接收⽅将⽆法重组数据报，从⽽导致丢弃整个UDP数据报。所以通常UDP的最⼤报⽂⻓度就限制为512字节或更⼩。</p>
<h3 id="tcp的拥塞控制机制是什么请简单说说">TCP的拥塞控制机制是什么？请简单说说。<a hidden class="anchor" aria-hidden="true" href="#tcp的拥塞控制机制是什么请简单说说">¶</a></h3>
<h3 id="ip报文中ttl字段作用">IP报文中TTL字段作用<a hidden class="anchor" aria-hidden="true" href="#ip报文中ttl字段作用">¶</a></h3>
<p>可用于防止数据包循环</p>
<h3 id="什么是tcp-rto">什么是TCP RTO？<a hidden class="anchor" aria-hidden="true" href="#什么是tcp-rto">¶</a></h3>
<p>TCP RTO是TCP数据包在发送后到接收ACK之间的超时时间。如果在这个时间内没有收到ACK，则认为数据包已经丢失，需要进行重传。RTO的值是根据网络延迟、带宽和网络拥堵等多种因素计算得出的。</p>
<h3 id="如何调整tcp-rto">如何调整TCP RTO？<a hidden class="anchor" aria-hidden="true" href="#如何调整tcp-rto">¶</a></h3>
<p>TCP RTO的调整需要根据实际的网络环境进行，可以通过以下几种方法进行：</p>
<ul>
<li>内核参数调整：可以通过调整内核参数来改变TCP RTO的计算公式，从而适应不同的网络环境；</li>
<li>使用拥塞控制算法：可以通过改变TCP的拥塞控制算法来影响RTO的调整；</li>
<li>优化网络拓扑结构：通过优化网络拓扑结构，如改变路由器的位置、增加网络带宽等，可以有效地降低RTO的值。</li>
</ul>


    
    


<div class="copyrightBlock" >
    <div class="articleSuffix-bg"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 147.78 155.96"> <path d="M10.5,99.81a1.9,1.9,0,0,0-.53-.09,1.66,1.66,0,0,0-1.64,1.65A1.64,1.64,0,0,0,10,103a1.57,1.57,0,0,0,.87-.25l26.76,26.82.45-1.08L11.52,101.91A1.65,1.65,0,0,0,10.5,99.81Zm-.13,2a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.58.58,0,0,1,.57-.57h0a.57.57,0,0,1,.56.58A.55.55,0,0,1,10.37,101.77Z" style="fill:#c5c9e0"></path><path d="M56.15,117.58H39.06l0-.09a1.65,1.65,0,0,0-1.36-1H37.5a1.65,1.65,0,1,0,1.56,2.19H55.7L92.92,156h41.44v-1.08h-41Zm-18.25.94a.56.56,0,0,1-.79,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h0a.58.58,0,0,1,.57.58A.54.54,0,0,1,37.9,118.52Z" style="fill:#c5c9e0"></path><path d="M23.52,50.32a1.65,1.65,0,0,0,1.55-1.11H55.28l48-48.13h31.06V0H102.85l-48,48.13H25.07a1.64,1.64,0,0,0-2.09-1,1.64,1.64,0,0,0,.54,3.2Zm0-2.21a.57.57,0,0,1,0,1.13.57.57,0,1,1,0-1.13Z" style="fill:#c5c9e0"></path><polygon points="102.86 0 102.86 0 102.86 0 102.86 0" style="fill:#c5c9e0"></polygon><path d="M107.72,12.14h26.64V11.07H107.27L57.4,61H3.09a1.66,1.66,0,0,0-1.45-.86H1.52A1.65,1.65,0,1,0,2.81,63a1.59,1.59,0,0,0,.45-.87H57.85ZM2.05,62.23a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h.09a.57.57,0,0,1,.32,1Z" style="fill:#c5c9e0"></path><path d="M134.36,43.22V42.14h-22.3l-9.62,9.63a1.64,1.64,0,0,0-2.19.77,1.61,1.61,0,0,0-.17.71,1.65,1.65,0,1,0,3.29,0,1.61,1.61,0,0,0-.16-.72l9.3-9.32Zm-32.64,10.6a.57.57,0,0,1,0-1.13.57.57,0,0,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M147,52.3l-9,9H111.48a1.64,1.64,0,0,0-1.61-1.33h-.14a1.65,1.65,0,1,0,1.6,2.41h27.19l9.26-9.29L147,52.3Zm-37.15,9.85a.56.56,0,0,1-.56-.57h0a.56.56,0,0,1,.56-.56h0a.57.57,0,1,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M66.79,75.35l11,11.06h56.53V85.33H78.27l-11-11.06H49.49L37.12,86.67a1.64,1.64,0,0,0-2.09,1,1.61,1.61,0,0,0-.09.54,1.65,1.65,0,0,0,3.29,0,1.68,1.68,0,0,0-.26-.89l12-12ZM36.58,88.79a.57.57,0,1,1,.57-.56A.57.57,0,0,1,36.58,88.79Z" style="fill:#c5c9e0"></path><path d="M110.61,95.55,92.8,113.4a1.62,1.62,0,1,0,.77.76l17.49-17.53h23.31V95.55ZM92.49,115.28a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.57-.57h0a.58.58,0,0,1,.56.58A.55.55,0,0,1,92.49,115.28Z" style="fill:#c5c9e0"></path><path d="M97.89,122.3H76.62L64.2,109.85a1.65,1.65,0,0,0-.77-2.2,1.77,1.77,0,0,0-.72-.17h-.14a1.65,1.65,0,0,0,.15,3.29,1.58,1.58,0,0,0,.71-.17l12.74,12.77H98.34l17.48-17.52h18.54v-1.08h-19ZM63.12,109.53a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,1.14,0A.54.54,0,0,1,63.12,109.53Z" style="fill:#c5c9e0"></path> </svg> </div>
    <p>本文发布于<a href="https://www.oomkill.com/about" target="_blank">Cylon的收藏册</a>，转载请著名原文链接~</p>
    <p>链接：<a href="https://www.oomkill.com/2021/10/interview-network/" target="_blank">https://www.oomkill.com/2021/10/interview-network/</a></p>
    <p style="margin-bottom: 0px;">版权：本作品采用<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">「署名-非商业性使用-相同方式共享 4.0 国际」</a> 许可协议进行许可。</p>
    </div>
</div>
  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://www.oomkill.com/2021/10/interview-monitor/">
    <span class="title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select: text;"><line x1="19" y1="12" x2="5" y2="12" style="user-select: text;"></line><polyline points="12 19 5 12 12 5" style="user-select: text;"></polyline>
      </polyline></svg>&nbsp; </span>
    
    <span>监控类面试题</span>
  </a>
  <a class="next" href="https://www.oomkill.com/2021/10/interview-om/" >
    <span class="title"> </span>
    
    <span>运维类面试题收集&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg></span>
  </a>
</nav>

  </footer>

  
  <div class="pagination__title">
    <span class="pagination__title-h"></span>
  </div>
  
  
  
  
    <div class="comments-separator"></div>
    

<h3 class="relatedContentTitle" >相关阅读</h3>
<ul class="relatedContent">
	
	<li><a href="/2021/06/understand-hole-punchine-mechnism/"><span>P2P打洞技术</span></a></li>
	
	<li><a href="/2021/02/calico-network-policy/"><span>calico网络策略</span></a></li>
	
	<li><a href="/2021/02/linux-1692540024/"><span>Linux中169.254.0.0/24的路由来自哪里</span></a></li>
	
	<li><a href="/2021/01/arp-proxy-and-arp/"><span>ARP与ARP Proxy</span></a></li>
	
	<li><a href="/2021/01/dynamic-routing-bgp/"><span>动态路由- BGP</span></a></li>
	
</ul>

  

  
    
      <div class="comments-separator"></div>
<div class="comments">
    <script>
    function loadComment() {
        let theme = localStorage.getItem('pref-theme') === 'dark' ? 'dark' : 'light';
        let s = document.createElement('script');
        s.src = 'https://giscus.app/client.js';
        s.setAttribute('data-repo', 'cylonchau\/cylonchau.github.io');
        s.setAttribute('data-repo-id', 'R_kgDOIRlNSQ');
        s.setAttribute('data-category', 'Announcements');
        s.setAttribute('data-category-id', 'DIC_kwDOIRlNSc4CXy1U');
        s.setAttribute('data-mapping', 'title');
        s.setAttribute('data-reactions-enabled', '1');
        s.setAttribute('data-emit-metadata', '1');
        s.setAttribute('data-input-position', 'top');
        s.setAttribute('data-lang', 'zh-TW');
        s.setAttribute('data-theme', theme);
        s.setAttribute('crossorigin', 'anonymous');
        s.setAttribute('async', '');
        document.querySelector('div.comments').innerHTML = '';
        document.querySelector('div.comments').appendChild(s);
    }
    loadComment();
    </script>
</div>
</article>
    </main>
    
<footer class="footer">
  <p>
  Copyright
  <span>&copy; 2024 <a href="https://www.oomkill.com">Cylon&#39;s Collection</a></span></p>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> on github-page & Theme
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '1' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>

<script>
  document.addEventListener('scroll', function (e) {
      const readProgress = document.getElementById("read_progress");
      const scrollHeight = document.documentElement.scrollHeight;
      const clientHeight = document.documentElement.clientHeight;
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
  })
</script>

<script>
  var menu = document.getElementById('menu')
  if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
          localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
  }

  document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
          e.preventDefault();
          var id = this.getAttribute("href").substr(1);
          if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
              document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                  behavior: "smooth"
              });
          } else {
              document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
          }
          if (id === "top") {
              history.replaceState(null, null, " ");
          } else {
              history.pushState(null, null, `#${id}`);
          }
      });
  });
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
      if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
          mybutton.style.visibility = "visible";
          mybutton.style.opacity = "1";
      } else {
          mybutton.style.visibility = "hidden";
          mybutton.style.opacity = "0";
      }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

<script src="/js/instantclick.min.js" data-no-instant
></script>
<script data-no-instant>
  
  
  
  
  
  
  InstantClick.init();
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.6.0/mermaid.min.js" crossorigin="anonymous"></script>
<script>
    mermaid.init(undefined, '.language-mermaid');
</script>
</body>

</html>
